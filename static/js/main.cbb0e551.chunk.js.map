{"version":3,"sources":["modules/utils/getset.ts","modules/utils/index.ts","modules/utils/tuple.ts","modules/utils/array.ts","modules/utils/observable.ts","modules/utils/assert.ts","modules/utils/function.ts","modules/todo/types.ts","modules/operations/types.ts","modules/operations/utils.ts","modules/filter-todo/types.ts","apps/todo/components/Item.tsx","apps/todo/components/List.tsx","modules/filter-todo/assert.ts","modules/transactions/types.ts","modules/filter-todo/filter.ts","modules/state/stateOf.ts","modules/transactions/utils.ts","modules/transactions/index.ts","modules/filter-todo/observable.ts","apps/todo/Todo.tsx","modules/todo/api.ts","modules/todo/constants.ts","modules/todo/events.ts","modules/todo/utils.ts","modules/todo/effects.ts","modules/todo/observables.ts","modules/state/transactionalStateOf.ts","App.tsx","modules/state/makeTimeTravelable.ts","modules/state/createState.ts","apps/todo/observables.ts","modules/filter-todo/select.ts","serviceWorker.ts","index.tsx"],"names":["get","prop","object","set","value","Object","assign","first","second","tuple","a","b","thruple","c","arrayBimap","f","g","as","map","IS_TUPLE","isArray","dataIsTuple","data","Array","length","take","amount","xs","txs","len","i","push","once","output","identity","compose","EventType","Status","makeIsStatus","statusType","checkedStatus","statusTypeIsOk","Ok","statusTypeIsBad","Bad","statusTypeIsNoop","Noop","statusTypeIsPending","Pending","makeIsOperationOfStatus","operation","status","isOk","isBad","isNoop","isPending","makeNoop","state","toPending","action","FilterType","Item","props","title","todo","style","opacity","isDeleting","transition","icon","completed","theme","undefined","onClick","onSave","error","fontStyle","use","List","newTodo","new","onChangeNew","noop","evt","currentTarget","className","twoLine","onCompleteAll","fullwidth","placeholder","height","onChange","onKeyUp","keyCode","onSubmitNew","autoFocus","trailingIcon","todos","key","id","onEdit","Delete","renderList","TransactionType","makeIsFilterType","of","filterType","isFilterTypeAll","All","isFilterTypeCompleted","Completed","isFilterTypeActive","Active","makeFilterTodosByFilterType","filter","filterCompletedTodos","filterActiveTodos","stateOf","initialState","subject","BehaviorSubject","asObservable","next","getValue","makeTransactionMaker","type","payload","makeAddTransaction","Add","makeUpdateTransaction","Update","makeRemoveTransaction","Remove","add","transaction","concat","update","isEqual","t1","t2","forEach","record","index","findIndex","r","splice","remove","filterTypeState$","list","textAlign","marginTop","choice","justifyContent","label","onChangeFilterType","onClearComplete","color","failPattern","failIndex","getNextFailFlag","delay","ms","Promise","resolve","setTimeout","read","fetch","response","json","create","doFail","Math","floor","random","userId","Save","trim","nextTodo","current","deleet","makeSaveEvent","makeIsEventType","eventType","isFetchEventType","Fetch","isEditEventType","Edit","isSaveEventType","isDeleteEventType","makeIsEventOfType","event","isFetchEvent","isEditEvent","isSaveEvent","mutuableTodo","toMutable","setTitle","setCompleted","getCompleted","getTitle","makeWriteEffect","transactionMaker","writer","addEffect","updateEffect","remoteEffect","runSaveOutcomeEffect","outcome","events$","Subject","dispatch","console","warn","isTuple","initialTransaction","state$","setState","transactional$","pipe","scan","acc","transactionalStateOf","todo1","todo2","todos$","writeTodos","resetOkAndBadTodos","updateOrDeleteEventAndOperation$","tap","handleEvents$","groupBy","actionsByGroup$","timeoutWith","EMPTY","ignoreElements","mergeMap","groupedEvent$","switchMap","handleReadEvent","handleEditEvent","handleSaveEvent","handleDeleteEvent","from","promise","updateTransaction","eventsHandler$","_newTodoOperation$","setNewTodoOperation","getNewTodoOperation","newTodoOperation$","todoWithOperation","nextState","startWith","observable$","indexSubject","stateWithHistory$","Date","now","combineLatest","history","nextIndex","share","playSubject","replay$","withLatestFrom","mode","s","timeline","setIndex","log","merge","result","makeTimeTravelable","mapOfObservables","observables$","keys","reduce","isStateObservable","nextState$","process","_","states","k","defineProperty","createState","selectTodoFilter","timeTravelableState$","play","pause","App","React","useState","max","useEffect","eventsHandlerSubscription","subscribe","stateSubscription","window","unsubscribe","isComplete","Todo","makeEditEvent","makeDeleteEvent","padding","onInput","detail","discrete","start","step","disabled","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cbb0e551.chunk.js","sourcesContent":["export function get<K extends string>(prop: K) {\n  // function getter<T extends { [P in K]?: T[K] }>(object: T): T[K]\n  function getter<T extends { [P in K]: T[K] }>(object: T): T[K] {\n    return object[prop]\n  }\n\n  return getter\n}\n\nexport function set<K extends string>(prop: K) {\n  // function setter<T extends { [P in K]?: T[K] }>(object: T): (value: T[K]) => T\n  function setter<T extends { [P in K]: T[K] }>(object: T): (value: T[K]) => T {\n    return function (value: T[K]): T {\n      return Object.assign(object, {\n        [prop]: value\n      })\n    }\n  }\n\n  return setter\n}\n\nexport interface GetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T): T[K]\n  <T extends { [P in K]: any }>(object: T): T[K]\n}\n\nexport interface SetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T, value: T[K]): T\n  <T extends { [P in K]: any }>(object: T, value: T[K]): T\n}\n    \n// Examples\n/*\ninterface User {\n    id: number,\n    username: string,\n}\n\ntype NewUser = Partial<User>\n    \nexport const getUserId = composeGetter('id')\n\ntype UsernameGetter = GetProperty<'username'>\nconst getUsername: UsernameGetter = composeGetter('username')\n\ndeclare const user: User\ndeclare const newUser: NewUser\n    \nconst userId = getUserId(user) // :number\nconst userUsername = getUsername(user) // :number | undefined\n\nconst newUserId = getUserId(newUser) // :number | undefined\nconst newUserUsername = getUsername(newUser) // :string | undefined\n\nconst nextUser = composeSetter('username')(newUser, 'foobar')\nconst nextUserUsername = nextUser.username // :string | undefined\n*/","/**\n * Don't ask. I was experimenting with point-free. Basically:\n * - We get (a, b)\n * - Then apply f((a, b)) wich gives use (a -> c)\n * - and so we apply a to that to return c\n *\n *  fromAandBToC :: ( (a, b) -> a -> c) -> (a, b) -> c\n */\nimport { first } from './tuple'\n\nexport const fromAandBToC = <A, B, C>(f: (ab: [A, B]) => (a: A) => C) => (\n  ab: [A, B]\n) => f(ab)(first(ab));\n\n\n\nexport * from './array'\nexport * from './observable'\nexport * from './tuple'\nexport * from './getset'\nexport * from './assert'\nexport * from './function'\nexport * from './types'","import { F } from './types'\n\nexport type Tuple<A, B> = [A, B]\n\nexport type Thruple<A, B, C> = [A, B, C]\n\n/**\n * first :: (a, b) -> a\n * \n * Returns the first element in a tuple.\n */\nexport const first = <A>([a]: [A, any] | readonly [A, any]) => a;\n\n/**\n * thirst :: (a, b, c) -> a\n * \n * Returns the first element in a thruple.\n */\nexport const thirst = <A>([a]: [A, any, any] | readonly [A, any, any]) => a;\n\n/**\n * Returns the second element in a tuple.\n *\n * second :: ( (a, b) -> b)\n */\nexport const second = <B>([, b]: [any, B] | readonly [any, B]) => b;\n\n/**\n * threcond :: (a, b, c) -> b\n * \n * Like [[second]]. But for thruples.\n */\nexport const threcond = <B>([, b]: [any, B, any] | readonly [any, B, any]) => b;\n\n/**\n * tuple :: a -> b -> (a, b)\n * \n * Create a tuple given two values.\n */\nexport const tuple = <A, B>(a: A, b: B): Tuple<A, B> => [a, b]\n\n/**\n * thruple :: a -> b -> c -> (a, b, c)\n * \n * Create a thruple given three values.\n */\nexport const thruple = <A, B, C>(a: A, b: B, c: C): [A, B, C] => [a, b, c]\n\n/**\n * applyToSecond :: (a -> b) -> (t, a) -> (t, b)\n * \n * There's gotta be an official name for this.\n * Applies function f to the second element in a tuple.\n * \n */\nexport const applyToSecond = <A, B>(f: F<A, B>) => <T>(t: Tuple<T, A>): Tuple<T, B> => tuple(first(t), f(second(t)))\n","import { tuple } from \"./tuple\";\n\ntype F<A, B> = (a: A) => B;\n\nexport const arrayMap = <A, B>(f: F<A, B>) => (as: A[]) => as.map(a => f(a));\n\n/**\n * arrayBimap :: (a -> t) -> (a -> u) -> [a] -> [(u, t)]\n * @param f\n */\nexport const arrayBimap = <A, T>(f: F<A, T>) => <U>(g: F<A, U>) => (as: A[]) =>\n  as.map(a => tuple(f(a), g(a)));\n\n/**\n * Value alias used to better clearly indicate when\n * passing `true` to `transactionalStateOf`'s third `isTuple` parameter.\n */\nexport const IS_TUPLE = true;\n\n/**\n * isArray :: boolean -> t | [t] -> boolean\n *\n * Wrapper around Array.isArray when working with tuple like data structures.\n *\n * @param dataIsTuple - Whether to conside tuple like data or not.\n */\nexport const isArray = (dataIsTuple: boolean) => <A>(\n  data: A | A[]\n): data is A[] =>\n  Array.isArray(data)\n    ? // Continue if data is an array\n      dataIsTuple && data.length > 0\n      ? // TRUE if we're checking for tuples, data has 1 or more elements, and the first element is also an array\n        // FALSE if we're checking for tuples, data has 1 or more elements, and the first element is **NOT** an array (aka data is a tuple)\n        Array.isArray(data[0])\n      : // TRUE if data has more than zero elements\n        true\n    : // FALSE if data is not an array to begin with\n      false;\n","import { of, concat } from 'rxjs'\nimport { delay } from 'rxjs/operators'\n\n/**\n * mapToAfterMs :: b -> number -> a -> Observable a | b\n * \n * @param to Value to emit first\n * @param ms Delay second value by number of milliseconds\n */\nexport const mapToAfterMs = <B>(to: B, ms: number = 1000) => <A>(from: A) =>\n  concat(of(from), of(to).pipe(delay(ms)));\n\n/**\n * toNullAfterMs :: number -> b -> Observable null | b\n * \n * @param ms Delay second value by number of milliseconds\n */\nexport const toNullAfterMs = (ms = 1000) => mapToAfterMs(null, ms);\n","/**\n * isNotNull :: a | null -> a asserted\n * \n * Filter nullable types from an array\n * \n * @param value The nullable value to be checked\n */\nexport const isNotNull = <T>(value: T | null): value is T => value != null;\n\n/**\n * take :: number -> [a] -> [a]\n * \n * Take a number of elements from a list.\n * \n * @param amount The number of elements to take.\n */\nexport const take = (amount: number) => <T>(xs: T[]) => {\n  const txs: T[] = [];\n  const len = xs.length;\n\n  for (let i = 0; i < len && i < amount; i += 1) {\n    txs.push(xs[i]);\n  }\n\n  return txs;\n};\n","/**\n * once :: (a -> b) -> (a -> b)\n * @param f \n */\nexport const once = <A, B>(f: (a: A) => B) => {\n  let output: B | undefined;\n\n  return (a: A) => {\n    if (!output) {\n      output = f(a);\n    }\n\n    return output;\n  };\n};\n\n/**\n * identity :: a -> a\n *\n * Identify function\n */\nexport const identity = <T>(value: T) => {\n  return value;\n};\n\n/**\n * compose :: (b -> c) -> (a -> b) -> c\n *\n * Function composition. f after g. g andThen f\n */\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) =>\n  f(g(a));\n\n/**\n * TODO\n * @param f \n */\nexport const flip = <A, B, C>(f: (a: A, b: B) => C) => (b: B, a: A) => f(a, b)\n\n\n/**\n * TODO\n * @param f \n */\nexport const curry = <A, B, C>(f: (a: A, b: B) => C) => (a: A) => (b: B) => f(a, b)\n","import { Operation, Noop, Bad } from \"../operations\";\n\n/**\n * Todo model\n */\nexport type Todo = {\n  readonly id: number;\n  readonly title: string;\n  // userId: number;\n  readonly completed: boolean;\n};\n\n/**\n * Type describing operational state for a new todo.\n */\nexport type NewTodoOperation = Operation<string, void>;\n\n/**\n * Type alias describing those parts of a todo that are user editable.\n */\nexport type MutableTodo = Pick<Todo, \"completed\" | \"title\">;\n\n/**\n * Union type of event types that are in use for operational state.\n */\nexport type OperationalEventTypes = EventType.Save | EventType.Delete;\n\n/**\n * Type describing operational data in relation to editing, saving, and or removing todos.\n */\nexport type TodoOperation = Operation<MutableTodo, Todo, OperationalEventTypes>;\n\n/**\n * Event types that are dispatched to thee events$ sink.\n */\nexport enum EventType {\n  Fetch = \"Fetch\",\n  Edit = \"Edit\",\n  Save = \"Save\",\n  Delete = \"Delete\"\n}\n\n/**\n * Event describing todo's should be requested from the server.\n */\nexport type FetchEvent = {\n  type: EventType.Fetch;\n};\n\n/**\n * Event indicating a change to a todo in state should be recorded.\n */\nexport type EditEvent = {\n  type: EventType.Edit;\n  operation: Noop<MutableTodo> | Bad<MutableTodo, OperationalEventTypes>;\n  todo: Todo;\n};\n\n/**\n * Event meant to trigger an API call for saving an event using the API\n */\nexport type SaveEvent = {\n  type: EventType.Save;\n  operation: Noop<MutableTodo> | Bad<MutableTodo, OperationalEventTypes>;\n  todo: Todo;\n};\n\n/**\n * Event indicating the user wants to delete an event from state and the database.\n */\nexport type DeleteEvent = {\n  type: EventType.Delete;\n  todo: Todo;\n};\n\n/**\n * Union type of all event tyeps.\n */\nexport type TodoEvent = FetchEvent | EditEvent | SaveEvent | DeleteEvent;\n\n/**\n * A tuple:\n * 1. [[Todo]]\n * 2. [[TodoOperation]]\n */\nexport type TodoWithOperation = [Todo, TodoOperation];\n","\nexport enum Status {\n  Noop = \"Noop\",\n  Pending = \"Pending\",\n  Ok = \"Ok\",\n  Bad = \"Bad\"\n}\n\nexport type Noop<T> = {\n  status: Status.Noop;\n  state: T;\n};\n\nexport type Pending<T, A = void> = {\n  status: Status.Pending;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Bad<T, A = void> = {\n  status: Status.Bad;\n  state: T;\n  error: string;\n} & (A extends void ? {} : { action: A });\n\nexport type Ok<T, A = void> = {\n  status: Status.Ok;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Operation<T, U = T, A = void> =\n  | Noop<T>\n  | Pending<T, A>\n  | Bad<T, A>\n  | (U extends void ? Noop<T> : Ok<U, A>);\n\n","import { Status, Noop, Pending, Bad } from './types'\n\n// Assertions\nconst makeIsStatus = <T extends Status>(statusType: T) => (\n  checkedStatus: Status\n): checkedStatus is T => statusType === checkedStatus;\n\nexport const statusTypeIsOk = makeIsStatus(Status.Ok);\nexport const statusTypeIsBad = makeIsStatus(Status.Bad);\nexport const statusTypeIsNoop = makeIsStatus(Status.Noop);\nexport const statusTypeIsPending = makeIsStatus(Status.Pending);\n\n// type Foo = <S, O extends Operation<S>, A extends O['status']>\n\nexport const makeIsOperationOfStatus = <S extends Status>(\n  f: (statusType: Status) => statusType is S\n) => <O extends { status: Status }>(\n  operation: O\n): operation is Extract<O, { status: S }> => f(operation.status);\n\nexport const isOk = makeIsOperationOfStatus(statusTypeIsOk);\nexport const isBad = makeIsOperationOfStatus(statusTypeIsBad);\nexport const isNoop = makeIsOperationOfStatus(statusTypeIsNoop);\nexport const isPending = makeIsOperationOfStatus(statusTypeIsPending);\n\nexport const makeNoop = <T>(state: T): Noop<T> => {\n  return {\n    status: Status.Noop,\n    state\n  };\n};\n\n// export const toPendingWithAction = <T, A, B extends A>(operation: Noop<T> | Bad<T, A>, action: B): Pending<T, B> => toPending(operation, action)\n\nexport function toPending<T>(operation: Noop<T> | Bad<T>): Pending<T>;\nexport function toPending<T, A>(\n  operation: Noop<T> | Bad<T, A>,\n  action: A\n): Pending<T, A>;\nexport function toPending<T, A>(\n  operation: Noop<T> | Bad<T, A>,\n  action?: A\n): Pending<T, any> {\n  if (action != null) {\n    return {\n      status: Status.Pending,\n      state: operation.state,\n      action\n    };\n  }\n\n  return {\n    status: Status.Pending,\n    state: operation.state\n  };\n}\n","export enum FilterType {\n  All = \"All\",\n  Active = \"Active\",\n  Completed = \"Completed\"\n}\n","import * as React from \"react\";\nimport { Todo, MutableTodo } from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\nimport {\n  Status,\n  statusTypeIsPending,\n  statusTypeIsBad,\n  statusTypeIsOk\n} from \"../../../modules/operations\";\nimport { Typography } from \"rmwc\";\n\nexport type PropsItem = {\n  todo: Todo;\n  status: Status;\n  error?: string;\n  onEdit: (state: Partial<MutableTodo>) => void;\n  onSave: (state?: Partial<MutableTodo>) => void;\n  isDeleting: boolean;\n};\n\nexport const Item = (props: PropsItem) => (\n  <>\n    <R.ListItem\n      title={props.todo.title}\n      style={{\n        opacity: props.isDeleting ? 0.5 : 1,\n        transition: \"opacity 0.2s ease-in-out\"\n      }}\n    >\n      <R.ListItemGraphic\n        icon={{\n          icon: props.todo.completed\n            ? \"check_circle_outline\"\n            : \"radio_button_unchecked\",\n          theme: props.todo.completed ? \"primary\" : undefined,\n          onClick: () => props.onSave({ completed: !props.todo.completed })\n        }}\n      />\n      <R.ListItemText>\n        <R.ListItemPrimaryText theme=\"secondary\">\n          {props.todo.title}\n        </R.ListItemPrimaryText>\n        <R.ListItemSecondaryText\n          theme={props.error ? \"error\" : undefined}\n          style={{ fontStyle: \"italic \" }}\n        >\n          {props.error ? (\n            props.error\n          ) : props.status && statusTypeIsPending(props.status) ? (\n            props.isDeleting ? (\n              \"...deleting\"\n            ) : (\n              \"...saving\"\n            )\n          ) : props.todo.completed ? (\n            <Typography theme=\"primary\" use=\"caption\">\n              You're a go-getter!\n            </Typography>\n          ) : (\n            <Typography use=\"caption\">Start working on it!</Typography>\n          )}\n        </R.ListItemSecondaryText>\n      </R.ListItemText>\n      <R.ListItemMeta\n        icon={\n          props.status == null ? (\n            \"\"\n          ) : statusTypeIsPending(props.status) ? (\n            <R.CircularProgress theme=\"secondary\" />\n          ) : statusTypeIsBad(props.status) ? (\n            { icon: \"error\", theme: \"error\" }\n          ) : statusTypeIsOk(props.status) ? (\n            { icon: \"check\", theme: \"primary\" }\n          ) : (\n            \"\"\n          )\n        }\n      />\n    </R.ListItem>\n    <R.ListDivider />\n  </>\n);\n","import * as React from \"react\";\nimport {\n  Todo,\n  TodoOperation,\n  NewTodoOperation,\n  MutableTodo,\n  EventType\n} from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\n\nimport { Item } from \"./Item\";\nimport { isOk, isPending, isBad } from \"../../../modules/operations\";\nimport { noop } from \"rxjs\";\n\nexport const renderList = (props: PropsList) =>\n  props.todos.map(([todo, operation]) => {\n    return (\n      <Item\n        key={todo.id}\n        todo={todo}\n        onEdit={props.onEdit(todo, operation)}\n        onSave={props.onSave(todo, operation)}\n        status={operation && operation.status}\n        isDeleting={\n          isPending(operation) && operation.action === EventType.Delete\n        }\n        error={(operation && isBad(operation) && operation.error) || undefined}\n      />\n    );\n  });\n\nexport type PropsList = {\n  todos: [Todo, TodoOperation][];\n  onEdit: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state: Partial<MutableTodo>) => void;\n  onSave: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state?: Partial<MutableTodo>) => void;\n  new: NewTodoOperation;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n};\n\nexport const List = (props: PropsList) => {\n  const newTodo = props.new;\n\n  const onChangeNew = isOk(newTodo)\n    ? noop\n    : (evt: React.FormEvent<HTMLInputElement>) => {\n        props.onChangeNew(evt.currentTarget.value);\n      };\n\n  return (\n    <R.List className=\"todo-list\" twoLine>\n      <R.ListItem>\n        <R.ListItemGraphic\n          title={\"Mark all as complete.\"}\n          icon={{ icon: \"keyboard_arrow_down\", onClick: props.onCompleteAll }}\n          theme=\"secondary\"\n        />\n        {isPending(props.new) ? (\n          <>\n            <R.ListItemText>\n              <R.ListItemPrimaryText theme=\"secondary\">\n                {props.new.state}\n              </R.ListItemPrimaryText>\n              <R.ListItemSecondaryText style={{ fontStyle: \"italic \" }}>\n                ...busy\n              </R.ListItemSecondaryText>\n            </R.ListItemText>\n            <R.ListItemMeta\n              icon={\n                props.new.status == null ? (\n                  \"\"\n                ) : isPending(props.new) ? (\n                  <R.CircularProgress theme=\"secondary\" />\n                ) : isBad(props.new) ? (\n                  { icon: \"error\", theme: \"error\" }\n                ) : isOk(props.new) ? (\n                  { icon: \"check\", theme: \"primary\" }\n                ) : (\n                  \"\"\n                )\n              }\n            />\n          </>\n        ) : (\n          <R.TextField\n            fullwidth\n            theme=\"textPrimaryOnDark\"\n            placeholder=\"Where do you want to go today?\"\n            style={{ height: \"100%\" }}\n            onChange={onChangeNew}\n            value={props.new.state || \"\"}\n            onKeyUp={evt => evt.keyCode === 13 && props.onSubmitNew()}\n            autoFocus\n            trailingIcon={\n              isBad(props.new) ? { icon: \"error\", theme: \"error\" } : undefined\n            }\n          />\n        )}\n      </R.ListItem>\n      <R.ListDivider />\n      {renderList(props)}\n    </R.List>\n  );\n};\n","\nimport { FilterType } from './types'\n\nexport const makeIsFilterType = <T extends FilterType>(of: T) => (\n  filterType: FilterType\n): filterType is T => filterType === of;\n\n\n/**\n * TODO\n */\nexport const isFilterTypeAll = makeIsFilterType(FilterType.All);\n\n\n/**\n * TODO\n */\nexport const isFilterTypeCompleted = makeIsFilterType(FilterType.Completed);\n\n\n/**\n * TODO\n */\nexport const isFilterTypeActive = makeIsFilterType(FilterType.Active);\n\n","\n/**\n * Type of transaction you might apply to a dataset\n */\nexport enum TransactionType {\n  Update = \"Update\",\n  Remove = \"Remove\",\n  Add = \"Add\"\n}\n\n/**\n * A [[TransactionType]] combined with a payload.\n */\nexport type TransactionLike<T, P> = {\n  type: T;\n  payload: P;\n};\n\n/**\n * A transaction decribing the dataset should update an existing\n * piece of data with information in this transaction's payload.\n */\nexport type Update<T> = TransactionLike<TransactionType.Update, T>;\n\n/**\n * A transaction decribing the dataset should remove an existing\n * piece of data matching transaction's payload.\n */\nexport type Remove<T> = TransactionLike<TransactionType.Remove, T>;\n\n/**\n * A transaction decribing the dataset should add a new piece\n * of data that is this transaction's payload.\n */\nexport type Add<T> = TransactionLike<TransactionType.Add, T>;\n\n/**\n * An [[Add]], [[Update]], or [[Remomve]] transaction\n */\nexport type Transaction<A, U = A, R = A> = Add<A> | Update<U> | Remove<R>;\n\n/**\n * Type describing data used in transactions for data sets that are lists\n */\nexport type Transanctional<T> = T[] | T;\n","import { Todo, TodoOperation } from \"../todo\";\nimport { FilterType } from \"./types\";\nimport { isFilterTypeCompleted, isFilterTypeActive } from \"./assert\";\n\n/**\n * TODO\n */\nexport const makeFilterTodosByFilterType = <T extends FilterType>(\n  filterType: T\n) => (todos: [Todo, TodoOperation][]) =>\n  filterType === FilterType.All\n    ? todos\n    : todos.filter(\n        ([todo]) =>\n          (isFilterTypeCompleted(filterType) && todo.completed) ||\n          (isFilterTypeActive(filterType) && !todo.completed)\n      );\n\n/**\n * TODO\n */\nexport const filterCompletedTodos = makeFilterTodosByFilterType(\n  FilterType.Completed\n);\n\n/**\n * TODO\n */\nexport const filterActiveTodos = makeFilterTodosByFilterType(FilterType.Active);\n","import { Observable, concat, BehaviorSubject } from \"rxjs\";\nimport { identity } from \"../utils\";\n\n/**\n * Similar to the what React's `useState` hook returns but for observables.\n */\nexport type StateObservable<T, U = T> = readonly [\n  Observable<U>,\n  (next: T) => void,\n  () => T\n];\n\n/**\n * Either [[StateObservable]] or [[Observable]]\n */\nexport type ObservableLike<T> = StateObservable<T> | Observable<T>;\n\n/**\n * Determines if the given observable like value is a [[StateObservable]]\n */\nexport const isStateObservable = <T>(\n  observable$: ObservableLike<T>\n): observable$ is StateObservable<T> => Array.isArray(observable$);\n\n/**\n * Create a stateful observable\n * \n * @param initialState Initial state of the observable (see [[BehaviourSubject]])\n */\nexport const stateOf = <T>(\n  initialState: T,\n): StateObservable<T> => {\n  // Create a new subject that will stream the state\n  const subject = new BehaviorSubject<T>(initialState);\n\n  // subject.subscribe(console.error)\n  const setState = (state: T) => {\n    subject.next(state);\n  };\n\n  const getCurrentState = () => subject.getValue();\n\n  return [\n    subject.asObservable(),\n    setState,\n    getCurrentState\n  ] as const;\n};\n","import { TransactionType } from './types'\n\n/**\n * makeTransactionMaker :: TransactionType -> a -> Add a\n * \n * Creates a function for creating transaction objects of a specific type.\n * It is a curried function combining transaction type and payload in to a transaction object.\n * \n * @param type The type of transaction\n */\nconst makeTransactionMaker = <T extends TransactionType>(type: T) => <P>(payload: P) => ({type, payload})\n\n\n/**\n * makeAddTransaction :: p -> Add p\n * \n * Creates an [[Add]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeAddTransaction = makeTransactionMaker(TransactionType.Add)\n\n/**\n * makeUpdateTransaction :: p -> Remove p\n * \n * Creates an [[Update]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeUpdateTransaction = makeTransactionMaker(TransactionType.Update)\n\n/**\n * makeRemoveTransaction :: p -> Remove p\n * \n * Creates an [[Remove]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeRemoveTransaction = makeTransactionMaker(TransactionType.Remove)","import { isArray, IS_TUPLE } from \"../utils\";\n\nimport { Update, TransactionLike, TransactionType } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\n/**\n * add :: (a -> a -> boolean) -> boolean - [a] -> Update a -> [a]\n *\n * Add data to state (a list of T) given the payload of an [[Add]] transaction\n * and return the next state.\n */\nexport const add = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Add, T | T[]>\n) => {\n  const data = dataIsTuple\n    ? [\n        ...state,\n        ...(isArray(dataIsTuple)(transaction.payload)\n          ? transaction.payload\n          : [transaction.payload])\n      ]\n    : state.concat(transaction.payload);\n  return data;\n};\n\n/**\n * update :: (a -> a -> boolean) -> boolean -> [a] -> Update a -> [a]\n *\n * Update data in state (a list of T) given the payload of an [[Update]] transaction\n * and return the next state.\n */\nexport const update = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Update, T | T[]>\n) => {\n  const next = [...state];\n  const data = isArray(dataIsTuple)(transaction.payload)\n    ? transaction.payload\n    : [transaction.payload];\n\n  data.forEach(record => {\n    const index = next.findIndex(r => isEqual(r, record));\n\n    if (index >= 0) {\n      next.splice(index, 1, record);\n    } else {\n      next.push(record);\n    }\n  });\n  return next;\n};\n\n/**\n * remove :: (a -> a -> boolean) -> boolean -> [a] -> Remove a -> [a]\n *\n * Remove data from state (a list of T) given the payload of an [[Remove]] transaction\n * and return the next state.\n */\nexport const remove = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Remove, T | T[]>\n) => {\n  const data = isArray(dataIsTuple)(transaction.payload)\n    ? [...transaction.payload]\n    : [transaction.payload];\n\n  return state.filter(record => {\n    const index = data.findIndex(data => isEqual(record, data));\n    if (index >= 0) {\n      data.splice(index, 1);\n      return false;\n    }\n\n    return true;\n  });\n};\n","import { stateOf } from \"../../modules/state\";\n\nimport { FilterType } from \"./types\";\n\nexport const filterTypeState$ = stateOf(FilterType.All);\n\n","import * as React from \"react\";\nimport {\n  Todo,\n  TodoOperation,\n  NewTodoOperation,\n  MutableTodo\n} from \"../../modules/todo/types\";\nimport { List } from \"./components/List\";\nimport {\n  FilterType,\n  isFilterTypeAll,\n  isFilterTypeActive,\n  isFilterTypeCompleted\n} from \"../../modules/filter-todo\";\n\nimport * as R from \"rmwc\";\n\nexport interface PropsTodo {\n  todos: [Todo, TodoOperation][];\n  filterType: FilterType;\n  new: NewTodoOperation;\n  onChangeFilterType: (filterType: FilterType) => void;\n  onEdit: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state: Partial<MutableTodo>) => void;\n  onSave: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state?: Partial<MutableTodo>) => void;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n  onClearComplete: () => void;\n}\n\nexport default (props: PropsTodo) => {\n  // console.log(JSON.stringify(props, null, 2))\n  const list = (\n    <List\n      todos={props.todos}\n      onEdit={props.onEdit}\n      onSave={props.onSave}\n      onChangeNew={props.onChangeNew}\n      new={props.new}\n      onSubmitNew={props.onSubmitNew}\n      onCompleteAll={props.onCompleteAll}\n    />\n  );\n\n  return (\n    <>\n      <div style={{ textAlign: \"center\", marginTop: 15 }}>\n        <R.Typography use=\"headline1\" theme=\"secondary\">\n          todos\n        </R.Typography>\n      </div>\n      <section className=\"todoapp\">\n        <section className=\"main\">{list}</section>\n        <footer className=\"footer\" style={{ textAlign: \"center\" }}>\n          <R.ChipSet choice style={{ justifyContent: \"center\" }}>\n            <R.Chip\n              label=\"All\"\n              theme={\n                isFilterTypeAll(props.filterType) ? \"secondaryBg\" : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.All)}\n            />\n            <R.Chip\n              label=\"Active\"\n              icon=\"radio_button_unchecked\"\n              theme={\n                isFilterTypeActive(props.filterType) ? \"secondaryBg\" : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.Active)}\n            />\n            <R.Chip\n              label=\"Completed\"\n              icon=\"check_circle_outline\"\n              theme={\n                isFilterTypeCompleted(props.filterType)\n                  ? \"secondaryBg\"\n                  : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.Completed)}\n            />\n          </R.ChipSet>\n\n          <div>\n            <R.Button onClick={props.onClearComplete}>Clear completed</R.Button>\n          </div>\n          <R.Typography use=\"caption\" style={{ color: \"#999  \" }}>\n            <strong>\n              {props.todos.filter(([todo]) => !todo.completed).length}\n            </strong>{\" \"}\n            item left\n          </R.Typography>\n        </footer>\n      </section>\n    </>\n  );\n};\n","import { URL } from \"./constants\";\n\n// Todo\nimport { Todo, MutableTodo, TodoOperation, EventType } from \"./types\";\n\n// Operations\nimport { Ok, Bad, Status, Pending, Noop } from \"../operations\";\n\n// Utilities\nimport { take } from \"../utils\";\n\n/**\n * Mock database of Toods\n */\nlet todos: Todo[] = [];\n\n/**\n * Pattern of booleans used to to randomly fail API calls.\n */\nconst failPattern = [true, false, false, true, true, false, true];\n\n/**\n * Mutuable pointer referencing a boolean in [[failPattern]]\n */\nlet failIndex = 0;\n\n/**\n * Returns the next \"doFail\" flag and moves the failIndex\n * pointer to the next boolean in [[failPattern]]\n */\nconst getNextFailFlag = () => {\n  failIndex += 1;\n\n  if (failIndex > failPattern.length - 1) {\n    failIndex = 0;\n  }\n\n  return failPattern[failIndex];\n};\n\n/**\n * delay\n * Helper function for creating promise that resolves after `ms` milliseconds.\n *\n * @param ms Number of milliseconds to delay resolving the promise.\n */\nconst delay = (ms: number) =>\n  new Promise<void>(resolve => setTimeout(resolve, ms));\n\n/**\n * API for loading the list of Todos in the database.\n */\nexport const read = async () => {\n  const doFail = getNextFailFlag();\n\n  // Only make the network call once since we are mocking things here.\n  if (todos.length <= 0) {\n    const response = await fetch(URL);\n    const json: Todo[] = await response.json();\n    await delay(1500);\n\n    // Replace the database\n    todos = take(6)(json); //.map(todo => ({...todo, completed: false}));\n  }\n  // Return data from our mocked database [[todos]] after 1 second\n  else {\n    await delay(1000);\n  }\n  return todos;\n};\n\n/**\n * API for creating new Todos and storing them in the database.\n * @param operation\n */\nexport const create = async (\n  operation: Pending<string>\n): Promise<Ok<Todo> | Bad<string>> => {\n  const doFail = getNextFailFlag();\n\n  await delay(1500);\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state\n    };\n  }\n\n  if (!operation.state) {\n    return {\n      status: Status.Bad,\n      error: \"A title is required!\",\n      state: operation.state\n    };\n  }\n\n  const todo = {\n    id: Math.floor(Math.random() * 10000),\n    userId: Math.floor(Math.random() * 10000),\n    title: operation.state,\n    completed: false\n  };\n\n  todos = [...todos, todo];\n\n  return {\n    status: Status.Ok,\n    state: todo\n  };\n};\n\n/**\n * API for updating Todos in the database\n *\n * @param todo\n * @param operation\n */\nexport const update = async (\n  todo: Todo,\n  operation: Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Save> | Bad<MutableTodo, EventType.Save>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag();\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state,\n      action: EventType.Save\n    };\n  }\n\n  const title = operation.state.title.trim();\n\n  if (!title) {\n    return {\n      status: Status.Bad,\n      action: EventType.Save,\n      error: \"A title is required!\",\n      state: {\n        ...operation.state,\n        title\n      }\n    };\n  }\n\n  const nextTodo = {\n    ...todo,\n    ...operation.state,\n    title\n  };\n\n  todos = todos.map(current => {\n    if (current.id === nextTodo.id) {\n      return nextTodo;\n    }\n\n    return todo;\n  });\n\n  return {\n    status: Status.Ok,\n    state: { ...todo, ...operation.state, title },\n    action: EventType.Save\n  };\n};\n\n/**\n * API for deleting Todo's from the database\n *\n * @param todo\n * @param operation\n */\nexport const deleet = async (\n  todo: Todo,\n  operation: Pending<MutableTodo, EventType.Delete> //Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Delete> | Bad<MutableTodo, EventType.Delete>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag();\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Unable to delete!\",\n      state: operation.state,\n      action: EventType.Delete\n    };\n  }\n\n  todos = todos.filter(current => current.id !== todo.id);\n\n  return {\n    status: Status.Ok,\n    state: todo,\n    action: EventType.Delete\n  };\n};\n","export const URL = 'https://jsonplaceholder.typicode.com/todos/'\n","import {\n  EventType,\n  FetchEvent,\n  TodoEvent,\n  SaveEvent,\n  DeleteEvent,\n  TodoOperation,\n  EditEvent,\n  Todo,\n  OperationalEventTypes\n} from \"./types\";\n\nimport { Noop, Bad } from '../operations'\n\n/**\n * makeFetchEvent\n */\nexport const makeFetchEvent = (): FetchEvent => {\n  return { type: EventType.Fetch };\n};\n\n/**\n * makeEditEvent\n */\n\nexport const makeEditEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): EditEvent => {\n  return { type: EventType.Edit, todo, operation };\n};\n\n/**\n * makeSaveEvent\n */\nexport const makeSaveEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): SaveEvent => {\n  return { type: EventType.Save, todo, operation };\n};\n\n/**\n * makeDeleteEvent\n */\nexport const makeDeleteEvent = (todo: Todo): DeleteEvent => {\n  return { type: EventType.Delete, todo };\n};\n\n/**\n * makeIsEventType\n */\nexport const makeIsEventType = <T extends EventType>(of: T) => (\n  eventType: EventType\n): eventType is T => eventType === of;\n\n/**\n * isFetchEventType\n */\nexport const isFetchEventType = makeIsEventType(EventType.Fetch);\n\n/**\n * isEditEventType\n */\nexport const isEditEventType = makeIsEventType(EventType.Edit);\n\n/**\n * isSaveEventType\n */\nexport const isSaveEventType = makeIsEventType(EventType.Save);\n\n/**\n * isDeleteEventType\n */\nexport const isDeleteEventType = makeIsEventType(EventType.Delete);\n\n/**\n * makeIsEventOfType\n */\nexport const makeIsEventOfType = <A extends EventType>(\n  f: (eventType: EventType) => eventType is A\n) => (event: TodoEvent): event is Extract<TodoEvent, { type: A }> =>\n  f(event.type);\n\n/**\n * isFetchEvent\n */\nexport const isFetchEvent = makeIsEventOfType(isFetchEventType);\n\n/**\n * isEditEvent\n */\nexport const isEditEvent = makeIsEventOfType(isEditEventType);\n\n/**\n * isSaveEvent\n */\nexport const isSaveEvent = makeIsEventOfType(isSaveEventType);\n\n/**\n * isDeleteEvent\n */\nexport const isDeleteEvent = makeIsEventOfType(isDeleteEventType);\n","import { Todo, MutableTodo } from \"./types\";\nimport { get, set } from \"../utils/getset\";\n\n/**\n * @private\n * \n * Constant used for creating empty, new [[Todo]]s\n */\nconst mutuableTodo: MutableTodo = { completed: false, title: \"\" };\n\n/**\n * toMutable :: [[Todo]] -> [[MutableTodo]]\n * \n * Helper function for extracting `completed` and `title` from todos.\n * This is mostly used to create data for operations.\n * \n * @param todo - The todo object to convert.\n */\nexport const toMutable = (todo: Todo): MutableTodo =>\n  setTitle(setCompleted(mutuableTodo)(getCompleted(todo)))(getTitle(todo));\n\n// Experimental code\nexport const getId = get(\"id\");\nexport const getTitle = get(\"title\");\nexport const getCompleted = get(\"completed\");\n\nexport const setId = set(\"id\");\nexport const setTitle = set(\"title\");\nexport const setCompleted = set(\"completed\");\n\n\n","import {\n  EventType,\n  Todo,\n  MutableTodo,\n  SaveEvent,\n  DeleteEvent,\n  TodoWithOperation,\n  TodoOperation\n} from \"./types\";\n\n// Transactions\nimport {\n  Transaction,\n  TransactionType,\n  makeAddTransaction,\n  makeUpdateTransaction,\n  makeRemoveTransaction,\n  Transanctional\n} from \"../transactions\";\n\n// Operations\nimport { Ok, Bad, isOk, makeNoop } from \"../operations\";\n\n// Utilities\nimport { toMutable } from \"./utils\";\nimport { tuple } from \"../utils\";\n\n/** Operations that can be reset to Noop */\nexport type ResetableOperation =\n  | Ok<Todo, EventType.Save>\n  | Bad<MutableTodo, EventType.Save | EventType.Delete>;\n\n/* Events that can be done over if there outcome fails. */\nexport type RedoableEvent = SaveEvent | DeleteEvent;\n\n/* Effectful function for updating state */\nexport type Writer = (\n  todos: Transaction<Transanctional<TodoWithOperation>>\n) => void;\n\n/**\n * resetOkAndBadTodosEffect :: Write -> (RedoableEvent, ResetableOperation) -> ()\n *  \n * @param writer \n */\nexport const resetOkAndBadTodosEffect = (writer: Writer) => ([\n  event,\n  operation\n]: [RedoableEvent, ResetableOperation]) => {\n  const noop = makeNoop(\n    isOk(operation) ? toMutable(operation.state) : operation.state\n  );\n\n  const transaction = {\n    type: TransactionType.Update,\n    payload: isOk(operation)\n      ? tuple(operation.state, noop)\n      : tuple(event.todo, noop)\n  };\n\n  writer(transaction);\n};\n\n// What I want is:\n// export const add = (write: Writer) => compose(write, makeAddTransaction)\n// or go crazy\n// and make add:\n// curry(flip(compose)(makeAddTransaction))\n// But TypeScript can't handle me\n\nconst makeWriteEffect = (\n  transactionMaker: (\n    data: Transanctional<[Todo, TodoOperation]>\n  ) => Transaction<Transanctional<[Todo, TodoOperation]>>\n) => (writer: Writer) => (data: Transanctional<[Todo, TodoOperation]>) =>\n  writer(transactionMaker(data));\n\nexport const addEffect = makeWriteEffect(makeAddTransaction);\n\nexport const updateEffect = makeWriteEffect(makeUpdateTransaction);\n\nexport const remoteEffect = makeWriteEffect(makeRemoveTransaction);\n\ntype DeleteOutcome =\n  | Ok<Todo, EventType.Delete>\n  | Bad<MutableTodo, EventType.Delete>;\n\nexport const runDeleteOutcomeEffect = (writer: Writer) => (todo: Todo) => (\n  outcome: DeleteOutcome\n) =>\n  isOk(outcome)\n    ? remoteEffect(writer)(tuple(todo, outcome))\n    : updateEffect(writer)(tuple(todo, outcome));\n\ntype SaveOutcome = Ok<Todo, EventType.Save> | Bad<MutableTodo, EventType.Save>;\n\nexport const runSaveOutcomeEffect = (writer: Writer) => (todo: Todo) => (\n  outcome: SaveOutcome\n) => {\n  updateEffect(writer)(\n    tuple(isOk(outcome) ? { ...todo, ...outcome.state } : todo, outcome)\n  );\n};\n\nexport const runCreateOutcomeEffect = (writer: Writer) => (\n  outcome: Ok<Todo> | Bad<string>\n) => {\n  if (isOk(outcome)) {\n    const todoWithOperation = tuple(\n      outcome.state,\n      makeNoop({\n        title: outcome.state.title,\n        completed: false\n      })\n    );\n\n    addEffect(writer)(todoWithOperation);\n  }\n};\n","// RxJS\nimport { Subject, from, of, EMPTY, concat, Observable } from \"rxjs\";\nimport {\n  tap,\n  map,\n  mergeMap,\n  switchMap,\n  groupBy,\n  timeoutWith,\n  ignoreElements,\n  startWith,\n  delay,\n  filter\n} from \"rxjs/operators\";\n\n// Utilities\nimport {\n  tuple,\n  compose,\n  thruple,\n  identity,\n  IS_TUPLE,\n  arrayBimap\n} from \"../utils\";\n\n// State\nimport { stateOf, StateObservable, transactionalStateOf } from \"../state\";\n\n// API\nimport { read, create, update, deleet } from \"./api\";\n\n// Todo\nimport {\n  TodoEvent,\n  Todo,\n  NewTodoOperation,\n  EventType,\n  SaveEvent,\n  EditEvent,\n  DeleteEvent,\n  FetchEvent,\n  TodoWithOperation\n} from \"./types\";\n\nimport { isFetchEvent, isEditEvent, isSaveEvent } from \"./events\";\n\nimport { toMutable } from \"./utils\";\n\n// Operational\nimport { makeNoop, isPending, isBad, toPending, isNoop } from \"../operations\";\n\n// Transaction\nimport { TransactionType } from \"../transactions\";\n\n// Effects\nimport {\n  resetOkAndBadTodosEffect,\n  RedoableEvent,\n  ResetableOperation,\n  addEffect,\n  updateEffect,\n  runDeleteOutcomeEffect,\n  runSaveOutcomeEffect,\n  runCreateOutcomeEffect\n} from \"./effects\";\n\n/**\n * @private\n *\n * [[Subject]] for dispatching and streaming events.\n */\nconst events$ = new Subject<TodoEvent>();\n\n/**\n * dispatch :: TodoEvent -> ()\n *\n * Function for dispatching to the [[events$]] [[Subject]]\n *\n * @param event An [[EditEvent]], [[SaveEent]], or [[DeleteEvent]].\n */\nexport const dispatch = (event: TodoEvent) => {\n  console.warn(`Dispatching ${event.type}`);\n  events$.next(event);\n};\n\n/**\n * Create a transactional [[StateObservable]] allowing us to use the\n * setState function (in this case named writeTodos) to either accept an\n * array of TodoWithOperation or just a single element.\n */\nexport const [todos$, writeTodos] = transactionalStateOf(\n  [] as TodoWithOperation[],\n  ([todo1], [todo2]) => todo1.id === todo2.id,\n  IS_TUPLE\n);\n\n/**\n * Operator for resetting a todo's operation to Noop\n * after it was set to Bad or Ok\n *\n * @param updateOrDeleteEventAndOperation$\n */\nconst resetOkAndBadTodos = (\n  updateOrDeleteEventAndOperation$: Observable<\n    [RedoableEvent, ResetableOperation]\n  >\n) =>\n  updateOrDeleteEventAndOperation$.pipe(\n    delay(1000),\n    tap(resetOkAndBadTodosEffect(writeTodos))\n  );\n\n/**\n * Main function for handling incoming events\n * Kind of like a reducer in Redux.\n *\n * It groups the events by type Fetch or the id of the todo.\n * and uses switchMap for each group.\n */\nexport const handleEvents$ = events$.pipe(\n  groupBy(\n    event => {\n      if (isFetchEvent(event)) {\n        return EventType.Fetch;\n      } else {\n        return event.todo.id;\n      }\n    },\n    event => event,\n    actionsByGroup$ =>\n      actionsByGroup$.pipe(\n        timeoutWith(15000, EMPTY),\n        ignoreElements()\n      )\n  ),\n  mergeMap(groupedEvent$ =>\n    groupedEvent$.pipe(\n      switchMap(event => {\n        if (isFetchEvent(event)) {\n          return handleReadEvent(event);\n        } else if (isEditEvent(event)) {\n          return handleEditEvent(event);\n        } else if (isSaveEvent(event)) {\n          return handleSaveEvent(event);\n        }\n\n        return handleDeleteEvent(event);\n      })\n    )\n  )\n);\n\n// Because TypeScript is unable to infer this bois abstractions.\ntype Id<T> = (id: T) => T;\n\n/**\n * Handles incoming [[FetchEvent]] events that have been\n * dispatched to the [[events$]] [[Subject]]\n *\n * It immediately calls the API for requesting Todos from\n * the server and updates state with the received todos\n * by running the addEffect\n *\n * @param event The [[FetchEvent]] event\n */\nexport const handleReadEvent = (event: FetchEvent) =>\n  from(read()).pipe(\n    // map(arrayMap(curry(tuple))),\n    map(\n      arrayBimap(identity as Id<Todo>)(\n        // f after g\n        compose(\n          makeNoop, // f\n          toMutable // g\n        )\n      )\n    ),\n    tap(addEffect(writeTodos))\n  );\n\n/**\n * Handle incoming events requesting [[Todo]](s) be deleted\n * from the database.\n *\n * State is updating first to indicate \"in progress\". Then the\n * API for deleting Todos is called. Once the call resolves\n * state is updated to indicate failure or success. After a second\n * state is updated once again to reset the operation so that the\n * UI removes the indicators of failure or success.\n *\n * @param event - The delete event [[DeleteEvent]]\n */\nconst handleDeleteEvent = (event: DeleteEvent) => {\n  const operation = toPending(\n    makeNoop(toMutable(event.todo)),\n    EventType.Delete as const\n  );\n\n  const promise = deleet(event.todo, operation);\n\n  return concat(\n    of(tuple(event.todo, operation)).pipe(tap(updateEffect(writeTodos))),\n    from(promise).pipe(\n      tap(runDeleteOutcomeEffect(writeTodos)(event.todo)),\n      filter(isBad),\n      map(outcome => tuple(event, outcome)),\n      resetOkAndBadTodos\n    )\n  );\n};\n\n/**\n * Responsds to the [[EditEvent]] dispatched on the [[events$]]\n * [[Subject]] after the user types to change the title of\n * a [[Todo]]\n *\n * The only effect here is updating state. No API calls\n *\n * @param event [[EditEvent]]\n */\nconst handleEditEvent = (event: EditEvent) => {\n  // Reset the Todo's operational status if the user\n  // started editing after a success or failure operation\n  const operation = isNoop(event.operation)\n    ? event.operation\n    : makeNoop(event.operation.state);\n\n  return of(tuple(event.todo, operation)).pipe(tap(updateEffect(writeTodos)));\n};\n\n/**\n * Handles incoming [[SaveEvent]] events that are dispatched to [[event$]]\n *\n * - It first updates state to indicate the Todo is currently being saved.\n * - Then calls the API for updating existing todos in the database.\n * - Passes the results to runSaveOutcomeEffect to update state accordingly\n * - And resets after a delay using [[resetOkAndBadTodos]]\n *\n * @param event\n */\nconst handleSaveEvent = (event: SaveEvent) => {\n  const operation = toPending(event.operation, EventType.Save as const);\n\n  const updateTransaction = {\n    type: TransactionType.Update as const,\n    payload: tuple(event.todo, operation)\n  };\n\n  const promise = update(event.todo, event.operation);\n\n  return concat(\n    of(void 0).pipe(tap(() => writeTodos(updateTransaction))),\n    from(promise).pipe(\n      tap(runSaveOutcomeEffect(writeTodos)(event.todo)),\n      map(outcome => tuple(event, outcome)),\n      resetOkAndBadTodos\n    )\n  );\n};\n\n/**\n * Event stream filtered by type FETCH\n */\nexport const eventsHandler$ = handleEvents$;\n\n/**\n * I'm destructuring the result of `stateOf` so that I can re-export\n * a piped version of `_newTodoOperation`\n */\nconst [_newTodoOperation$, setNewTodoOperation, getNewTodoOperation] = stateOf(\n  makeNoop(\"\") as NewTodoOperation\n);\n\n/**\n * [[StateObservable]] that handles new todos the user wants to create.\n * It starts with an empty \"Noop\" operation of a string (title)\n * and any time `setNewTodoOperation` is called the stream checks if the status\n * has changed to \"pending\" and if so will start calling the API\n * for storing the new todo in the datatabase.\n *\n * Using [[thruple]] to re-export everything as a [[StateObservable]]\n *\n *\n */\nexport const newTodoOperation$ = thruple(\n  _newTodoOperation$.pipe(\n    switchMap(state =>\n      isPending(state)\n        ? from(create(state)).pipe(\n            tap(runCreateOutcomeEffect(writeTodos)),\n            map(nextState => (isBad(nextState) ? nextState : makeNoop(\"\"))),\n            startWith(state)\n          )\n        : of(state)\n    )\n  ),\n  setNewTodoOperation,\n  getNewTodoOperation\n) as StateObservable<NewTodoOperation>;\n","import { scan } from \"rxjs/operators\";\n\nimport { tuple } from \"../utils\";\nimport { TransactionType, Transaction, update, add, remove } from \"../transactions\";\n\nimport { stateOf } from \"./stateOf\";\n\n/**\n * transactionalStateOf :: t | [t] -> (t -> t -> boolean) -> boolean -> (Observable [t], Transaction t | [t] -> void)\n * \n * Creates a stateful, transactional observable for lists.\n */\nexport const transactionalStateOf = <T>(\n  initialState: T | T[],\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  isTuple: boolean = false\n) => {\n  const initialTransaction: Transaction<T | T[]> = {\n    type: TransactionType.Add,\n    payload: initialState\n  } as any;\n\n\n\n  const [state$, setState] = stateOf(initialTransaction);\n\n  const transactional$ = state$.pipe(\n    scan(\n      (acc, transaction) => {\n        switch (transaction.type) {\n          case TransactionType.Add: {\n            return add(isEqual, isTuple)(acc)(transaction)\n          }\n          case TransactionType.Update: {\n            return update(isEqual, isTuple)(acc)(transaction)\n          }\n\n          case TransactionType.Remove: {\n            return remove(isEqual, isTuple)(acc)(transaction)\n          }\n\n          default:\n            return acc;\n        }\n      },\n      [] as T[]\n    )\n  );\n\n  return tuple(transactional$, setState);\n};\n\n","import React from \"react\";\n\nimport TodoApp from \"./apps/todo/Todo\";\nimport { Slider, IconButton } from \"rmwc\";\n\nimport {\n  dispatch,\n  newTodoOperation$,\n  eventsHandler$\n} from \"./modules/todo/observables\";\n\nimport { tap } from \"rxjs/operators\";\n\nimport { todosByFilterType$ } from \"./apps/todo/observables\";\nimport { createState, makeTimeTravelable } from \"./modules/state\";\n\nimport { Observable, noop } from \"rxjs\";\nimport {\n  makeFetchEvent,\n  makeSaveEvent,\n  makeEditEvent,\n  makeDeleteEvent\n} from \"./modules/todo/events\";\nimport {\n  makeNoop,\n  toPending,\n  isPending,\n  isBad,\n  isNoop,\n  Noop\n} from \"./modules/operations\";\nimport { TodoOperation, Todo, MutableTodo } from \"./modules/todo/types\";\nimport { FilterType, filterTypeState$ } from \"./modules/filter-todo\";\nimport { compose, first, second, tuple } from \"./modules/utils\";\n\nconst state$ = createState({\n  todos: todosByFilterType$,\n  filterType: filterTypeState$,\n  new: newTodoOperation$\n});\n\nconst [timeTravelableState$, setIndex, _, play, pause] = makeTimeTravelable(\n  state$\n);\n\ntype Observed<T> = T extends Observable<infer S> ? S : never;\n\ntype State = {\n  data: Observed<typeof state$> | undefined;\n  index: number;\n  max: number;\n};\n\nconst App = () => {\n  console.log(\"Render App\");\n  const [state, setState] = React.useState<State>({\n    data: undefined,\n    index: -1,\n    max: 0\n  });\n\n  React.useEffect(() => {\n    // const todosSubscription = todosByFilterType$.pipe(tap(setTodos)).subscribe()\n\n    const eventsHandlerSubscription = eventsHandler$.subscribe();\n\n    const stateSubscription = timeTravelableState$\n      .pipe(\n        tap(([state, _, index, max]) => setState({ data: state, index, max })),\n        tap(state => Object.assign(window, { state }))\n      )\n      .subscribe();\n\n    dispatch(makeFetchEvent());\n\n    return () => {\n      eventsHandlerSubscription.unsubscribe();\n      stateSubscription.unsubscribe();\n    };\n  }, []);\n\n  const data = state.data;\n  if (data != null) {\n    const onChangeFilterType = (filterType: FilterType) => {\n      data.filterType = filterType;\n    };\n\n    const onChangeNew = (title: string) => {\n      data.new = makeNoop(title);\n    };\n\n    const onSubmitNew = () => {\n      if (!isPending(data.new)) data.new = toPending(data.new);\n    };\n\n    const onEdit = (todo: Todo, operation: TodoOperation) => (\n      state: Partial<Pick<Todo, \"completed\" | \"title\">>\n    ) => {\n      if (isNoop(operation) || isBad(operation)) {\n        dispatch(\n          makeEditEvent(todo, {\n            ...operation,\n            state: {\n              ...operation.state,\n              ...state\n            }\n          })\n        );\n      }\n    };\n\n    const onSave = (todo: Todo, operation: TodoOperation) => (\n      state: Partial<Pick<Todo, \"completed\" | \"title\">> = {}\n    ) => {\n      if (isNoop(operation) || isBad(operation)) {\n        dispatch(\n          makeSaveEvent(todo, {\n            ...operation,\n            state: {\n              ...operation.state,\n              ...state\n            }\n          })\n        );\n      }\n    };\n\n    const isComplete = (todo: Todo) => todo.completed === true;\n\n    const onCompleteAll = () =>\n      data.todos\n        .filter(\n          compose(\n            a => !a,\n            compose(\n              isComplete,\n              first\n            )\n          )\n        )\n        .filter(\n          (todo): todo is [Todo, Noop<MutableTodo>] =>\n            isNoop(second(todo)) || isBad(second(todo))\n        )\n        .map(todo =>\n          tuple(first(todo), {\n            ...second(todo),\n            state: { ...second(todo).state, completed: true }\n          })\n        )\n        .forEach(todo => dispatch(makeSaveEvent(...todo)));\n\n    const onClearComplete = () => {\n      data.todos\n        .filter(\n          compose(\n            isComplete,\n            first\n          )\n        )\n        .filter(\n          (todo): todo is [Todo, Noop<MutableTodo>] =>\n            isNoop(second(todo)) || isBad(second(todo))\n        )\n        .forEach(([todo]) => dispatch(makeDeleteEvent(todo)));\n    };\n\n    return (\n      <>\n        <div>\n          <div className=\"todomvc\">\n            <TodoApp\n              todos={data.todos}\n              new={data.new}\n              onChangeFilterType={\n                state.index !== state.max ? noop : onChangeFilterType\n              }\n              onChangeNew={state.index !== state.max ? noop : onChangeNew}\n              onSubmitNew={state.index !== state.max ? noop : onSubmitNew}\n              filterType={data.filterType}\n              onEdit={state.index !== state.max ? () => noop : onEdit}\n              onSave={state.index !== state.max ? () => noop : onSave}\n              onCompleteAll={state.index !== state.max ? noop : onCompleteAll}\n              onClearComplete={\n                state.index !== state.max ? noop : onClearComplete\n              }\n            />\n          </div>\n        </div>\n        <div>\n          <div style={{ padding: 15 }}>\n            <Slider\n              value={state.index}\n              // onChange={evt => setIndex(evt.detail.value)}\n              onInput={evt => {\n                setIndex(evt.detail.value);\n              }}\n              discrete\n              start={0}\n              max={state.max}\n              step={1}\n            />\n            <div className=\"controls\">\n              <IconButton\n                theme={state.index === 0 ? undefined : \"secondary\"}\n                icon=\"fast_rewind\"\n                onClick={() => setIndex(0)}\n                disabled={state.index === 0}\n              />\n              <IconButton\n                theme={state.index === 0 ? undefined : \"secondary\"}\n                icon=\"skip_previous\"\n                onClick={() => setIndex(state.index - 1)}\n                disabled={state.index === 0}\n              />\n              <IconButton theme=\"secondary\" icon=\"stop\" onClick={pause} />\n              <IconButton\n                theme=\"secondary\"\n                icon=\"play_circle_filled\"\n                onClick={play}\n              />\n              <IconButton\n                theme={state.index === state.max ? undefined : \"secondary\"}\n                icon=\"skip_next\"\n                onClick={() => setIndex(state.index + 1)}\n                disabled={state.index === state.max}\n              />\n              <IconButton\n                theme={state.index === state.max ? undefined : \"secondary\"}\n                icon=\"fast_forward\"\n                onClick={() => setIndex(state.max)}\n                disabled={state.index === state.max}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  return <div>Loading..</div>;\n};\n\nexport default App;\n","import {\n  Observable,\n  Subject,\n  combineLatest,\n  BehaviorSubject,\n  of,\n  interval,\n  EMPTY,\n  merge,\n  concat\n} from \"rxjs\";\nimport {\n  debounceTime,\n  scan,\n  startWith,\n  map,\n  withLatestFrom,\n  mergeAll,\n  tap,\n  delay,\n  mergeMap,\n  repeat,\n  switchMap,\n  filter,\n  share\n} from \"rxjs/operators\";\nimport { first, second, tuple } from \"../utils\";\n\n/**\n * Turns an observable into a time travelable\n * version of itself.\n *\n * It does this by creating a Subject to sink/stream the selected\n * historic index.\n *\n * Then it it creates `stateWithHistory$` which is just using\n * the `scan` operator to keep track of all emitted values.\n *\n * A final `index$` observable is created that only emits\n * index values that are within the bounds of the history\n * array's length.\n *\n * A final `state$` observable is created by combining\n * `index$` and `stateWithHistory$` to either select state\n * from the history array or return the active, current state\n * if the index is `-1`\n *\n * The return value of this function is a thruple of:\n * 0: The final `state$` observable\n * 1: A dispatch function for setting the selected index\n * 2: The `index$` observable emitting both the index and the maximum\n */\nexport const makeTimeTravelable = <T>(observable$: Observable<T>) => {\n  const indexSubject = new BehaviorSubject(-1);\n  const startDate = Date.now();\n\n  const stateWithHistory$ = combineLatest(indexSubject, observable$).pipe(\n    scan(\n      ([state, index, history], [nextIndex, nextState]) => {\n        return state !== nextState\n          ? ([\n              nextState,\n              index >= 0 && index + 1 < history.length ? index + 1 : -1,\n              state ? [...history, [state, Date.now()]] : []\n            ] as [T, number, [T, number][]])\n          : ([nextState, nextIndex, history] as [T, number, [T, number][]]);\n      },\n      [undefined, -1, []] as [T | undefined, number, [T, number][]]\n    ),\n    map(([state, index, history]) => {\n      if (index < 0 || index >= history.length) {\n        return [state, history, history.length, history.length] as const;\n      }\n\n      return [history[index][0], history, index, history.length] as const;\n    }),\n    share()\n  );\n\n  const playSubject = new Subject<\"PLAY\" | \"PAUSE\">();\n\n  const replay$ = playSubject.pipe(\n    withLatestFrom(stateWithHistory$),\n    switchMap(([mode, s]) => {\n      if (mode === \"PLAY\") {\n        return concat(of(s), stateWithHistory$).pipe(\n          switchMap(([state, history, index]) => {\n            const timeline = state ? [...history, tuple(state, history[history.length - 1][1] + 250)] : history\n            const ms = index > 0 && timeline[index + 1]\n              ? timeline[index + 1][1] - timeline[index][1]\n              : 0;\n\n            return of(void 0).pipe(\n              delay(ms > 2500 ? 250 : ms),\n              tap(() => setIndex(timeline[index + 1] ? index + 1 : 0))\n            );\n          })\n        );\n      }\n\n      return EMPTY;\n    })\n  );\n\n  const setIndex = (index: number) => {\n    console.log(index);\n    indexSubject.next(index);\n  };\n\n  return [\n    merge(replay$, stateWithHistory$).pipe(\n      filter(result => !!result)\n    ) as typeof stateWithHistory$,\n    setIndex,\n    indexSubject.asObservable(),\n    () => playSubject.next('PLAY'),\n    () => playSubject.next('PAUSE')\n  ] as const;\n};\n","import { Observable, combineLatest } from \"rxjs\";\nimport { isStateObservable, ObservableLike } from \"./stateOf\";\nimport { map, tap, share } from \"rxjs/operators\";\n\n/**\n * Returns a type describing all keys of object T\n * that are of type V\n */\ntype KeyOfType<T, V> = {\n  [P in keyof T]: T[P] extends V ? P : never;\n}[keyof T];\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they belong to keys in type K\n */\ntype ReadonlyByKey<T extends {}, K extends keyof T> = Readonly<Pick<T, K>> &\n  Omit<T, K>;\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they are of type V\n */\ntype ReadonlyByType<T, V> = ReadonlyByKey<T, KeyOfType<T, V>>;\n\n/**\n * An object representing a map of [[Observable]] or [[StateObserveable]]\n */\ntype MapOfObservables = {\n  [prop: string]: ObservableLike<any>;\n};\n\n/**\n * A type representing a map of values based on a map of\n * [[Observable]] or [[StateObservable]] and the values those\n * observable stream.\n *\n * For example\n *\n * ```ts\n * type Foo = MapOfStateFromMapOfObservables<{ bar: Observable<number>>, zax: StateObservable<string> }\n *\n * // equates to\n *\n * type Foo = { readonly bar: number, zax: string }\n * ```\n *\n */\ntype MapOfStateFromMapOfObservables<T> = {\n  [P in keyof T]: T[P] extends ObservableLike<infer B> ? B : never;\n};\n\n/**\n * State$ describes an [[Observable]] that emits a state object where\n * key/value pairs created by a sub [[Observable]] are immutable and\n * key/values streamed by a [[StateObservable]] are semi-mutuable in\n * the sense that you can change their value in an mutauble style as\n * a _setter_ has been defined for that key/value pair that will send\n * the assigned value to the StateObservable's [[Subject]]\n *\n */\nexport type State$<T extends MapOfObservables> = Observable<\n  MapOfStateFromMapOfObservables<ReadonlyByType<T, Observable<any>>>\n>;\n\n/**\n * Creates a single state observable from a map of [[ObservableLike]]\n */\nexport const createState = <T extends MapOfObservables>(\n  mapOfObservables: T\n): State$<T> => {\n  // Compile a list of keys that are part of the state object.\n  const keys = Object.keys(mapOfObservables);\n\n  // Reduce the list of keys to a list of observables where each observable\n  // is a thruple of the key, getter, and setter.\n  const observables$: Observable<\n    [string, () => any, () => void]\n  >[] = keys.reduce(\n    (acc, key) => {\n      const observable$ = mapOfObservables[key];\n\n      // If the observable is our custom StateObservable\n      if (isStateObservable(observable$)) {\n        // Destructure the StateObservable into it's actual observabble and dispatcher\n        const [state$, setState] = observable$;\n\n        // Map the state$ observable to a thruple of\n        // its key, getter, and setter\n        const nextState$ = state$.pipe(\n          map(state => {\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter\n              (nextState: any) => {\n                setState(nextState);\n              }\n            ];\n          })\n        );\n\n        // Add the composed state observable to the accumulator.\n        acc.push(nextState$);\n      }\n\n      // If the observable was just a regular observable\n      else {\n        const nextState$ = observable$.pipe(\n          map(state => {\n            // Map the state$ observable to a thruple of\n            // its key, getter, and setter\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter that will log an error message in dev mode\n              (value: any) => {\n                if (process.env.NODE_ENV === \"development\") {\n                  console.error(\n                    `Attempting to mutate state \"${key}\" with value \"${value}\" of state with properties ${keys.join(\n                      \", \"\n                    )}`\n                  );\n                }\n              }\n            ];\n          }),\n          tap(_ => console.warn(`Streaming [${key}]`)),\n\n        );\n\n        acc.push(nextState$);\n      }\n      return acc;\n    },\n    [] as any[]\n  );\n\n  // Combine the list of observables of [key, getter, setter]\n  // into a single state observable\n\n  type Key = string;\n  type Getter = () => any;\n  type Setter = () => void;\n\n  const state$ = combineLatest(...observables$).pipe(\n    map((states: [Key, Getter, Setter][]) =>\n      states.reduce(\n        (acc, [k, g, s]) => {\n          // Using Object.defineProperty to preserve the merging\n          // of getters and setters\n          Object.defineProperty(acc, k, {\n            get: g,\n            set: s\n          });\n\n          return acc;\n        },\n        {} as any\n      )\n    ),\n    tap(state => console.log('State, state', state)),\n    share()\n  );\n\n  return state$;\n};\n","import { combineLatest } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\n\nimport { todos$ } from \"../../modules/todo/observables\";\nimport { selectTodoFilter, filterTypeState$ } from \"../../modules/filter-todo\";\n\n/**\n * Observable returning todos filtered by selected filter type.\n */\nexport const todosByFilterType$ = combineLatest(\n  todos$,\n  filterTypeState$[0]\n).pipe(\n  map(\n    ([todos, filterType]) => selectTodoFilter(filterType)(todos)\n    // What I want is point-free but TypeScript can't handle me.\n    // fromAandBToC(\n    //   compose(\n    //     selectTodoFilter,\n    //     second\n    //   )\n  )\n);\n","import { identity } from '../utils'\n\nimport { FilterType } from './types'\nimport { filterActiveTodos, filterCompletedTodos  } from './filter'\nimport { isFilterTypeActive, isFilterTypeCompleted } from './assert'\n\n/**\n * selectTodoFilter :: FilterType -> [TodoWithOperation] -> [TodoWithOperation]\n * \n * Given a type of filter returns a function that filters a list of tuples of (Todo, TodoOperation)\n * \n */\nexport const selectTodoFilter = (filterType: FilterType) =>\n  isFilterTypeActive(filterType)\n    ? filterActiveTodos\n    : isFilterTypeCompleted(filterType)\n    ? filterCompletedTodos\n    : identity;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}