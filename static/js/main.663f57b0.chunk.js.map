{"version":3,"sources":["modules/todo/types.ts","modules/todo/utils.ts","apps/todo/components/Item.tsx","apps/todo/types.ts","apps/todo/components/List.tsx","modules/utils/index.ts","apps/todo/Todo.tsx","modules/rxjs-state/stateOf.ts","modules/todo/api.ts","modules/todo/constants.ts","modules/todo/events.ts","modules/todo/observables.ts","modules/utils/getset.ts","apps/todo/observables.ts","App.tsx","modules/rxjs-state/makeTimeTravelable.ts","modules/rxjs-state/createState.ts","serviceWorker.ts","index.tsx"],"names":["Status","EventType","makeIsStatus","statusType","checkedStatus","statusTypeIsOk","Ok","statusTypeIsBad","Bad","statusTypeIsNoop","Noop","statusTypeIsPending","Pending","makeIsOperationOfStatus","f","operation","status","isOk","isBad","isNoop","isPending","makeNoop","state","toPending","action","FilterType","Item","props","title","todo","style","opacity","isDeleting","transition","icon","completed","theme","undefined","onClick","onSave","error","fontStyle","List","console","log","new","newTodo","onChangeNew","noop","evt","currentTarget","value","className","twoLine","onCompleteAll","fullwidth","placeholder","height","onInput","onKeyUp","keyCode","onSubmitNew","autoFocus","trailingIcon","todos","map","key","id","onEdit","Delete","renderList","take","amount","xs","txs","len","length","i","push","first","thirst","second","threcond","tuple","a","b","thruple","c","makeIsFilterType","of","filterType","isFilterTypeAll","All","isFilterTypeCompleted","Completed","isFilterTypeActive","Active","makeFilterTodosByFilterType","filter","filterCompletedTodos","filterActiveTodos","identity","compose","g","list","textAlign","marginTop","use","choice","justifyContent","label","onChangeFilterType","onClearComplete","color","stateOf","initialState","piper","subject","Subject","nextState","setState","next","nextState$","pipe","piped$","asObservable","concat","failPattern","failIndex","getNextFailFlag","delay","ms","Promise","resolve","setTimeout","read","fetch","response","json","create","doFail","Math","floor","random","userId","update","Save","trim","nextTodo","current","deleet","makeSaveEvent","type","makeIsEventType","eventType","isFetchEventType","Fetch","isEditEventType","Edit","isSaveEventType","isDeleteEventType","makeIsEventOfType","event","isFetchEvent","isEditEvent","isSaveEvent","isDeleteEvent","events$","dispatch","todos$","storeTodos","storeTodo","get","mergeMap","stream","withLatestFrom","todoOrId","todoOperation","index","findIndex","nextTodos","splice","tap","eventsHandler$","groupBy","actionsByGroup$","timeoutWith","EMPTY","ignoreElements","groupedEvent$","switchMap","from","noopOperation","makeEditEvent$","data","curry","makeSaveEvent$","prop","getId","object","find","item","maybeTodo","pendingOperation","newTodoOperation$","state$","startWith","share","filterTypeState$","observable$","indexSubject","stateWithHistory$","scan","history","index$","combineLatest","max","makeTimeTravelable","mapOfObservables","observables$","Object","keys","reduce","acc","Array","isArray","isStateObservable","process","states","k","s","defineProperty","set","createState","selectTodoFilter","timeTravelableState$","setIndex","App","React","useState","setIndexState","useEffect","eventsHandlerSubscription","subscribe","indexSubscription","assign","window","unsubscribe","isComplete","Todo","makeEditEvent","forEach","padding","detail","discrete","start","step","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"6NAOYA,EAgDAC,E,yEAhDAD,K,YAAAA,E,kBAAAA,E,QAAAA,E,WAAAA,M,cAgDAC,K,cAAAA,E,YAAAA,E,YAAAA,E,iBAAAA,M,0CC5CNC,EAAe,SAAmBC,GAAnB,OAAqC,SACxDC,GADwD,OAEjCD,IAAeC,IAE3BC,EAAiBH,EAAaF,EAAOM,IACrCC,EAAkBL,EAAaF,EAAOQ,KACtCC,EAAmBP,EAAaF,EAAOU,MACvCC,EAAsBT,EAAaF,EAAOY,SAI1CC,EAA0B,SACrCC,GADqC,OAElC,SAA+BC,GAA/B,OAAwFD,EAAEC,EAAUC,UAE5FC,EAAOJ,EAAwBR,GAC/Ba,EAAQL,EAAwBN,GAChCY,EAASN,EAAwBJ,GACjCW,EAAYP,EAAwBF,GAEpCU,EAAW,SAAIC,GAC1B,MAAO,CACLN,OAAQhB,EAAOU,KACfY,UASG,SAASC,EAAgBR,EAAgCS,GAC9D,OAAc,MAAVA,EACK,CACLR,OAAQhB,EAAOY,QACfU,MAAOP,EAAUO,MACjBE,UAIG,CACLR,OAAQhB,EAAOY,QACfU,MAAOP,EAAUO,OCxCd,ICdKG,EDcCC,EAAO,SAACC,GAAD,OAClB,gCACE,gBAAC,IAAD,CAAYC,MAAOD,EAAME,KAAKD,MAAOE,MAAO,CAACC,QAASJ,EAAMK,WAAa,GAAM,EAAGC,WAAY,6BAC5F,gBAAC,IAAD,CACEC,KAAM,CACJA,KAAMP,EAAME,KAAKM,UACb,uBACA,yBACJC,MAAOT,EAAME,KAAKM,UAAY,eAAYE,EAC1CC,QAAS,kBACPX,EAAMY,OAAO,CAAEJ,WAAYR,EAAME,KAAKM,gBAG5C,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAuBC,MAAM,aAC1BT,EAAME,KAAKD,OAEd,gBAAC,IAAD,CACEQ,MAAOT,EAAMa,MAAQ,aAAUH,EAC/BP,MAAO,CAAEW,UAAW,YAEnBd,EAAMa,MACHb,EAAMa,MACNb,EAAMX,QAAUL,EAAoBgB,EAAMX,QAC1C,UACA,eAGR,gBAAC,IAAD,CACEkB,KACkB,MAAhBP,EAAMX,OACJ,GACEL,EAAoBgB,EAAMX,QAC5B,gBAAC,IAAD,CAAoBoB,MAAM,cACxB7B,EAAgBoB,EAAMX,QACxB,CAAEkB,KAAM,QAASE,MAAO,SACtB/B,EAAesB,EAAMX,QACvB,CAAEkB,KAAM,QAASE,MAAO,WAExB,MAKR,gBAAC,IAAD,Q,QElBSM,EAAO,SAACf,GACnBgB,QAAQC,IAAI,MAAOjB,EAAMkB,IAAI7B,QAC7B,IAAM8B,EAAUnB,EAAMkB,IAEhBE,EAAc9B,EAAK6B,GACrBE,IACA,SAACC,GACCtB,EAAMoB,YAAYE,EAAIC,cAAcC,QAG1C,OACE,gBAAC,IAAD,CAAQC,UAAU,YAAYC,SAAO,GACnC,gBAAC,IAAD,KACE,gBAAC,IAAD,CACEzB,MAAO,wBACPM,KAAM,CAAEA,KAAM,sBAAuBI,QAASX,EAAM2B,eACpDlB,MAAM,cAEPhB,EAAUO,EAAMkB,KACf,gCACE,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAuBT,MAAM,aAC1BT,EAAMkB,IAAIvB,OAEb,gBAAC,IAAD,CAAyBQ,MAAO,CAAEW,UAAW,YAA7C,YAIF,gBAAC,IAAD,CACEP,KACsB,MAApBP,EAAMkB,IAAI7B,OACR,GACEI,EAAUO,EAAMkB,KAClB,gBAAC,IAAD,CAAoBT,MAAM,cACxBlB,EAAMS,EAAMkB,KACd,CAAEX,KAAM,QAASE,MAAO,SACtBnB,EAAKU,EAAMkB,KACb,CAAEX,KAAM,QAASE,MAAO,WAExB,MAMR,gBAAC,IAAD,CACEmB,WAAS,EACTnB,MAAM,oBACNoB,YAAY,iCACZ1B,MAAO,CAAE2B,OAAQ,QACjBC,QAASX,EACTI,MAAOxB,EAAMkB,IAAIvB,OAAS,GAC1BqC,QAAS,SAAAV,GAAG,OAAoB,KAAhBA,EAAIW,SAAkBjC,EAAMkC,eAC5CC,WAAS,EACTC,aAAc7C,EAAMS,EAAMkB,KAAO,CAACX,KAAM,QAASE,MAAO,cAAWC,KAIzE,gBAAC,IAAD,MAtFoB,SAACV,GAAD,OACxBA,EAAMqC,MAAMC,KAAI,YAAwB,IAAD,mBAArBpC,EAAqB,KAAfd,EAAe,KAErC,OACE,gBAAC,EAAD,CACEmD,IAAKrC,EAAKsC,GACVtC,KAAMA,EACNuC,OAAQzC,EAAMyC,OAAOvC,EAAMd,GAC3BwB,OAAQZ,EAAMY,OAAOV,EAAMd,GAC3BC,OAAQD,GAAaA,EAAUC,OAC/BgB,WAAYZ,EAAUL,IAAcA,EAAUS,SAAWvB,EAAUoE,OACnE7B,MACGzB,GAAaG,EAAMH,IAAcA,EAAUyB,YAAUH,OA2EzDiC,CAAW3C,M,SDnGNF,K,UAAAA,E,gBAAAA,E,uBAAAA,M,+BEYC8C,EAAO,SAACC,GAAD,OAAoB,SAAIC,GAI1C,IAHA,IAAMC,EAAW,GACXC,EAAMF,EAAGG,OAENC,EAAI,EAAGA,EAAIF,GAAOE,EAAIL,EAAQK,GAAK,EAC1CH,EAAII,KAAKL,EAAGI,IAGd,OAAOH,IAUIK,EAAQ,wCAERC,EAAS,wCAMTC,EAAS,wCAETC,EAAW,wCAOXC,EAAQ,SAAOC,EAAMC,GAAb,MAAmC,CAACD,EAAGC,IAE/CC,EAAU,SAAUF,EAAMC,EAAME,GAAtB,MAA0C,CAACH,EAAGC,EAAGE,IAmB3DC,EAAmB,SAAuBC,GAAvB,OAAiC,SAC/DC,GAD+D,OAE3CA,IAAeD,IAExBE,EAAkBH,EAAiB/D,EAAWmE,KAC9CC,EAAwBL,EAAiB/D,EAAWqE,WACpDC,EAAqBP,EAAiB/D,EAAWuE,QAGjDC,EAA8B,SACzCP,GADyC,OAEtC,SAAC1B,GAAD,OACH0B,IAAejE,EAAWmE,IACtB5B,EACAA,EAAMkC,QACJ,gBAAErE,EAAF,2BACGgE,EAAsBH,IAAe7D,EAAKM,WAC1C4D,EAAmBL,KAAgB7D,EAAKM,eAGtCgE,EAAuBF,EAClCxE,EAAWqE,WAEAM,EAAoBH,EAC/BxE,EAAWuE,QAqBAK,EAAW,SAAIlD,GAC1B,OAAOA,GAQImD,EAAU,SAAUxF,EAAgByF,GAA1B,OAA6C,SAACnB,GAAD,OAClEtE,EAAEyF,EAAEnB,M,wBClGS,WAACzD,GAEd,IAAM6E,EACJ,gBAAC,EAAD,CACExC,MAAOrC,EAAMqC,MACbI,OAAQzC,EAAMyC,OACd7B,OAAQZ,EAAMY,OACdQ,YAAapB,EAAMoB,YACnBF,IAAKlB,EAAMkB,IACXgB,YAAalC,EAAMkC,YACnBP,cAAe3B,EAAM2B,gBAIzB,OACE,gCACE,uBAAKxB,MAAO,CAAE2E,UAAW,SAAUC,UAAW,KAC5C,gBAAC,IAAD,CAAcC,IAAI,YAAYvE,MAAM,aAApC,UAIF,2BAASgB,UAAU,WACjB,2BAASA,UAAU,QAAQoD,GAC3B,0BAAQpD,UAAU,SAAStB,MAAO,CAAE2E,UAAW,WAC7C,gBAAC,IAAD,CAAWG,QAAM,EAAC9E,MAAO,CAAE+E,eAAgB,WACzC,gBAAC,IAAD,CACEC,MAAM,MACN1E,MACEuD,EAAgBhE,EAAM+D,YAAc,mBAAgBrD,EAEtDC,QAAS,kBAAMX,EAAMoF,mBAAmBtF,EAAWmE,QAErD,gBAAC,IAAD,CACEkB,MAAM,SACN5E,KAAK,yBACLE,MACE2D,EAAmBpE,EAAM+D,YAAc,mBAAgBrD,EAEzDC,QAAS,kBAAMX,EAAMoF,mBAAmBtF,EAAWuE,WAErD,gBAAC,IAAD,CACEc,MAAM,YACN5E,KAAK,uBACLE,MACEyD,EAAsBlE,EAAM+D,YACxB,mBACArD,EAENC,QAAS,kBAAMX,EAAMoF,mBAAmBtF,EAAWqE,eAIvD,2BACE,gBAAC,IAAD,CAAUxD,QAASX,EAAMqF,iBAAzB,oBAEF,gBAAC,IAAD,CAAcL,IAAI,UAAU7E,MAAO,CAACmF,MAAO,WACzC,8BACGtF,EAAMqC,MAAMkC,QAAO,uCAAkB/D,aAAWyC,QACzC,IAHZ,iB,6JCtDGsC,GAAU,SACrBC,GAEwB,IADxBC,EACuB,uDADuBf,EAGxCgB,EAAU,IAAIC,KAEhBC,EAAYJ,EACVK,EAAW,SAAClG,GAEhBiG,EAAYjG,EACZ+F,EAAQI,KAAKnG,IAGToG,EAAajC,iBAAG,GAAQkC,KAC5B1D,cAAI,kBAAMsD,MAGNK,EAASR,EAAMC,EAAQQ,gBAI7B,MAAO,CACLC,aAAOJ,EAAYE,GACnBJ,EACAL,I,mmBChCJ,IAAInD,GAAgB,GAEd+D,GAAc,EAAC,GAAM,GAAO,GAAO,GAAM,GAAM,GAAO,GACxDC,GAAY,EAEVC,GAAkB,WAOtB,OANAD,IAAa,GAEGD,GAAYnD,OAAS,IACnCoD,GAAY,GAGPD,GAAYC,KAGfE,GAAQ,SAACC,GAAD,OACZ,IAAIC,SAAc,SAAAC,GAAO,OAAIC,WAAWD,EAASF,OAKtCI,GAAI,yCAAG,+BAAAnD,EAAA,yDACH6C,OAEXjE,GAAMY,QAAU,GAHF,iCAIO4D,MC5CR,+CDwCC,cAIVC,EAJU,gBAKWA,EAASC,OALpB,cAKVA,EALU,iBAMVR,GAAM,MANI,QAOhBlE,GAAQO,EAAK,GAALA,CAASmE,GAAMzE,KAAI,SAAApC,GAAI,aAASA,EAAT,CAAeM,WAAW,OAPzC,yCASV+F,GAAM,KATI,iCAWXlE,IAXW,4CAAH,qDAkBJ2E,GAAM,yCAAG,WACpB5H,GADoB,kBAAAqE,EAAA,6DAGdwD,EAASX,KAHK,SAKdC,GAAM,MALQ,WAOhBU,EAPgB,yCAQX,CACL5H,OAAQhB,EAAOQ,IACfgC,MAAO,iCACPlB,MAAOP,EAAUO,QAXD,UAefP,EAAUO,MAfK,yCAgBX,CACLN,OAAQhB,EAAOQ,IACfgC,MAAO,uBACPlB,MAAOP,EAAUO,QAnBD,cAuBdO,EAAO,CACXsC,GAAI0E,KAAKC,MAAsB,IAAhBD,KAAKE,UACpBC,OAAQH,KAAKC,MAAsB,IAAhBD,KAAKE,UACxBnH,MAAOb,EAAUO,MACjBa,WAAW,GAGb6B,GAAK,sBAAOA,IAAP,CAAcnC,IA9BC,kBAgCb,CACLb,OAAQhB,EAAOM,GACfgB,MAAOO,IAlCW,4CAAH,sDAsCNoH,GAAM,yCAAG,WACpBpH,EACAd,GAFoB,kBAAAqE,EAAA,sEAId8C,GAAM,MAJQ,WAKLD,KALK,yCAQX,CACLjH,OAAQhB,EAAOQ,IACfgC,MAAO,iCACPlB,MAAOP,EAAUO,MACjBE,OAAQvB,EAAUiJ,OAZF,UAgBdtH,EAAQb,EAAUO,MAAMM,MAAMuH,OAhBhB,yCAmBX,CACLnI,OAAQhB,EAAOQ,IACfgB,OAAQvB,EAAUiJ,KAClB1G,MAAO,uBACPlB,MAAM,GAAD,GACAP,EAAUO,MADV,CAEHM,YAzBc,cA8BdwH,EA9Bc,MA+BfvH,EA/Be,GAgCfd,EAAUO,MAhCK,CAiClBM,UAGFoC,GAAQA,GAAMC,KAAI,SAAAoF,GAChB,OAAIA,EAAQlF,KAAOiF,EAASjF,GACnBiF,EAGFvH,KAzCW,kBA4Cb,CACLb,OAAQhB,EAAOM,GACfgB,MAAM,GAAD,GAAOO,EAAP,GAAgBd,EAAUO,MAA1B,CAAiCM,UACtCJ,OAAQvB,EAAUiJ,OA/CA,4CAAH,wDAmDNI,GAAM,yCAAG,WACpBzH,EACAd,GAFoB,UAAAqE,EAAA,sEAId8C,GAAM,MAJQ,WAKLD,KALK,yCAQX,CACLjH,OAAQhB,EAAOQ,IACfgC,MAAO,oBACPlB,MAAOP,EAAUO,MACjBE,OAAQvB,EAAUoE,SAZF,cAgBpBL,GAAQA,GAAMkC,QAAO,SAAAmD,GAAO,OAAIA,EAAQlF,KAAOtC,EAAKsC,MAhBhC,kBAkBb,CACLnD,OAAQhB,EAAOM,GACfgB,MAAOO,EACPL,OAAQvB,EAAUoE,SArBA,2CAAH,wDE9GNkF,GAAgB,SAC3B1H,EACAd,GAIA,MAAO,CAAEyI,KAAMvJ,EAAUiJ,KAAMrH,OAAMd,cAa1B0I,GAAkB,SAAsBhE,GAAtB,OAAgC,SAC7DiE,GAD6D,OAE1CA,IAAcjE,IAKtBkE,GAAmBF,GAAgBxJ,EAAU2J,OAK7CC,GAAkBJ,GAAgBxJ,EAAU6J,MAK5CC,GAAkBN,GAAgBxJ,EAAUiJ,MAK5Cc,GAAoBP,GAAgBxJ,EAAUoE,QAK9C4F,GAAoB,SAC/BnJ,GAD+B,OAE5B,SAACoJ,GAAD,OACHpJ,EAAEoJ,EAAMV,QAKGW,GAAeF,GAAkBN,IAKjCS,GAAcH,GAAkBJ,IAKhCQ,GAAcJ,GAAkBF,IAKhCO,GAAgBL,GAAkBD,IC9ClCO,GAAU,IAAIjD,KAKdkD,GAAW,SAACN,GACvBK,GAAQ9C,KAAKyC,I,GAOqBhD,GAA6B,I,qBAAnDuD,G,MAAQC,G,MAmDhBC,GAAY,SAChBC,GADgB,OAGhBC,cAAS,SAACC,GAAD,OACPrF,YAAGqF,GAAQnD,KAEToD,aAAeN,IACfxG,cAAI,YAAsB,IAAD,mBAAnB6G,EAAmB,KAAX9G,EAAW,OACW4G,EAAIE,GADf,mBAChBE,EADgB,KACNC,EADM,KAIjBC,EAAQlH,EAAMmH,WAClB,uCACUhH,MACa,kBAAb6G,EAAwBA,EAAWA,EAAS7G,OAGxD,GAAI+G,GAAS,EAAG,CAEd,IAAME,EAAS,YAAOpH,GAMtB,OALAoH,EAAUC,OAAOH,EAAO,EAAG,CACL,kBAAbF,EAAwBhH,EAAMkH,GAAO,GAAKF,EACjDC,IAGK3F,EAAQ2F,EAAeG,EAAWJ,GAG3C,OAAO1F,EAAQ2F,EAAejH,EAAOgH,MAEvCM,aACEhF,EACEoE,GACAxF,SAqIGqG,GA5FgBhB,GAAQ5C,KACnC6D,cACE,SAAAtB,GACE,OAAIC,GAAaD,GACRjK,EAAU2J,MACRQ,GAAYF,IAAUG,GAAYH,GACpCA,EAAMrI,KAAKsC,GACTmG,GAAcJ,GAChBA,EAAM/F,QADR,KAIT,SAAA+F,GAAK,OAAIA,KACT,SAAAuB,GAAe,OACbA,EAAgB9D,KACd+D,aAAY,KAAOC,MACnBC,mBAGNf,cAAS,SAAAgB,GAAa,OACpBA,EAAclE,KACZmE,cAAU,SAAA5B,GACR,GAAIC,GAAaD,GACf,OA7IR6B,aAAKxD,MAAQZ,KACXoD,aAAeN,IACfxG,cAAI,YAAsB,IAAD,mBAAnBwD,EAAmB,KAAb4B,EAAa,KAcvB,MAZqC,sBAChCA,GADgC,YAEhC5B,EAAKxD,KAAI,SAAApC,GACV,IAAMmK,EAAgB3K,EAAS,CAC7BO,MAAOC,EAAKD,MACZO,UAAWN,EAAKM,YAGlB,OAAOgD,EAAMtD,EAAMmK,WAMzBV,aAAIZ,KA2HsB/C,KAAK1D,cAAI,SAAAD,GAAK,OAAImB,EAAM+E,EAAOlG,OAC9C,GAAIoG,GAAYF,GACrB,OAtHa,SAACA,GAAD,OACrBzE,iBAAG,GAAQkC,KACToD,aAAeN,IACfxG,aAAIgB,GACJhB,cAAI,SAAAD,GACF,IAAMkH,EAAQlH,EAAMmH,WAAU,uCAAiBhH,KAAO+F,EAAMrI,KAAKsC,MAC3DiH,EAAS,YAAOpH,GAEtB,OADAoH,EAAUC,OAAOH,EAAO,EAAG,CAAChB,EAAMrI,KAAMqI,EAAMnJ,YACvCqK,KAETE,aAAIZ,IACJzG,cAAI,SAAAmH,GAAS,OAAIjG,EAAM+E,EAAOkB,OA2GjBa,CAAe/B,GACjB,GAAIG,GAAYH,GACrB,OAzDa,SAACA,GAAD,OACrBpC,aAEErC,YAAGlE,EAAU2I,EAAMnJ,UAAWd,EAAUiJ,OAAOvB,KAC7CgD,IAAU,SAAAG,GAAM,OAAI3F,EAAM+E,EAAMrI,KAAMiJ,MACtC7G,cAAI,SAAAiI,GAAI,OAAIhH,EAASgH,MACrBjI,cAAI,SAAAiI,GAAI,ONtCiBpL,EMsCPqE,ENtCgC,SAACC,GAAD,OAAU,SAACC,GAAD,OAAUvE,EAAEsE,EAAGC,MMsClD6E,EAAbiC,CAAoBD,GNtCjB,IAAUpL,MMyC3BiL,aAAK9C,GAAOiB,EAAMrI,KAAMqI,EAAMnJ,YAAY4G,KACxCgD,IAAU,SAAAG,GAIR,OAAO3F,EAAMlE,EAAK6J,GAAUA,EAAOxJ,MAAQ4I,EAAMrI,KAAMiJ,MAGzD7G,aAAIe,GAGJ6F,cAAS,SAAAC,GAAM,OAAIrF,YAAGqF,GAAQnD,KAAKO,YAAMjH,EAAK6J,GAAU,IAAM,SAG9DH,IAAU,SAAAG,GAAM,OAAI3F,EAAM+E,EAAMrI,KAAKsC,GAAI9C,EAASyJ,EAAOxJ,WACzD2C,cAAI,SAAAmH,GAAS,OAAIjG,EAAM+E,EAAOkB,QAiCnBgB,CAAelC,GAGxB,ICnO8BmC,EDmOxBC,GCnOwBD,EDmOZ,KCjOxB,SAA6CE,GAC3C,OAAOA,EAAOF,KDkOV,OAAO5G,iBAAG,GAAQkC,KAChBoD,aAAeN,IACfxG,aAAIgB,GACJhB,cAAI,SAAAD,GAAK,OAAIA,EAAMwI,MAAK,SAAAC,GAAI,OAAIH,EAAMvH,EAAM0H,MAAWH,EAAMpC,SAC7DW,cAAS,SAAA6B,GAAS,OAChBA,EACIjH,YAAGiH,GAAW/E,KACZzB,cACE,SACEgG,GADF,OAQK/K,EAAO8D,EAAOiH,KAAUhL,EAAM+D,EAAOiH,OAI5CvB,IAAU,mCAAE9I,EAAF,KAAQd,EAAR,YACRoE,EAAMtD,EAAMN,EAAUR,EAAWd,EAAUoE,YAE7CwG,cAAS,mCAAE8B,EAAF,KAAuB9K,GAAvB,kBACPkK,aACEzC,GACEzH,EACA8K,IAEFhF,KACAkD,cACE,SAAAC,GACE,OAAI7J,EAAM6J,GACDrF,iBAAG,GAAQkC,KAChBoD,aAAeN,IACfxG,aAAIgB,GACJqG,cAAI,SAAAtH,GAAK,OAAI0G,GAAW1G,EAAMkC,QAAO,uCAAiB/B,KAAO2G,EAAOxJ,MAAM6C,WAIvEsB,iBAAG,GAAQkC,KAChBgD,IACE,iBAAM,CAAC5F,EAAM2H,GAAY5B,eAQvCrF,YAAGN,EAAM+E,OAAO7H,gBAgBnBuK,GAAoB1F,GAC/B,CACElG,OAAQhB,EAAOU,KACfY,MAAO,KAET,SAAAuL,GAAM,OACJA,EAAOlF,KACLmE,cAAU,SAAAxK,GAAK,OACbF,EAAUE,GACNyK,aAAKpD,GAAOrH,IAAQqG,KAClBoD,aAAeN,IACfa,cAAI,YAAyB,IAAD,mBAAtB/D,EAAsB,KAAXvD,EAAW,KACtB/C,EAAKsG,IACPmD,GAAW,GAAD,mBACL1G,GADK,CAERmB,EAAMoC,EAAUjG,MAAOD,EAASkG,EAAUjG,cAGhD2C,aAAIc,GACJd,cAAI,SAAAsD,GAAS,OAAKrG,EAAMqG,GAAaA,EAAYlG,EAAS,OAC1DyL,aAAUxL,IAEZmE,YAAGnE,MAETyL,mBEhTOC,GAAmB9F,GAAQzF,EAAWmE,K,6jBCoBnD,I,GCRkC,SAAIqH,GACpC,IAAMC,EAAe,IAAI5F,KAEnB6F,EAAoBF,EAAYtF,KAEpCyF,cACE,WAAmB3F,GAAnB,uBAAEnG,EAAF,KAAS+L,EAAT,WACE,CAAC5F,EAAMnG,EAAK,sBAAO+L,GAAP,CAAgB/L,IAAS,MACvC,MAACe,EAAW,MAIViL,EAASC,aACbL,EAAarF,eAAeF,KAAKmF,cAAW,IAC5CK,GACAxF,KACA1D,cAAI,YAA2B,IAAD,mBAAxBiH,EAAwB,KAAdmC,EAAc,uBAC5B,OAAInC,EAAQ,EACH,EAAE,EAAGmC,EAAQzI,QACXsG,EAAQmC,EAAQzI,OAAS,EAC3B,CAACyI,EAAQzI,OAAS,EAAGyI,EAAQzI,QAG/B,CAACsG,EAAOmC,EAAQzI,YAY3B,MAAO,CARQ2I,aAAcD,EAAQH,GAAmBxF,KACtD1D,cAAI,yDAAGiH,EAAH,KAAUsC,EAAV,2BAAiBlM,EAAjB,KAAwB+L,EAAxB,YACFnC,GAAS,GAAiC,MAA5BmC,EAAQG,EAAMtC,EAAQ,GAAamC,EAAQG,EAAMtC,EAAQ,GAAK5J,MAI/D,SAAC4J,GAAD,OAAmBgC,EAAazF,KAAKyD,IAE5BoC,GDrBqBG,CE2BtB,SACzBC,GAGA,IAIMC,EAJOC,OAAOC,KAAKH,GAMdI,QACT,SAACC,EAAK7J,GACJ,IAAM+I,EAAcS,EAAiBxJ,GAGrC,GTlE2B,SAC/B+I,GAD+B,OAEOe,MAAMC,QAAQhB,GSgE5CiB,CAAkBjB,GAAc,mBAEPA,EAFO,GAE3BJ,EAF2B,KAEnBrF,EAFmB,KAM5BE,EAAamF,EAAOlF,KACxB1D,cAAI,SAAA3C,GACF,MAAO,CAEL4C,EAEA,kBAAM5C,GAEN,SAACiG,GACCC,EAASD,SAOjBwG,EAAIjJ,KAAK4C,OAIN,CACH,IAAMA,EAAauF,EAAYtF,KAC7B1D,cAAI,SAAA3C,GAGF,MAAO,CAEL4C,EAEA,kBAAM5C,GAEN,SAAC6B,GACKgL,QAYZJ,EAAIjJ,KAAK4C,GAEX,OAAOqG,IAET,IA4BF,OAlBeR,KAAa,WAAb,cAAiBI,IAAchG,KAC5C1D,cAAI,SAACmK,GAAD,OACFA,EAAON,QACL,SAACC,EAAD,GAAqB,IAAD,mBAAbM,EAAa,KAAV9H,EAAU,KAAP+H,EAAO,KAQlB,OALAV,OAAOW,eAAeR,EAAKM,EAAG,CAC5BzD,IAAKrE,EACLiI,IAAKF,IAGAP,IAET,QF7HOU,CAAY,CACzBzK,MDnBgCuJ,aAChC9C,GACAuC,GAAiB,IACjBrF,KACA1D,cACE,mCAAED,EAAF,YRgI4B,SAAC0B,GAAD,OAC9BK,EAAmBL,GACfU,EACAP,EAAsBH,GACtBS,EACAE,EQrIuBqI,CAAzB,KAAyBA,CAA6B1K,OCexD0B,WAAYsH,GACZnK,IAAK+J,M,qBAGA+B,G,MAAsBC,G,MAAUtB,G,MAmKxBuB,GA7JH,WACVlM,QAAQC,IAAI,cADI,MAEUkM,IAAMC,WAFhB,mBAETzN,EAFS,KAEFkG,EAFE,OAIsBsH,IAAMC,SAAS,EAClD,EACD,IANc,yCAIR7D,EAJQ,KAIDsC,EAJC,KAIKwB,EAJL,KAkChB,GAzBAF,IAAMG,WAAU,WAGd,IAAMC,EAA4B3D,GAAe4D,YAE3CC,EAAoB9B,GACvB3F,KAAK2D,cAAI,SAAA7D,GAAI,OAAIuH,EAAcvH,OAC/B0H,YAEuBR,GACvBhH,KACC2D,aAAI9D,GACJ8D,cAAI,SAAAhK,GAAK,OAAIsM,OAAOyB,OAAOC,OAAQ,CAAEhO,cAEtC6N,YAIH,OAFA3E,GJtDK,CAAEhB,KAAMvJ,EAAU2J,QIwDhB,WACLsF,EAA0BK,cAC1BH,EAAkBG,cAClBH,EAAkBG,iBAEnB,IAECjO,EAAO,CACT,IA4CMkO,EAAa,SAAC3N,GAAD,OAAmC,IAAnBA,EAAKM,WAwCxC,OACE,oCACE,6BACE,yBAAKiB,UAAU,WACb,kBAACqM,EAAD,CACEzL,MAAO1C,EAAM0C,MACbnB,IAAKvB,EAAMuB,IACXkE,mBAAoBmE,GAAS,EAAIlI,IA3FhB,SAAC0C,GAC1BpE,EAAMoE,WAAaA,GA2FX3C,YAAamI,GAAS,EAAIlI,IAxFhB,SAACpB,GACnBN,EAAMuB,IAAMxB,EAASO,IAwFbiC,YAAaqH,GAAS,EAAIlI,IArFhB,WACb5B,EAAUE,EAAMuB,OAAMvB,EAAMuB,IAAMtB,EAAUD,EAAMuB,OAqF/C6C,WAAYpE,EAAMoE,WAClBtB,OAAQ8G,GAAS,EAAI,kBAAMlI,KAnFtB,SAACnB,EAAYd,GAAb,OAA0C,SACvDO,IAEIH,EAAOJ,IAAcG,EAAMH,KAC7ByJ,GJzEqB,SAC3B3I,EACAd,GAIA,MAAO,CAAEyI,KAAMvJ,EAAU6J,KAAMjI,OAAMd,aIoE7B2O,CAAc7N,EAAD,MACRd,EADQ,CAEXO,MAAM,MACDP,EAAUO,MADV,GAEAA,SA2EHiB,OAAQ2I,GAAS,EAAI,kBAAMlI,KApEtB,SAACnB,EAAYd,GAAb,OAA0C,WAEnD,IADJO,EACG,uDADiD,IAEhDH,EAAOJ,IAAcG,EAAMH,KAC7ByJ,GACEjB,GAAc1H,EAAD,MACRd,EADQ,CAEXO,MAAM,MACDP,EAAUO,MADV,GAEAA,SA4DHgC,cAAe4H,GAAS,EAAIlI,IAnDhB,kBACpB1B,EAAM0C,MACHkC,OACCI,GACE,SAAAlB,GAAC,OAAKA,IACNkB,EACEkJ,EACAzK,KAILmB,QACC,SAACrE,GAAD,OACEV,EAAO8D,EAAOpD,KAAUX,EAAM+D,EAAOpD,OAExCoC,KAAI,SAAApC,GAAI,OACPsD,EAAMJ,EAAMlD,GAAP,MACAoD,EAAOpD,GADP,CAEHP,MAAM,MAAM2D,EAAOpD,GAAMP,MAApB,CAA2Ba,WAAW,UAG9CwN,SAAQ,SAAA9N,GAAI,OAAI2I,GAASjB,GAAa,WAAb,cAAiB1H,SA+BrCmF,gBAAiBkE,GAAS,EAAIlI,IA7BhB,WACtB1B,EAAM0C,MACHkC,OACCI,EACEkJ,EACAzK,IAGHmB,QACC,SAACrE,GAAD,OACEV,EAAO8D,EAAOpD,KAAUX,EAAM+D,EAAOpD,OAExC8N,SAAQ,gBJlHexL,EIkHbtC,EAAF,2BAAY2I,IJlHGrG,EIkHsBtC,EAAKsC,GJjHlD,CAAEqF,KAAMvJ,EAAUoE,OAAQF,gBIsI3B,6BACE,yBAAKrC,MAAO,CAAE8N,QAAS,KACrB,kBAAC,KAAD,CACEzM,MAAO+H,EAAQ,EAAIsC,EAAMA,EAAMtC,EAAQ,EAEvCxH,QAAS,SAAAT,GAAG,OAAI2L,GAASpB,EAAMvK,EAAI4M,OAAO1M,MAAQ,IAClD2M,UAAQ,EACRC,MAAO,EACPvC,IAAKA,EACLwC,KAAM,OAQlB,OAAO,2CG7LWC,QACW,cAA7BX,OAAOY,SAASC,UAEe,UAA7Bb,OAAOY,SAASC,UAEhBb,OAAOY,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,GAAD,MAASC,SAASC,eAAe,SDmI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.663f57b0.chunk.js","sourcesContent":["export type Todo = {\n  readonly id: number;\n  readonly title: string;\n  // userId: number;\n  readonly completed: boolean;\n};\n\nexport enum Status {\n  Noop = \"Noop\",\n  Pending = \"Pending\",\n  Ok = \"Ok\",\n  Bad = \"Bad\"\n}\n\nexport type Noop<T> = {\n  status: Status.Noop;\n  state: T;\n};\n\nexport type Pending<T, A = void> = {\n  status: Status.Pending;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Bad<T, A = void> = {\n  status: Status.Bad;\n  state: T;\n  error: string;\n} & (A extends void ? {} : { action: A });\n\nexport type Ok<T, A = void> = {\n  status: Status.Ok;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Operation<T, U = T, A = void> =\n  | Noop<T>\n  | Pending<T, A>\n  | Bad<T, A>\n  | (U extends void ? Noop<T> : Ok<U, A>);\n\n\n\nexport type NewTodoOperation = Operation<string, void>;\n\n// type Foo = Operation<string, boolean>\n\nexport type Mutable = Pick<Todo, \"completed\" | \"title\">;\n\nexport type OperationalEventTypes = EventType.Save | EventType.Delete;\n\nexport type TodoOperation = Operation<Mutable, Todo, OperationalEventTypes>;\n\n// Events\n\nexport enum EventType {\n  Fetch = \"Fetch\",\n  Edit = \"Edit\",\n  Save = \"Save\",\n  Delete = \"Delete\"\n}\n\nexport type FetchEvent = {\n  type: EventType.Fetch;\n};\n\nexport type EditEvent = {\n  type: EventType.Edit;\n  operation: Noop<Mutable> | Bad<Mutable, OperationalEventTypes>;\n  todo: Todo;\n};\n\nexport type SaveEvent = {\n  type: EventType.Save;\n  operation: Noop<Mutable> | Bad<Mutable, OperationalEventTypes>;\n  todo: Todo;\n};\n\nexport type DeleteEvent = {\n  type: EventType.Delete;\n  id: number;\n};\n\nexport type TodoEvent = FetchEvent | EditEvent | SaveEvent | DeleteEvent;\n","import {\n  Status,\n  Operation,\n  Todo,\n  Noop,\n  Bad,\n  Pending,\n} from \"./types\";\nimport { number } from \"prop-types\";\n\n// Assertions\nconst makeIsStatus = <T extends Status>(statusType: T) => (\n  checkedStatus: Status\n): checkedStatus is T => statusType === checkedStatus;\n\nexport const statusTypeIsOk = makeIsStatus(Status.Ok);\nexport const statusTypeIsBad = makeIsStatus(Status.Bad);\nexport const statusTypeIsNoop = makeIsStatus(Status.Noop);\nexport const statusTypeIsPending = makeIsStatus(Status.Pending);\n\n// type Foo = <S, O extends Operation<S>, A extends O['status']>\n\nexport const makeIsOperationOfStatus = <S extends Status>(\n  f: (statusType: Status) => statusType is S\n) => <O extends { status: Status }>(operation: O): operation is Extract<O, { status: S }> => f(operation.status)\n\nexport const isOk = makeIsOperationOfStatus(statusTypeIsOk);\nexport const isBad = makeIsOperationOfStatus(statusTypeIsBad);\nexport const isNoop = makeIsOperationOfStatus(statusTypeIsNoop);\nexport const isPending = makeIsOperationOfStatus(statusTypeIsPending);\n\nexport const makeNoop = <T>(state: T): Noop<T> => {\n  return {\n    status: Status.Noop,\n    state,\n  }\n}\n\n// export const toPendingWithAction = <T, A, B extends A>(operation: Noop<T> | Bad<T, A>, action: B): Pending<T, B> => toPending(operation, action)\n\n\nexport function toPending<T>(operation: Noop<T> | Bad<T>): Pending<T>\nexport function toPending<T, A>(operation: Noop<T> | Bad<T, A>, action: A): Pending<T, A>\nexport function toPending<T, A>(operation: Noop<T> | Bad<T, A>, action?: A): Pending<T, any> {\n  if (action != null) {\n    return {\n      status: Status.Pending,\n      state: operation.state,\n      action,\n    }\n  }\n\n  return {\n    status: Status.Pending,\n    state: operation.state,\n  }\n}","import * as React from \"react\";\nimport { Todo, Status, Mutable } from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\nimport { isBad, isPending, isOk, statusTypeIsPending, statusTypeIsBad, statusTypeIsOk } from \"../../../modules/todo/utils\";\n\nexport type PropsItem = {\n  todo: Todo;\n  status: Status,\n  error?: string,\n  onEdit: (state: Partial<Mutable>) => void;\n  onSave: (state?: Partial<Mutable>) => void;\n  isDeleting: boolean\n};\n\nexport const Item = (props: PropsItem) => (\n  <>\n    <R.ListItem title={props.todo.title} style={{opacity: props.isDeleting ? 0.5 : 1, transition: 'opacity 0.2s ease-in-out'}}>\n      <R.ListItemGraphic\n        icon={{\n          icon: props.todo.completed\n            ? \"check_circle_outline\"\n            : \"radio_button_unchecked\",\n          theme: props.todo.completed ? \"primary\" : undefined,\n          onClick: () =>\n            props.onSave({ completed: !props.todo.completed })\n        }}\n      />\n      <R.ListItemText>\n        <R.ListItemPrimaryText theme=\"secondary\">\n          {props.todo.title}\n        </R.ListItemPrimaryText>\n        <R.ListItemSecondaryText\n          theme={props.error ? \"error\" : undefined}\n          style={{ fontStyle: \"italic \" }}\n        >\n          {props.error\n            ? props.error\n            : props.status && statusTypeIsPending(props.status)\n            ? \"...busy\"\n            : \"Get to it!\"}\n        </R.ListItemSecondaryText>\n      </R.ListItemText>\n      <R.ListItemMeta\n        icon={\n          props.status == null ? (\n            \"\"\n          ) : statusTypeIsPending(props.status) ? (\n            <R.CircularProgress theme='secondary' />\n          ) : statusTypeIsBad(props.status) ? (\n            { icon: \"error\", theme: \"error\" }\n          ) : statusTypeIsOk(props.status) ? (\n            { icon: \"check\", theme: \"primary\" }\n          ) : (\n            \"\"\n          )\n        }\n      />\n    </R.ListItem>\n    <R.ListDivider />\n  </>\n);\n","export enum FilterType {\n  All = \"All\",\n  Active = \"Active\",\n  Completed = \"Completed\"\n}\n","import * as React from \"react\";\nimport { Todo, TodoOperation, NewTodoOperation, Status, Mutable, EventType } from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\n\nimport { Item } from \"./Item\";\nimport {\n  isOk,\n  isPending,\n  isBad\n} from \"../../../modules/todo/utils\";\nimport { noop } from \"rxjs\";\n\nexport const renderList = (props: PropsList) =>\n  props.todos.map(([todo, operation]) => {\n\n    return (\n      <Item\n        key={todo.id}\n        todo={todo}\n        onEdit={props.onEdit(todo, operation)}\n        onSave={props.onSave(todo, operation)}\n        status={operation && operation.status}\n        isDeleting={isPending(operation) && operation.action === EventType.Delete}\n        error={\n          (operation && isBad(operation) && operation.error) || undefined\n        }\n      />\n    );\n  });\n\nexport type PropsList = {\n  todos: [Todo, TodoOperation][],\n  onEdit: (todo: Todo, operation: TodoOperation) => (state: Partial<Mutable>) => void;\n  onSave: (todo: Todo, operation: TodoOperation) => (state?: Partial<Mutable>) => void;\n  new: NewTodoOperation;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n};\n\nexport const List = (props: PropsList) => {\n  console.log('new', props.new.status)\n  const newTodo = props.new;\n\n  const onChangeNew = isOk(newTodo)\n    ? noop\n    : (evt: React.FormEvent<HTMLInputElement>) => {\n        props.onChangeNew(evt.currentTarget.value);\n      };\n\n  return (\n    <R.List className=\"todo-list\" twoLine>\n      <R.ListItem>\n        <R.ListItemGraphic\n          title={\"Mark all as complete.\"}\n          icon={{ icon: \"keyboard_arrow_down\", onClick: props.onCompleteAll }}\n          theme=\"secondary\"\n        />\n        {isPending(props.new) ? (\n          <>\n            <R.ListItemText>\n              <R.ListItemPrimaryText theme=\"secondary\">\n                {props.new.state}\n              </R.ListItemPrimaryText>\n              <R.ListItemSecondaryText style={{ fontStyle: \"italic \" }}>\n                ...busy\n              </R.ListItemSecondaryText>\n            </R.ListItemText>\n            <R.ListItemMeta\n              icon={\n                props.new.status == null ? (\n                  \"\"\n                ) : isPending(props.new) ? (\n                  <R.CircularProgress theme=\"secondary\" />\n                ) : isBad(props.new) ? (\n                  { icon: \"error\", theme: \"error\" }\n                ) : isOk(props.new) ? (\n                  { icon: \"check\", theme: \"primary\" }\n                ) : (\n                  \"\"\n                )\n              }\n            />\n          </>\n        ) : (\n          <R.TextField\n            fullwidth\n            theme=\"textPrimaryOnDark\"\n            placeholder=\"Where do you want to go today?\"\n            style={{ height: \"100%\" }}\n            onInput={onChangeNew}\n            value={props.new.state || ''}\n            onKeyUp={evt => evt.keyCode === 13 && props.onSubmitNew()}\n            autoFocus\n            trailingIcon={isBad(props.new) ? {icon: 'error', theme: 'error'} : undefined}\n          />\n        )}\n      </R.ListItem>\n      <R.ListDivider />\n      {renderList(props)}\n    </R.List>\n  );\n};\n","import { Subject, Observable, merge, of } from \"rxjs\";\nimport { startWith, tap, withLatestFrom, map, delay, publish } from \"rxjs/operators\";\nimport { FilterType } from \"../../apps/todo/types\";\nimport { Todo, TodoOperation } from \"../todo/types\";\nimport * as React from \"react\";\n\n// Types\ntype F<A, B> = (a: A) => B\n\ntype Tuple<A, B> = [A, B]\n\n// Array functions\nexport const take = (amount: number) => <T>(xs: T[]) => {\n  const txs: T[] = [];\n  const len = xs.length;\n\n  for (let i = 0; i < len && i < amount; i += 1) {\n    txs.push(xs[i]);\n  }\n\n  return txs;\n};\n\n// Tuple functions\n\n/**\n * Returns the first element in a tuple.\n *\n * first :: ( (a, b) -> a)\n */\nexport const first = <A>([a]: [A, any] | readonly [A, any]) => a;\n\nexport const thirst = <A>([a]: [A, any, any] | readonly [A, any, any]) => a;\n/**\n * Returns the second element in a tuple.\n *\n * second :: ( (a, b) -> b)\n */\nexport const second = <B>([, b]: [any, B] | readonly [any, B]) => b;\n\nexport const threcond = <B>([, b]: [any, B, any] | readonly [any, B, any]) => b;\n\n/**\n * \n * @param a \n * @param b \n */\nexport const tuple = <A, B>(a: A, b: B): Tuple<A, B> => [a, b]\n\nexport const thruple = <A, B, C>(a: A, b: B, c: C): [A, B, C] => [a, b, c]\n\n/**\n * \n * @param f \n */\nexport const applyToSecond = <A, B>(f: F<A, B>) => <T>(t: Tuple<T, A>): Tuple<T, B> => tuple(first(t), f(second(t)))\n\n// Compositors for observables\nexport const mapToAfterMs = <B>(to: B, ms: number = 1000) => <A>(from: A) =>\n  merge(of(from), of(to).pipe(delay(ms)));\n\nexport const toNullAfterMs = (ms = 1000) => mapToAfterMs(null, ms);\n\n\n\n// Assertion functions\nexport const isNotNull = <T>(value: T | null): value is T => value != null;\n\nexport const makeIsFilterType = <T extends FilterType>(of: T) => (\n  filterType: FilterType\n): filterType is T => filterType === of;\n\nexport const isFilterTypeAll = makeIsFilterType(FilterType.All);\nexport const isFilterTypeCompleted = makeIsFilterType(FilterType.Completed);\nexport const isFilterTypeActive = makeIsFilterType(FilterType.Active);\n\n// Filter functions\nexport const makeFilterTodosByFilterType = <T extends FilterType>(\n  filterType: FilterType\n) => (todos: [Todo, TodoOperation][]) =>\n  filterType === FilterType.All\n    ? todos\n    : todos.filter(\n        ([todo]) =>\n          (isFilterTypeCompleted(filterType) && todo.completed) ||\n          (isFilterTypeActive(filterType) && !todo.completed)\n      );\n\nexport const filterCompletedTodos = makeFilterTodosByFilterType(\n  FilterType.Completed\n);\nexport const filterActiveTodos = makeFilterTodosByFilterType(\n  FilterType.Active\n);\n\n// Function functions\n\nexport const once = <A, B>(f: (a: A) => B) => {\n  let output: B | undefined;\n\n  return (a: A) => {\n    if (!output) {\n      output = f(a);\n    }\n\n    return output;\n  };\n};\n/**\n * Identify function\n *\n * identity :: a -> a\n */\nexport const identity = <T>(value: T) => {\n  return value;\n};\n\n/**\n * Function composition. f after g. g andThen f\n *\n * compose :: (b -> c) -> (a -> b) -> c\n */\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) =>\n  f(g(a));\n\n/**\n * \n * @param f \n */\nexport const flip = <A, B, C>(f: (a: A, b: B) => C) => (b: B, a: A) => f(a, b)\n\n/**\n * \n * @param f \n */\nexport const curry = <A, B, C>(f: (a: A, b: B) => C) => (a: A) => (b: B) => f(a, b)\n\n/**\n * Don't ask. I was experimenting with point-free. Basically:\n * - We get (a, b)\n * - Then apply f((a, b)) wich gives use (a -> c)\n * - and so we apply a to that to return c\n *\n *  fromAandBToC :: ( (a, b) -> a -> c) -> (a, b) -> c\n */\nexport const fromAandBToC = <A, B, C>(f: (ab: [A, B]) => (a: A) => C) => (\n  ab: [A, B]\n) => f(ab)(first(ab));\n\n// Selectors\nexport const selectTodoFilter = (filterType: FilterType) =>\n  isFilterTypeActive(filterType)\n    ? filterActiveTodos\n    : isFilterTypeCompleted(filterType)\n    ? filterCompletedTodos\n    : identity;\n","import * as React from \"react\";\nimport { Todo, Status, TodoOperation, NewTodoOperation, Mutable } from \"../../modules/todo/types\";\nimport { List } from \"./components/List\";\nimport { FilterType } from \"./types\";\nimport {\n  isFilterTypeAll,\n  isFilterTypeActive,\n  isFilterTypeCompleted\n} from \"../../modules/utils\";\n\nimport * as R from \"rmwc\";\n\nexport interface PropsTodo {\n  todos: [Todo, TodoOperation][];\n  filterType: FilterType;\n  new: Exclude<NewTodoOperation, { status: Status.Ok }>;\n  onChangeFilterType: (filterType: FilterType) => void;\n  onEdit: (todo: Todo, operation: TodoOperation) => (state: Partial<Mutable>) => void;\n  onSave: (todo: Todo, operation: TodoOperation) => (state?: Partial<Mutable>) => void;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n  onClearComplete: () => void;\n}\n\nexport default (props: PropsTodo) => {\n  // console.log(JSON.stringify(props, null, 2))\n  const list = (\n    <List\n      todos={props.todos}\n      onEdit={props.onEdit}\n      onSave={props.onSave}\n      onChangeNew={props.onChangeNew}\n      new={props.new}\n      onSubmitNew={props.onSubmitNew}\n      onCompleteAll={props.onCompleteAll}\n    />\n  );\n\n  return (\n    <>\n      <div style={{ textAlign: \"center\", marginTop: 15}}>\n        <R.Typography use=\"headline1\" theme=\"secondary\">\n          todos\n        </R.Typography>\n      </div>\n      <section className=\"todoapp\">\n        <section className=\"main\">{list}</section>\n        <footer className=\"footer\" style={{ textAlign: \"center\" }}>\n          <R.ChipSet choice style={{ justifyContent: \"center\" }}>\n            <R.Chip\n              label=\"All\"\n              theme={\n                isFilterTypeAll(props.filterType) ? \"secondaryBg\" : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.All)}\n            />\n            <R.Chip\n              label=\"Active\"\n              icon=\"radio_button_unchecked\"\n              theme={\n                isFilterTypeActive(props.filterType) ? \"secondaryBg\" : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.Active)}\n            />\n            <R.Chip\n              label=\"Completed\"\n              icon=\"check_circle_outline\"\n              theme={\n                isFilterTypeCompleted(props.filterType)\n                  ? \"secondaryBg\"\n                  : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.Completed)}\n            />\n          </R.ChipSet>\n\n          <div>\n            <R.Button onClick={props.onClearComplete}>Clear completed</R.Button>\n          </div>\n          <R.Typography use=\"caption\" style={{color: '#999  '}}>\n            <strong>\n              {props.todos.filter(([todo]) => !todo.completed).length}\n            </strong>{\" \"}\n            item left\n          </R.Typography>\n        </footer>\n      </section>\n    </>\n  );\n};\n","import { Observable, Subject, concat, of } from \"rxjs\";\nimport { identity, second } from \"../utils\";\nimport { startWith, share, withLatestFrom, map, delay } from \"rxjs/operators\";\n\n/**\n * Similar to the what React's `useState` hook returns but for observables.\n */\nexport type StateObservable<T> = readonly [Observable<T>, (next: T) => void, T];\n\n/**\n * Either [[StateObservable]] or [[Observable]]\n */\nexport type ObservableLike<T> = StateObservable<T> | Observable<T>;\n\n/**\n * Determines if the given observable like value is a [[StateObservable]]\n */\nexport const isStateObservable = <T>(\n  observable$: ObservableLike<T>\n): observable$ is StateObservable<T> => Array.isArray(observable$);\n\n/**\n * \n * @param initialState Initial state of the [[Subject]]\n * @param piper Callback for adding \"pipes\" aka operators to the subject's output.\n */\nexport const stateOf = <T>(\n  initialState: T,\n  piper: (o$: Observable<T>) => Observable<T> = identity\n): StateObservable<T> => {\n  // Create a new subject that will stream the state\n  const subject = new Subject<T>();\n\n  let nextState = initialState\n  const setState = (state: T) => {\n    // debugger\n    nextState = state\n    subject.next(state);\n  };\n\n  const nextState$ = of(void 0).pipe(\n    map(() => nextState)\n  )\n\n  const piped$ = piper(subject.asObservable())\n\n  // const initialState$ = piped$  \n\n  return [\n    concat(nextState$, piped$),\n    setState,\n    initialState\n  ] as const;\n};\n","import { URL } from \"./constants\";\n\nimport {\n  Ok,\n  Bad,\n  Status,\n  Pending,\n  Todo,\n  Noop,\n  Mutable,\n  TodoOperation,\n  EventType\n} from \"./types\";\n\nimport { take } from \"../utils\";\n\n/**\n * Mock database\n */\nlet todos: Todo[] = [];\n\nconst failPattern = [true, false, false, true, true, false, true]\nlet failIndex = 0\n\nconst getNextFailFlag = () => {\n  failIndex += 1\n\n  if (failIndex > failPattern.length - 1) {\n    failIndex = 0\n  }\n\n  return failPattern[failIndex]\n}\n\nconst delay = (ms: number) =>\n  new Promise<void>(resolve => setTimeout(resolve, ms));\n\n/**\n * \n */\nexport const read = async () => {\n  const doFail = getNextFailFlag()\n\n  if (todos.length <= 0) {\n    const response = await fetch(URL);\n    const json: Todo[] = await response.json();\n    await delay(1500);\n    todos = take(25)(json).map(todo => ({...todo, completed: false}));\n  } else {\n    await delay(1000);\n  }\n  return todos\n};\n\n/**\n * \n * @param operation \n */\nexport const create = async (\n  operation: Pending<string>\n): Promise<Ok<Todo> | Bad<string>> => {\n  const doFail = getNextFailFlag()\n\n  await delay(1500);\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state\n    };\n  }\n\n  if (!operation.state) {\n    return {\n      status: Status.Bad,\n      error: \"A title is required!\",\n      state: operation.state\n    };\n  }\n\n  const todo = {\n    id: Math.floor(Math.random() * 10000),\n    userId: Math.floor(Math.random() * 10000),\n    title: operation.state,\n    completed: false\n  };\n\n  todos = [...todos, todo];\n\n  return {\n    status: Status.Ok,\n    state: todo\n  };\n};\n\nexport const update = async (\n  todo: Todo,\n  operation: Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Save> | Bad<Mutable, EventType.Save>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag()\n  \n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state,\n      action: EventType.Save\n    };\n  }\n\n  const title = operation.state.title.trim();\n\n  if (!title) {\n    return {\n      status: Status.Bad,\n      action: EventType.Save,\n      error: \"A title is required!\",\n      state: {\n        ...operation.state,\n        title\n      }\n    };\n  }\n\n  const nextTodo = {\n    ...todo,\n    ...operation.state,\n    title\n  };\n\n  todos = todos.map(current => {\n    if (current.id === nextTodo.id) {\n      return nextTodo;\n    }\n\n    return todo;\n  });\n\n  return {\n    status: Status.Ok,\n    state: { ...todo, ...operation.state, title },\n    action: EventType.Save\n  };\n};\n\nexport const deleet = async (\n  todo: Todo,\n  operation: Pending<Mutable, EventType.Delete>, //Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Delete> | Bad<Mutable, EventType.Delete>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag()\n  \n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Unable to delete!\",\n      state: operation.state,\n      action: EventType.Delete\n    };\n  }\n\n  todos = todos.filter(current => current.id !== todo.id)\n\n  return {\n    status: Status.Ok,\n    state: todo,\n    action: EventType.Delete\n  };\n};\n","export const URL = 'https://jsonplaceholder.typicode.com/todos/'\n\n","import {\n  EventType,\n  FetchEvent,\n  TodoEvent,\n  SaveEvent,\n  DeleteEvent,\n  TodoOperation,\n  EditEvent,\n  Todo,\n  Noop,\n  Bad,\n  OperationalEventTypes\n} from \"./types\";\n\n/**\n * makeFetchEvent\n */\nexport const makeFetchEvent = (): FetchEvent => {\n  return { type: EventType.Fetch };\n};\n\n/**\n * makeEditEvent\n */\n\nexport const makeEditEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): EditEvent => {\n  return { type: EventType.Edit, todo, operation };\n};\n\n/**\n * makeSaveEvent\n */\nexport const makeSaveEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): SaveEvent => {\n  return { type: EventType.Save, todo, operation };\n};\n\n/**\n * makeDeleteEvent\n */\nexport const makeDeleteEvent = (id: number): DeleteEvent => {\n  return { type: EventType.Delete, id };\n};\n\n/**\n * makeIsEventType\n */\nexport const makeIsEventType = <T extends EventType>(of: T) => (\n  eventType: EventType\n): eventType is T => eventType === of;\n\n/**\n * isFetchEventType\n */\nexport const isFetchEventType = makeIsEventType(EventType.Fetch);\n\n/**\n * isEditEventType\n */\nexport const isEditEventType = makeIsEventType(EventType.Edit);\n\n/**\n * isSaveEventType\n */\nexport const isSaveEventType = makeIsEventType(EventType.Save);\n\n/**\n * isDeleteEventType\n */\nexport const isDeleteEventType = makeIsEventType(EventType.Delete);\n\n/**\n * makeIsEventOfType\n */\nexport const makeIsEventOfType = <A extends EventType>(\n  f: (eventType: EventType) => eventType is A\n) => (event: TodoEvent): event is Extract<TodoEvent, { type: A }> =>\n  f(event.type);\n\n/**\n * isFetchEvent\n */\nexport const isFetchEvent = makeIsEventOfType(isFetchEventType);\n\n/**\n * isEditEvent\n */\nexport const isEditEvent = makeIsEventOfType(isEditEventType);\n\n/**\n * isSaveEvent\n */\nexport const isSaveEvent = makeIsEventOfType(isSaveEventType);\n\n/**\n * isDeleteEvent\n */\nexport const isDeleteEvent = makeIsEventOfType(isDeleteEventType);\n","import { Subject, from, of, EMPTY, concat } from \"rxjs\";\n\nimport {\n  tap,\n  map,\n  mergeMap,\n  share,\n  withLatestFrom,\n  mapTo,\n  switchMap,\n  groupBy,\n  timeoutWith,\n  ignoreElements,\n  startWith,\n  delay,\n  filter\n} from \"rxjs/operators\";\n\nimport { get, set } from \"../utils/getset\";\n\nimport { stateOf } from \"../rxjs-state\";\nimport { read, create, update, deleet } from \"./api\";\nimport {\n  TodoEvent,\n  Todo,\n  NewTodoOperation,\n  Status,\n  TodoOperation,\n  EventType,\n  SaveEvent,\n  EditEvent,\n  Operation,\n  Noop,\n  OperationalEventTypes,\n  Bad,\n  Mutable,\n  Pending\n} from \"./types\";\nimport {\n  isFetchEvent,\n  isEditEvent,\n  isSaveEvent,\n  isDeleteEvent\n} from \"./events\";\n\nimport {\n  tuple,\n  first,\n  second,\n  compose,\n  curry,\n  thruple,\n  threcond,\n  thirst\n} from \"../utils\";\nimport { makeNoop, isPending, isBad, isOk, toPending, isNoop } from \"./utils\";\n\n/**\n * Event stream\n */\nexport const events$ = new Subject<TodoEvent>();\n\n/**\n * Helper function for dispatching to the event stream.\n */\nexport const dispatch = (event: TodoEvent) => {\n  events$.next(event);\n};\n\ntype TodoWithOperation = [Todo, TodoOperation];\n/**\n * Fetches and streams ToDos\n */\nexport const [todos$, storeTodos] = stateOf<TodoWithOperation[]>([]);\n\n/**\n *\n */\nconst readTodos$ = () =>\n  from(read()).pipe(\n    withLatestFrom(todos$),\n    map(([next, current]) => {\n      // TODO Filter out incoming todos that have matching ids with todos in state\n      const additional: TodoWithOperation[] = [\n        ...current,\n        ...next.map(todo => {\n          const noopOperation = makeNoop({\n            title: todo.title,\n            completed: todo.completed\n          });\n\n          return tuple(todo, noopOperation);\n        })\n      ];\n\n      return additional;\n    }),\n    tap(storeTodos)\n  );\n\n/**\n *\n * @param event\n */\nconst makeEditEvent$ = (event: EditEvent) =>\n  of(void 0).pipe(\n    withLatestFrom(todos$),\n    map(second),\n    map(todos => {\n      const index = todos.findIndex(([todo]) => todo.id === event.todo.id);\n      const nextTodos = [...todos];\n      nextTodos.splice(index, 1, [event.todo, event.operation]);\n      return nextTodos;\n    }),\n    tap(storeTodos),\n    map(nextTodos => tuple(event, nextTodos))\n  );\n\ntype TodoId = number;\n\n/**\n * Operator compositor for dispatching a single updated todo to state\n * @param get - Callback function that given stream S returns a tuple of a [[Todo]] or [[TodoId]] and [[TodoOperation]]\n */\nconst storeTodo = <S, O extends TodoOperation, T extends TodoId | Todo>(\n  get: (stream: S) => [Todo | TodoId, O]\n) =>\n  mergeMap((stream: S) =>\n    of(stream).pipe(\n      // Combine the stream with the most recent state of the list of todos\n      withLatestFrom(todos$),\n      map(([stream, todos]) => {\n        const [todoOrId, todoOperation] = get(stream);\n\n        // Find the index of the operated todo in state\n        const index = todos.findIndex(\n          ([current]) =>\n            current.id ===\n            (typeof todoOrId === \"number\" ? todoOrId : todoOrId.id)\n        );\n\n        if (index >= 0) {\n          // Update state with data from the operated todo\n          const nextTodos = [...todos];\n          nextTodos.splice(index, 1, [\n            typeof todoOrId === \"number\" ? todos[index][0] : todoOrId,\n            todoOperation\n          ]);\n\n          return thruple(todoOperation, nextTodos, todoOrId);\n        }\n\n        return thruple(todoOperation, todos, todoOrId);\n      }),\n      tap(\n        compose(\n          storeTodos,\n          threcond\n        )\n      )\n    )\n  );\n\n/**\n *\n * @param event\n */\nconst makeSaveEvent$ = (event: SaveEvent) =>\n  concat(\n    // Update state for this todo to status \"Pending\"\n    of(toPending(event.operation, EventType.Save)).pipe(\n      storeTodo(stream => tuple(event.todo, stream)),\n      map(data => threcond(data)),\n      map(data => curry(tuple)(event)(data))\n    ),\n    // Continue with updating the the todo on the server\n    from(update(event.todo, event.operation)).pipe(\n      storeTodo(stream => {\n        // const foo = isOk(stream)\n        //   ? tuple(stream.state, stream)\n        //   : tuple(event.todo, stream);\n        return tuple(isOk(stream) ? stream.state : event.todo, stream);\n        // return [event.todo, stream];\n      }),\n      map(thirst),\n      // or 5000 if the operation was Bad\n      // Delay the stream by 750ms if the operation was Ok\n      mergeMap(stream => of(stream).pipe(delay(isOk(stream) ? 750 : 5000))),\n\n      // Reset the todo in state to status \"Noop\"\n      storeTodo(stream => tuple(event.todo.id, makeNoop(stream.state))),\n      map(nextTodos => tuple(event, nextTodos))\n    )\n  );\n\n/**\n *\n */\nexport const handleEvents$ = events$.pipe(\n  groupBy(\n    event => {\n      if (isFetchEvent(event)) {\n        return EventType.Fetch;\n      } else if (isEditEvent(event) || isSaveEvent(event)) {\n        return event.todo.id;\n      } else if (isDeleteEvent(event)) {\n        return event.id;\n      }\n    },\n    event => event,\n    actionsByGroup$ =>\n      actionsByGroup$.pipe(\n        timeoutWith(15000, EMPTY),\n        ignoreElements()\n      )\n  ),\n  mergeMap(groupedEvent$ =>\n    groupedEvent$.pipe(\n      switchMap(event => {\n        if (isFetchEvent(event)) {\n          return readTodos$().pipe(map(todos => tuple(event, todos)));\n        } else if (isEditEvent(event)) {\n          return makeEditEvent$(event);\n        } else if (isSaveEvent(event)) {\n          return makeSaveEvent$(event);\n        }\n\n        const getId = get(\"id\");\n\n        return of(void 0).pipe(\n          withLatestFrom(todos$),\n          map(second),\n          map(todos => todos.find(item => getId(first(item)) === getId(event))),\n          mergeMap(maybeTodo =>\n            maybeTodo\n              ? of(maybeTodo).pipe(\n                  filter(\n                    (\n                      data\n                    ): data is [\n                      Todo,\n                      Extract<\n                        TodoOperation,\n                        { status: Status.Noop | Status.Bad }\n                      >\n                    ] => isNoop(second(data)) || isBad(second(data))\n                  ),\n                  // I wish TypeScript had better type inference\n                  // storeTodo(applyToSecond(curry(flip(toPendingWithAction))(EventType.Delete))),\n                  storeTodo(([todo, operation]) =>\n                    tuple(todo, toPending(operation, EventType.Delete))\n                  ),\n                  mergeMap(([pendingOperation, _, todo]) =>\n                    from(\n                      deleet(\n                        todo as Todo,\n                        pendingOperation as Pending<Mutable, EventType.Delete>\n                      )\n                    ).pipe(\n                      mergeMap(\n                        stream => {\n                          if (isOk((stream))) {\n                            return of(void 0).pipe(\n                              withLatestFrom(todos$),\n                              map(second),\n                              tap(todos => storeTodos(todos.filter(([todo]) => todo.id !== stream.state.id)))\n                            )\n                          }\n\n                          return of(void 0).pipe(\n                            storeTodo(\n                              () => [first(maybeTodo), stream] \n                            )\n                          )\n                        }\n                      )\n                    )\n                  )\n                )\n              : of(tuple(event, undefined))\n          )\n        );\n      })\n    )\n  )\n);\n\n/**\n * Event stream filtered by type FETCH\n */\nexport const eventsHandler$ = handleEvents$;\n\n/**\n *\n */\nexport const newTodoOperation$ = stateOf<NewTodoOperation>(\n  {\n    status: Status.Noop,\n    state: \"\"\n  },\n  state$ =>\n    state$.pipe(\n      switchMap(state =>\n        isPending(state)\n          ? from(create(state)).pipe(\n              withLatestFrom(todos$),\n              tap(([nextState, todos]) => {\n                if (isOk(nextState))\n                  storeTodos([\n                    ...todos,\n                    tuple(nextState.state, makeNoop(nextState.state))\n                  ]);\n              }),\n              map(first),\n              map(nextState => (isBad(nextState) ? nextState : makeNoop(\"\"))),\n              startWith(state)\n            )\n          : of(state)\n      ),\n      share()\n    )\n);\n","export function get<K extends string>(prop: K) {\n  function getter<T extends { [P in K]?: any }>(object: T): T[typeof prop]\n  function getter<T extends { [P in K]: any }>(object: T) {\n    return object[prop]\n  }\n\n  return getter\n}\n\nexport function set<K extends string>(prop: K) {\n  function setter<T extends { [P in K]?: any }>(object: T, value: T[typeof prop]): T\n  function setter<T extends { [P in K]: any }>(object: T, value: T[typeof prop]): T {\n    return Object.assign(object, {\n      [prop]: value\n    })\n  }\n\n  return setter\n}\n\nexport interface GetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T): T[K]\n  <T extends { [P in K]: any }>(object: T): T[K]\n}\n\nexport interface SetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T, value: T[K]): T\n  <T extends { [P in K]: any }>(object: T, value: T[K]): T\n}\n    \n// Examples\n/*\ninterface User {\n    id: number,\n    username: string,\n}\n\ntype NewUser = Partial<User>\n    \nexport const getUserId = composeGetter('id')\n\ntype UsernameGetter = GetProperty<'username'>\nconst getUsername: UsernameGetter = composeGetter('username')\n\ndeclare const user: User\ndeclare const newUser: NewUser\n    \nconst userId = getUserId(user) // :number\nconst userUsername = getUsername(user) // :number | undefined\n\nconst newUserId = getUserId(newUser) // :number | undefined\nconst newUserUsername = getUsername(newUser) // :string | undefined\n\nconst nextUser = composeSetter('username')(newUser, 'foobar')\nconst nextUserUsername = nextUser.username // :string | undefined\n*/","import {\n  second,\n  selectTodoFilter,\n  compose,\n  fromAandBToC\n} from \"../../modules/utils\";\n\nimport { stateOf } from \"../../modules/rxjs-state\";\n\nimport { todos$} from \"../../modules/todo/observables\";\n\nimport { FilterType } from \"./types\";\nimport { map, filter } from \"rxjs/operators\";\nimport { combineLatest } from \"rxjs\";\n\nexport const filterTypeState$ = stateOf(FilterType.All);\n\nexport const todosByFilterType$ = combineLatest(\n  todos$,\n  filterTypeState$[0]\n).pipe(\n  map(\n    ([todos, filterType]) => selectTodoFilter(filterType)(todos)\n    // fromAandBToC(\n    //   compose(\n    //     selectTodoFilter,\n    //     second\n    //   )\n    )\n);\n","import React from \"react\";\n\nimport TodoApp from \"./apps/todo/Todo\";\nimport { Slider } from \"rmwc\";\n\nimport {\n  dispatch,\n  newTodoOperation$,\n  eventsHandler$\n} from \"./modules/todo/observables\";\n\nimport { tap, filter } from \"rxjs/operators\";\n\nimport { filterTypeState$, todosByFilterType$ } from \"./apps/todo/observables\";\nimport { createState, makeTimeTravelable } from \"./modules/rxjs-state\";\n\nimport { Observable, noop } from \"rxjs\";\nimport {\n  makeFetchEvent,\n  makeSaveEvent,\n  makeEditEvent,\n  makeDeleteEvent\n} from \"./modules/todo/events\";\nimport {\n  makeNoop,\n  toPending,\n  isPending,\n  isOk,\n  isBad,\n  isNoop\n} from \"./modules/todo/utils\";\nimport { TodoOperation, Todo, Mutable, Noop } from \"./modules/todo/types\";\nimport { FilterType } from \"./apps/todo/types\";\nimport { compose, first, second, tuple } from \"./modules/utils\";\n\nconst state$ = createState({\n  todos: todosByFilterType$,\n  filterType: filterTypeState$,\n  new: newTodoOperation$\n});\n\nconst [timeTravelableState$, setIndex, index$] = makeTimeTravelable(state$);\n\ntype Observed<T> = T extends Observable<infer S> ? S : never;\n\ntype State = Observed<typeof state$>;\n\nconst App = () => {\n  console.log(\"Render App\");\n  const [state, setState] = React.useState<State>();\n\n  const [[index, max], setIndexState] = React.useState([\n    -1 as number,\n    0 as number\n  ] as const);\n\n  React.useEffect(() => {\n    // const todosSubscription = todosByFilterType$.pipe(tap(setTodos)).subscribe()\n\n    const eventsHandlerSubscription = eventsHandler$.subscribe();\n\n    const indexSubscription = index$\n      .pipe(tap(next => setIndexState(next)))\n      .subscribe();\n\n    const stateSubscription = timeTravelableState$\n      .pipe(\n        tap(setState),\n        tap(state => Object.assign(window, { state }))\n      )\n      .subscribe();\n\n    dispatch(makeFetchEvent());\n\n    return () => {\n      eventsHandlerSubscription.unsubscribe();\n      indexSubscription.unsubscribe();\n      indexSubscription.unsubscribe();\n    };\n  }, []);\n\n  if (state) {\n    const onChangeFilterType = (filterType: FilterType) => {\n      state.filterType = filterType;\n    };\n\n    const onChangeNew = (title: string) => {\n      state.new = makeNoop(title);\n    };\n\n    const onSubmitNew = () => {\n      if (!isPending(state.new)) state.new = toPending(state.new);\n    };\n\n    const onEdit = (todo: Todo, operation: TodoOperation) => (\n      state: Partial<Pick<Todo, \"completed\" | \"title\">>\n    ) => {\n      if (isNoop(operation) || isBad(operation)) {\n        dispatch(\n          makeEditEvent(todo, {\n            ...operation,\n            state: {\n              ...operation.state,\n              ...state\n            }\n          })\n        );\n      }\n    };\n\n    const onSave = (todo: Todo, operation: TodoOperation) => (\n      state: Partial<Pick<Todo, \"completed\" | \"title\">> = {}\n    ) => {\n      if (isNoop(operation) || isBad(operation)) {\n        dispatch(\n          makeSaveEvent(todo, {\n            ...operation,\n            state: {\n              ...operation.state,\n              ...state\n            }\n          })\n        );\n      }\n    };\n\n    const isComplete = (todo: Todo) => todo.completed === true;\n    \n    const onCompleteAll = () =>\n      state.todos\n        .filter(\n          compose(\n            a => !a,\n            compose(\n              isComplete,\n              first\n            )\n          )\n        )\n        .filter(\n          (todo): todo is [Todo, Noop<Mutable>] =>\n            isNoop(second(todo)) || isBad(second(todo))\n        )\n        .map(todo =>\n          tuple(first(todo), {\n            ...second(todo),\n            state: { ...second(todo).state, completed: true }\n          })\n        )\n        .forEach(todo => dispatch(makeSaveEvent(...todo)));\n\n    const onClearComplete = () => {\n      state.todos\n        .filter(\n          compose(\n            isComplete,\n            first\n          )\n        )\n        .filter(\n          (todo): todo is [Todo, Noop<Mutable>] =>\n            isNoop(second(todo)) || isBad(second(todo))\n        )\n        .forEach(([todo]) => dispatch(makeDeleteEvent(todo.id)));\n    };\n\n    return (\n      <>\n        <div>\n          <div className=\"todomvc\">\n            <TodoApp\n              todos={state.todos}\n              new={state.new}\n              onChangeFilterType={index >= 0 ? noop : onChangeFilterType}\n              onChangeNew={index >= 0 ? noop : onChangeNew}\n              onSubmitNew={index >= 0 ? noop : onSubmitNew}\n              filterType={state.filterType}\n              onEdit={index >= 0 ? () => noop : onEdit}\n              onSave={index >= 0 ? () => noop : onSave}\n              onCompleteAll={index >= 0 ? noop : onCompleteAll}\n              onClearComplete={index >= 0 ? noop : onClearComplete}\n            />\n          </div>\n        </div>\n        <div>\n          <div style={{ padding: 15 }}>\n            <Slider\n              value={index < 0 ? max : max - index - 1}\n              // onChange={evt => setIndex(evt.detail.value)}\n              onInput={evt => setIndex(max - evt.detail.value - 1)}\n              discrete\n              start={0}\n              max={max}\n              step={1}\n            />\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  return <div>Loading..</div>;\n};\n\nexport default App;\n","import { Observable, Subject, combineLatest } from \"rxjs\";\nimport { debounceTime, scan, startWith, map } from \"rxjs/operators\";\n\n/**\n * Turns an observable into a time travelable\n * version of itself.\n * \n * It does this by creating a Subject to sink/stream the selected\n * historic index.\n * \n * Then it it creates `stateWithHistory$` which is just using\n * the `scan` operator to keep track of all emitted values.\n * \n * A final `index$` observable is created that only emits\n * index values that are within the bounds of the history\n * array's length.\n * \n * A final `state$` observable is created by combining\n * `index$` and `stateWithHistory$` to either select state\n * from the history array or return the active, current state\n * if the index is `-1`\n * \n * The return value of this function is a thruple of:\n * 0: The final `state$` observable\n * 1: A dispatch function for setting the selected index\n * 2: The `index$` observable emitting both the index and the maximum\n */\nexport const makeTimeTravelable = <T>(observable$: Observable<T>) => {\n  const indexSubject = new Subject<number>();\n\n  const stateWithHistory$ = observable$.pipe(\n    // debounceTime(500),\n    scan(\n      ([state, history], next): readonly [T, T[]] =>\n        [next, state ? [...history, state] : []] as const,\n      [undefined, []] as readonly [T | undefined, T[]]\n    )\n  );\n\n  const index$ = combineLatest(\n    indexSubject.asObservable().pipe(startWith(-1)),\n    stateWithHistory$\n  ).pipe(\n    map(([index, [, history]]) => {\n      if (index < 0) {\n        return [-1, history.length] as const;\n      } else if (index > history.length - 1) {\n        return [history.length - 1, history.length] as const;\n      }\n\n      return [index, history.length] as const;\n    })\n  );\n\n  const state$ = combineLatest(index$, stateWithHistory$).pipe(\n    map(([[index, max], [state, history]]) =>\n      index > -1 && history[max - index - 1] != null ? history[max - index - 1] : state\n    )\n  );\n\n  const setIndex = (index: number) => indexSubject.next(index);\n\n  return [state$, setIndex, index$] as const;\n};\n","import { Observable, combineLatest } from \"rxjs\";\nimport { isStateObservable, StateObservable, ObservableLike } from \"./stateOf\";\nimport { map } from \"rxjs/operators\";\n\n/**\n * Returns a type describing all keys of object T\n * that are of type V\n */\ntype KeyOfType<T, V> = {\n  [P in keyof T]: T[P] extends V ? P : never;\n}[keyof T];\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they belong to keys in type K\n */\ntype ReadonlyByKey<T extends {}, K extends keyof T> = Readonly<Pick<T, K>> &\n  Omit<T, K>;\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they are of type V\n */\ntype ReadonlyByType<T, V> = ReadonlyByKey<T, KeyOfType<T, V>>;\n\n/**\n * An object representing a map of [[Observable]] or [[StateObserveable]]\n */\ntype MapOfObservables = {\n  [prop: string]: ObservableLike<any>;\n};\n\n/**\n * A type representing a map of values based on a map of\n * [[Observable]] or [[StateObservable]] and the values those\n * observable stream.\n *\n * For example\n *\n * ```ts\n * type Foo = MapOfStateFromMapOfObservables<{ bar: Observable<number>>, zax: StateObservable<string> }\n *\n * // equates to\n *\n * type Foo = { readonly bar: number, zax: string }\n * ```\n *\n */\ntype MapOfStateFromMapOfObservables<T> = {\n  [P in keyof T]: T[P] extends ObservableLike<infer B> ? B : never;\n};\n\n/**\n * State$ describes an [[Observable]] that emits a state object where\n * key/value pairs created by a sub [[Observable]] are immutable and\n * key/values streamed by a [[StateObservable]] are semi-mutuable in\n * the sense that you can change their value in an mutauble style as\n * a _setter_ has been defined for that key/value pair that will send\n * the assigned value to the StateObservable's [[Subject]]\n *\n */\nexport type State$<T extends MapOfObservables> = Observable<\n  MapOfStateFromMapOfObservables<ReadonlyByType<T, Observable<any>>>\n>;\n\n/**\n * Creates a single state observable from a map of [[ObservableLike]]\n */\nexport const createState = <T extends MapOfObservables>(\n  mapOfObservables: T\n): State$<T> => {\n  // Compile a list of keys that are part of the state object.\n  const keys = Object.keys(mapOfObservables);\n\n  // Reduce the list of keys to a list of observables where each observable\n  // is a thruple of the key, getter, and setter.\n  const observables$: Observable<\n    [string, () => any, () => void]\n  >[] = keys.reduce(\n    (acc, key) => {\n      const observable$ = mapOfObservables[key];\n\n      // If the observable is our custom StateObservable\n      if (isStateObservable(observable$)) {\n        // Destructure the StateObservable into it's actual observabble and dispatcher\n        const [state$, setState] = observable$;\n\n        // Map the state$ observable to a thruple of\n        // its key, getter, and setter\n        const nextState$ = state$.pipe(\n          map(state => {\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter\n              (nextState: any) => {\n                setState(nextState);\n              }\n            ];\n          })\n        );\n\n        // Add the composed state observable to the accumulator.\n        acc.push(nextState$);\n      }\n\n      // If the observable was just a regular observable\n      else {\n        const nextState$ = observable$.pipe(\n          map(state => {\n            // Map the state$ observable to a thruple of\n            // its key, getter, and setter\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter that will log an error message in dev mode\n              (value: any) => {\n                if (process.env.NODE_ENV === \"development\") {\n                  console.error(\n                    `Attempting to mutate state \"${key}\" with value \"${value}\" of state with properties ${keys.join(\n                      \", \"\n                    )}`\n                  );\n                }\n              }\n            ];\n          })\n        );\n\n        acc.push(nextState$);\n      }\n      return acc;\n    },\n    [] as any[]\n  );\n\n  // Combine the list of observables of [key, getter, setter]\n  // into a single state observable\n\n  type Key = string;\n  type Getter = () => any;\n  type Setter = () => void;\n\n  const state$ = combineLatest(...observables$).pipe(\n    map((states: [Key, Getter, Setter][]) =>\n      states.reduce(\n        (acc, [k, g, s]) => {\n          // Using Object.defineProperty to preserve the merging\n          // of getters and setters\n          Object.defineProperty(acc, k, {\n            get: g,\n            set: s\n          });\n\n          return acc;\n        },\n        {} as any\n      )\n    )\n  );\n\n  return state$;\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}