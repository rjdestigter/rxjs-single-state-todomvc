{"version":3,"sources":["modules/utils/getset.ts","modules/utils/index.ts","modules/utils/tuple.ts","modules/utils/array.ts","modules/utils/observable.ts","modules/utils/assert.ts","modules/utils/function.ts","modules/todo/types.ts","modules/operations/types.ts","modules/operations/utils.ts","apps/todo/components/Item.tsx","modules/filter-todo/types.ts","apps/todo/components/List.tsx","apps/todo/components/Title.tsx","modules/filter-todo/assert.ts","modules/transactions/types.ts","modules/filter-todo/filter.ts","modules/state/stateOf.ts","modules/transactions/utils.ts","modules/transactions/index.ts","modules/filter-todo/observable.ts","apps/todo/components/Filter.tsx","apps/todo/Todo.tsx","apps/state-replay/compontents/Controls.tsx","Loading.tsx","modules/todo/api.ts","modules/todo/constants.ts","modules/todo/events.ts","modules/todo/utils.ts","modules/todo/effects.ts","modules/todo/observables.ts","modules/state/transactionalStateOf.ts","modules/state/makeTimeTravelable.ts","apps/todo/state.ts","modules/state/createState.ts","apps/todo/observables.ts","modules/filter-todo/select.ts","modules/todo/assert.ts","apps/todo/select.ts","App.tsx","apps/todo/hooks.ts","serviceWorker.ts","index.tsx"],"names":["get","prop","object","set","value","Object","assign","first","second","tuple","a","b","thruple","c","arrayBimap","f","g","as","map","IS_TUPLE","isArray","dataIsTuple","data","Array","length","isNotNull","take","amount","xs","txs","len","i","push","once","output","identity","compose","EventType","Status","makeIsStatus","statusType","checkedStatus","statusTypeIsOk","Ok","statusTypeIsBad","Bad","statusTypeIsNoop","Noop","statusTypeIsPending","Pending","makeIsOperationOfStatus","operation","status","isOk","isBad","isNoop","isPending","makeNoop","state","toPending","action","FilterType","Item","props","title","todo","style","opacity","isDeleting","transition","icon","completed","theme","undefined","onClick","onSave","error","fontStyle","use","newTodo","new","onChangeNew","noop","evt","currentTarget","className","twoLine","onCompleteAll","fullwidth","placeholder","height","onChange","onKeyUp","keyCode","onSubmitNew","autoFocus","trailingIcon","todos","key","id","onEdit","Delete","renderList","textAlign","marginTop","TransactionType","makeIsFilterType","of","filterType","isFilterTypeAll","All","isFilterTypeCompleted","Completed","isFilterTypeActive","Active","makeFilterTodosByFilterType","filter","filterCompletedTodos","filterActiveTodos","stateOf","initialState","subject","BehaviorSubject","asObservable","next","getValue","makeTransactionMaker","type","payload","makeAddTransaction","Add","makeUpdateTransaction","Update","makeRemoveTransaction","Remove","add","transaction","concat","update","isEqual","t1","t2","forEach","record","index","findIndex","r","splice","remove","filterTypeState$","choice","justifyContent","label","onChangeFilterType","list","List","clearBtn","onClearComplete","filterChips","Filter","footer","color","Title","padding","onInput","setIndex","detail","discrete","start","max","step","disabled","pause","play","styles","flex","display","alignItems","size","failPattern","failIndex","getNextFailFlag","delay","ms","Promise","resolve","setTimeout","read","fetch","response","json","create","doFail","Math","floor","random","userId","Save","trim","nextTodo","current","deleet","makeSaveEvent","makeIsEventType","eventType","isFetchEventType","Fetch","isEditEventType","Edit","isSaveEventType","isDeleteEventType","makeIsEventOfType","event","isFetchEvent","isEditEvent","isSaveEvent","mutuableTodo","toMutable","setTitle","setCompleted","getCompleted","getTitle","makeWriteEffect","transactionMaker","writer","addEffect","updateEffect","remoteEffect","runSaveOutcomeEffect","outcome","events$","Subject","dispatch","console","warn","dispatchFetch","isTuple","initialTransaction","state$","setState","transactional$","pipe","scan","acc","transactionalStateOf","todo1","todo2","todos$","writeTodos","resetOkAndBadTodos","updateOrDeleteEventAndOperation$","tap","handleEvents$","groupBy","actionsByGroup$","timeoutWith","EMPTY","ignoreElements","mergeMap","groupedEvent$","switchMap","handleReadEvent","handleEditEvent","handleSaveEvent","handleDeleteEvent","from","promise","updateTransaction","eventsHandler$","_newTodoOperation$","setNewTodoOperation","getNewTodoOperation","newTodoOperation$","todoWithOperation","nextState","startWith","observable$","indexSubject","stateWithHistory$","combineLatest","history","nextIndex","Date","now","stream","share","playSubject","replay$","withLatestFrom","mode","s","timeline","merge","makeTimeTravelable","mapOfObservables","observables$","keys","reduce","isStateObservable","nextState$","process","_","states","k","defineProperty","log","createState","selectTodoFilter","timeTravelableState$","isComplete","makeOnEdit","makeEditEvent","makeOnSave","makeOnClearComplete","makeDeleteEvent","props$","isReplaying","makeOnChangeFilterType","makeOnChangeNew","makeOnSubmitNew","makeOnCompleteAll","App","React","setProps","propsSubscription","subscribe","eventsHandlerSubscription","stateSubscription","unsubscribe","useTodoProps","todoApp","Todo","controls","Controls","Loading","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.41ef7839.chunk.js","sourcesContent":["export function get<K extends string>(prop: K) {\n  // function getter<T extends { [P in K]?: T[K] }>(object: T): T[K]\n  function getter<T extends { [P in K]: T[K] }>(object: T): T[K] {\n    return object[prop]\n  }\n\n  return getter\n}\n\nexport function set<K extends string>(prop: K) {\n  // function setter<T extends { [P in K]?: T[K] }>(object: T): (value: T[K]) => T\n  function setter<T extends { [P in K]: T[K] }>(object: T): (value: T[K]) => T {\n    return function (value: T[K]): T {\n      return Object.assign(object, {\n        [prop]: value\n      })\n    }\n  }\n\n  return setter\n}\n\nexport interface GetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T): T[K]\n  <T extends { [P in K]: any }>(object: T): T[K]\n}\n\nexport interface SetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T, value: T[K]): T\n  <T extends { [P in K]: any }>(object: T, value: T[K]): T\n}\n    \n// Examples\n/*\ninterface User {\n    id: number,\n    username: string,\n}\n\ntype NewUser = Partial<User>\n    \nexport const getUserId = composeGetter('id')\n\ntype UsernameGetter = GetProperty<'username'>\nconst getUsername: UsernameGetter = composeGetter('username')\n\ndeclare const user: User\ndeclare const newUser: NewUser\n    \nconst userId = getUserId(user) // :number\nconst userUsername = getUsername(user) // :number | undefined\n\nconst newUserId = getUserId(newUser) // :number | undefined\nconst newUserUsername = getUsername(newUser) // :string | undefined\n\nconst nextUser = composeSetter('username')(newUser, 'foobar')\nconst nextUserUsername = nextUser.username // :string | undefined\n*/","/**\n * Don't ask. I was experimenting with point-free. Basically:\n * - We get (a, b)\n * - Then apply f((a, b)) wich gives use (a -> c)\n * - and so we apply a to that to return c\n *\n *  fromAandBToC :: ( (a, b) -> a -> c) -> (a, b) -> c\n */\nimport { first } from './tuple'\n\nexport const fromAandBToC = <A, B, C>(f: (ab: [A, B]) => (a: A) => C) => (\n  ab: [A, B]\n) => f(ab)(first(ab));\n\n\n\nexport * from './array'\nexport * from './observable'\nexport * from './tuple'\nexport * from './getset'\nexport * from './assert'\nexport * from './function'\nexport * from './types'","import { F } from './types'\n\nexport type Tuple<A, B> = [A, B]\n\nexport type Thruple<A, B, C> = [A, B, C]\n\n/**\n * first :: (a, b) -> a\n * \n * Returns the first element in a tuple.\n */\nexport const first = <A>([a]: [A, any] | readonly [A, any]) => a;\n\n/**\n * thirst :: (a, b, c) -> a\n * \n * Returns the first element in a thruple.\n */\nexport const thirst = <A>([a]: [A, any, any] | readonly [A, any, any]) => a;\n\n/**\n * Returns the second element in a tuple.\n *\n * second :: ( (a, b) -> b)\n */\nexport const second = <B>([, b]: [any, B] | readonly [any, B]) => b;\n\n/**\n * threcond :: (a, b, c) -> b\n * \n * Like [[second]]. But for thruples.\n */\nexport const threcond = <B>([, b]: [any, B, any] | readonly [any, B, any]) => b;\n\n/**\n * tuple :: a -> b -> (a, b)\n * \n * Create a tuple given two values.\n */\nexport const tuple = <A, B>(a: A, b: B): Tuple<A, B> => [a, b]\n\n/**\n * thruple :: a -> b -> c -> (a, b, c)\n * \n * Create a thruple given three values.\n */\nexport const thruple = <A, B, C>(a: A, b: B, c: C): [A, B, C] => [a, b, c]\n\n/**\n * applyToSecond :: (a -> b) -> (t, a) -> (t, b)\n * \n * There's gotta be an official name for this.\n * Applies function f to the second element in a tuple.\n * \n */\nexport const applyToSecond = <A, B>(f: F<A, B>) => <T>(t: Tuple<T, A>): Tuple<T, B> => tuple(first(t), f(second(t)))\n","import { tuple } from \"./tuple\";\n\ntype F<A, B> = (a: A) => B;\n\nexport const arrayMap = <A, B>(f: F<A, B>) => (as: A[]) => as.map(a => f(a));\n\n/**\n * arrayBimap :: (a -> t) -> (a -> u) -> [a] -> [(u, t)]\n * @param f\n */\nexport const arrayBimap = <A, T>(f: F<A, T>) => <U>(g: F<A, U>) => (as: A[]) =>\n  as.map(a => tuple(f(a), g(a)));\n\n/**\n * Value alias used to better clearly indicate when\n * passing `true` to `transactionalStateOf`'s third `isTuple` parameter.\n */\nexport const IS_TUPLE = true;\n\n/**\n * isArray :: boolean -> t | [t] -> boolean\n *\n * Wrapper around Array.isArray when working with tuple like data structures.\n *\n * @param dataIsTuple - Whether to conside tuple like data or not.\n */\nexport const isArray = (dataIsTuple: boolean) => <A>(\n  data: A | A[]\n): data is A[] =>\n  Array.isArray(data)\n    ? // Continue if data is an array\n      dataIsTuple && data.length > 0\n      ? // TRUE if we're checking for tuples, data has 1 or more elements, and the first element is also an array\n        // FALSE if we're checking for tuples, data has 1 or more elements, and the first element is **NOT** an array (aka data is a tuple)\n        Array.isArray(data[0])\n      : // TRUE if data has more than zero elements\n        true\n    : // FALSE if data is not an array to begin with\n      false;\n","import { of, concat } from 'rxjs'\nimport { delay } from 'rxjs/operators'\n\n/**\n * mapToAfterMs :: b -> number -> a -> Observable a | b\n * \n * @param to Value to emit first\n * @param ms Delay second value by number of milliseconds\n */\nexport const mapToAfterMs = <B>(to: B, ms: number = 1000) => <A>(from: A) =>\n  concat(of(from), of(to).pipe(delay(ms)));\n\n/**\n * toNullAfterMs :: number -> b -> Observable null | b\n * \n * @param ms Delay second value by number of milliseconds\n */\nexport const toNullAfterMs = (ms = 1000) => mapToAfterMs(null, ms);\n","/**\n * isNotNull :: a | null -> a asserted\n * \n * Filter nullable types from an array\n * \n * @param value The nullable value to be checked\n */\nexport const isNotNull = <T>(value: T | null): value is T => value != null;\n\n/**\n * take :: number -> [a] -> [a]\n * \n * Take a number of elements from a list.\n * \n * @param amount The number of elements to take.\n */\nexport const take = (amount: number) => <T>(xs: T[]) => {\n  const txs: T[] = [];\n  const len = xs.length;\n\n  for (let i = 0; i < len && i < amount; i += 1) {\n    txs.push(xs[i]);\n  }\n\n  return txs;\n};\n","/**\n * once :: (a -> b) -> (a -> b)\n * @param f \n */\nexport const once = <A, B>(f: (a: A) => B) => {\n  let output: B | undefined;\n\n  return (a: A) => {\n    if (!output) {\n      output = f(a);\n    }\n\n    return output;\n  };\n};\n\n/**\n * identity :: a -> a\n *\n * Identify function\n */\nexport const identity = <T>(value: T) => {\n  return value;\n};\n\n/**\n * compose :: (b -> c) -> (a -> b) -> c\n *\n * Function composition. f after g. g andThen f\n */\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) =>\n  f(g(a));\n\n/**\n * TODO\n * @param f \n */\nexport const flip = <A, B, C>(f: (a: A, b: B) => C) => (b: B, a: A) => f(a, b)\n\n\n/**\n * TODO\n * @param f \n */\nexport const curry = <A, B, C>(f: (a: A, b: B) => C) => (a: A) => (b: B) => f(a, b)\n","import { Operation, Noop, Bad } from \"../operations\";\n\n/**\n * Todo model\n */\nexport type Todo = {\n  readonly id: number;\n  readonly title: string;\n  // userId: number;\n  readonly completed: boolean;\n};\n\n/**\n * Type describing operational state for a new todo.\n */\nexport type NewTodoOperation = Operation<string, void>;\n\n/**\n * Type alias describing those parts of a todo that are user editable.\n */\nexport type MutableTodo = Pick<Todo, \"completed\" | \"title\">;\n\n/**\n * Union type of event types that are in use for operational state.\n */\nexport type OperationalEventTypes = EventType.Save | EventType.Delete;\n\n/**\n * Type describing operational data in relation to editing, saving, and or removing todos.\n */\nexport type TodoOperation = Operation<MutableTodo, Todo, OperationalEventTypes>;\n\n/**\n * Event types that are dispatched to thee events$ sink.\n */\nexport enum EventType {\n  Fetch = \"Fetch\",\n  Edit = \"Edit\",\n  Save = \"Save\",\n  Delete = \"Delete\"\n}\n\n/**\n * Event describing todo's should be requested from the server.\n */\nexport type FetchEvent = {\n  type: EventType.Fetch;\n};\n\n/**\n * Event indicating a change to a todo in state should be recorded.\n */\nexport type EditEvent = {\n  type: EventType.Edit;\n  operation: Noop<MutableTodo> | Bad<MutableTodo, OperationalEventTypes>;\n  todo: Todo;\n};\n\n/**\n * Event meant to trigger an API call for saving an event using the API\n */\nexport type SaveEvent = {\n  type: EventType.Save;\n  operation: Noop<MutableTodo> | Bad<MutableTodo, OperationalEventTypes>;\n  todo: Todo;\n};\n\n/**\n * Event indicating the user wants to delete an event from state and the database.\n */\nexport type DeleteEvent = {\n  type: EventType.Delete;\n  todo: Todo;\n};\n\n/**\n * Union type of all event tyeps.\n */\nexport type TodoEvent = FetchEvent | EditEvent | SaveEvent | DeleteEvent;\n\n/**\n * A tuple:\n * 1. [[Todo]]\n * 2. [[TodoOperation]]\n */\nexport type TodoWithOperation = [Todo, TodoOperation];\n","\nexport enum Status {\n  Noop = \"Noop\",\n  Pending = \"Pending\",\n  Ok = \"Ok\",\n  Bad = \"Bad\"\n}\n\nexport type Noop<T> = {\n  status: Status.Noop;\n  state: T;\n};\n\nexport type Pending<T, A = void> = {\n  status: Status.Pending;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Bad<T, A = void> = {\n  status: Status.Bad;\n  state: T;\n  error: string;\n} & (A extends void ? {} : { action: A });\n\nexport type Ok<T, A = void> = {\n  status: Status.Ok;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Operation<T, U = T, A = void> =\n  | Noop<T>\n  | Pending<T, A>\n  | Bad<T, A>\n  | (U extends void ? Noop<T> : Ok<U, A>);\n\n","import { Status, Noop, Pending, Bad } from './types'\n\n// Assertions\nconst makeIsStatus = <T extends Status>(statusType: T) => (\n  checkedStatus: Status\n): checkedStatus is T => statusType === checkedStatus;\n\nexport const statusTypeIsOk = makeIsStatus(Status.Ok);\nexport const statusTypeIsBad = makeIsStatus(Status.Bad);\nexport const statusTypeIsNoop = makeIsStatus(Status.Noop);\nexport const statusTypeIsPending = makeIsStatus(Status.Pending);\n\n// type Foo = <S, O extends Operation<S>, A extends O['status']>\n\nexport const makeIsOperationOfStatus = <S extends Status>(\n  f: (statusType: Status) => statusType is S\n) => <O extends { status: Status }>(\n  operation: O\n): operation is Extract<O, { status: S }> => f(operation.status);\n\nexport const isOk = makeIsOperationOfStatus(statusTypeIsOk);\nexport const isBad = makeIsOperationOfStatus(statusTypeIsBad);\nexport const isNoop = makeIsOperationOfStatus(statusTypeIsNoop);\nexport const isPending = makeIsOperationOfStatus(statusTypeIsPending);\n\nexport const makeNoop = <T>(state: T): Noop<T> => {\n  return {\n    status: Status.Noop,\n    state\n  };\n};\n\n// export const toPendingWithAction = <T, A, B extends A>(operation: Noop<T> | Bad<T, A>, action: B): Pending<T, B> => toPending(operation, action)\n\nexport function toPending<T>(operation: Noop<T> | Bad<T>): Pending<T>;\nexport function toPending<T, A>(\n  operation: Noop<T> | Bad<T, A>,\n  action: A\n): Pending<T, A>;\nexport function toPending<T, A>(\n  operation: Noop<T> | Bad<T, A>,\n  action?: A\n): Pending<T, any> {\n  if (action != null) {\n    return {\n      status: Status.Pending,\n      state: operation.state,\n      action\n    };\n  }\n\n  return {\n    status: Status.Pending,\n    state: operation.state\n  };\n}\n","import * as React from \"react\";\nimport { Todo, MutableTodo } from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\nimport {\n  Status,\n  statusTypeIsPending,\n  statusTypeIsBad,\n  statusTypeIsOk\n} from \"../../../modules/operations\";\nimport { Typography } from \"rmwc\";\n\nexport type PropsItem = {\n  todo: Todo;\n  status: Status;\n  error?: string;\n  onEdit: (state: Partial<MutableTodo>) => void;\n  onSave: (state?: Partial<MutableTodo>) => void;\n  isDeleting: boolean;\n};\n\nexport const Item = (props: PropsItem) => (\n  <>\n    <R.ListItem\n      title={props.todo.title}\n      style={{\n        opacity: props.isDeleting ? 0.5 : 1,\n        transition: \"opacity 0.2s ease-in-out\"\n      }}\n    >\n      <R.ListItemGraphic\n        icon={{\n          icon: props.todo.completed\n            ? \"check_circle_outline\"\n            : \"radio_button_unchecked\",\n          theme: props.todo.completed ? \"primary\" : undefined,\n          onClick: () => props.onSave({ completed: !props.todo.completed })\n        }}\n      />\n      <R.ListItemText>\n        <R.ListItemPrimaryText theme=\"secondary\">\n          {props.todo.title}\n        </R.ListItemPrimaryText>\n        <R.ListItemSecondaryText\n          theme={props.error ? \"error\" : undefined}\n          style={{ fontStyle: \"italic \" }}\n        >\n          {props.error ? (\n            props.error\n          ) : props.status && statusTypeIsPending(props.status) ? (\n            props.isDeleting ? (\n              \"...deleting\"\n            ) : (\n              \"...saving\"\n            )\n          ) : props.todo.completed ? (\n            <Typography theme=\"primary\" use=\"caption\">\n              You're a go-getter!\n            </Typography>\n          ) : (\n            <Typography use=\"caption\">Start working on it!</Typography>\n          )}\n        </R.ListItemSecondaryText>\n      </R.ListItemText>\n      <R.ListItemMeta\n        icon={\n          props.status == null ? (\n            \"\"\n          ) : statusTypeIsPending(props.status) ? (\n            <R.CircularProgress theme=\"secondary\" />\n          ) : statusTypeIsBad(props.status) ? (\n            { icon: \"error\", theme: \"error\" }\n          ) : statusTypeIsOk(props.status) ? (\n            { icon: \"check\", theme: \"primary\" }\n          ) : (\n            \"\"\n          )\n        }\n      />\n    </R.ListItem>\n    <R.ListDivider />\n  </>\n);\n","export enum FilterType {\n  All = \"All\",\n  Active = \"Active\",\n  Completed = \"Completed\"\n}\n","import * as React from \"react\";\n\nimport {\n  List,\n  ListItem,\n  ListItemGraphic,\n  ListItemPrimaryText,\n  ListItemSecondaryText,\n  ListItemMeta,\n  ListDivider,\n  ListItemText\n} from '@rmwc/list'\n\nimport {CircularProgress} from '@rmwc/circular-progress'\nimport {TextField} from '@rmwc/textfield'\n\nimport {\n  Todo,\n  TodoOperation,\n  NewTodoOperation,\n  MutableTodo,\n  EventType\n} from \"../../../modules/todo/types\";\n\nimport { Item } from \"./Item\";\nimport { isOk, isPending, isBad } from \"../../../modules/operations\";\nimport { noop } from \"rxjs\";\n\nexport const renderList = (props: PropsList) =>\n  props.todos.map(([todo, operation]) => {\n    return (\n      <Item\n        key={todo.id}\n        todo={todo}\n        onEdit={props.onEdit(todo, operation)}\n        onSave={props.onSave(todo, operation)}\n        status={operation && operation.status}\n        isDeleting={\n          isPending(operation) && operation.action === EventType.Delete\n        }\n        error={(operation && isBad(operation) && operation.error) || undefined}\n      />\n    );\n  });\n\nexport type PropsList = {\n  todos: [Todo, TodoOperation][];\n  onEdit: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state: Partial<MutableTodo>) => void;\n  onSave: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state?: Partial<MutableTodo>) => void;\n  new: NewTodoOperation;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n};\n\nexport default (props: PropsList) => {\n  const newTodo = props.new;\n\n  const onChangeNew = isOk(newTodo)\n    ? noop\n    : (evt: React.FormEvent<HTMLInputElement>) => {\n        props.onChangeNew(evt.currentTarget.value);\n      };\n\n  return (\n    <List className=\"todo-list\" twoLine>\n      <ListItem>\n        <ListItemGraphic\n          title={\"Mark all as complete.\"}\n          icon={{ icon: \"keyboard_arrow_down\", onClick: props.onCompleteAll }}\n          theme=\"secondary\"\n        />\n        {isPending(props.new) ? (\n          <>\n            <ListItemText>\n              <ListItemPrimaryText theme=\"secondary\">\n                {props.new.state}\n              </ListItemPrimaryText>\n              <ListItemSecondaryText style={{ fontStyle: \"italic \" }}>\n                ...busy\n              </ListItemSecondaryText>\n            </ListItemText>\n            <ListItemMeta\n              icon={\n                props.new.status == null ? (\n                  \"\"\n                ) : isPending(props.new) ? (\n                  <CircularProgress theme=\"secondary\" />\n                ) : isBad(props.new) ? (\n                  { icon: \"error\", theme: \"error\" }\n                ) : isOk(props.new) ? (\n                  { icon: \"check\", theme: \"primary\" }\n                ) : (\n                  \"\"\n                )\n              }\n            />\n          </>\n        ) : (\n          <TextField\n            fullwidth\n            theme=\"textPrimaryOnDark\"\n            placeholder=\"Where do you want to go today?\"\n            style={{ height: \"100%\" }}\n            onChange={onChangeNew}\n            value={props.new.state || \"\"}\n            onKeyUp={evt => evt.keyCode === 13 && props.onSubmitNew()}\n            autoFocus\n            trailingIcon={\n              isBad(props.new) ? { icon: \"error\", theme: \"error\" } : undefined\n            }\n          />\n        )}\n      </ListItem>\n      <ListDivider />\n      {renderList(props)}\n    </List>\n  );\n};\n","import * as React from \"react\";\nimport { Typography } from \"@rmwc/typography\";\n\nconst style: React.CSSProperties = { textAlign: \"center\", marginTop: 15 };\n\nexport default () => (\n  <div style={style}>\n    <Typography use=\"headline1\" theme=\"secondary\">\n      todos\n    </Typography>\n  </div>\n);\n","\nimport { FilterType } from './types'\n\nexport const makeIsFilterType = <T extends FilterType>(of: T) => (\n  filterType: FilterType\n): filterType is T => filterType === of;\n\n\n/**\n * TODO\n */\nexport const isFilterTypeAll = makeIsFilterType(FilterType.All);\n\n\n/**\n * TODO\n */\nexport const isFilterTypeCompleted = makeIsFilterType(FilterType.Completed);\n\n\n/**\n * TODO\n */\nexport const isFilterTypeActive = makeIsFilterType(FilterType.Active);\n\n","\n/**\n * Type of transaction you might apply to a dataset\n */\nexport enum TransactionType {\n  Update = \"Update\",\n  Remove = \"Remove\",\n  Add = \"Add\"\n}\n\n/**\n * A [[TransactionType]] combined with a payload.\n */\nexport type TransactionLike<T, P> = {\n  type: T;\n  payload: P;\n};\n\n/**\n * A transaction decribing the dataset should update an existing\n * piece of data with information in this transaction's payload.\n */\nexport type Update<T> = TransactionLike<TransactionType.Update, T>;\n\n/**\n * A transaction decribing the dataset should remove an existing\n * piece of data matching transaction's payload.\n */\nexport type Remove<T> = TransactionLike<TransactionType.Remove, T>;\n\n/**\n * A transaction decribing the dataset should add a new piece\n * of data that is this transaction's payload.\n */\nexport type Add<T> = TransactionLike<TransactionType.Add, T>;\n\n/**\n * An [[Add]], [[Update]], or [[Remomve]] transaction\n */\nexport type Transaction<A, U = A, R = A> = Add<A> | Update<U> | Remove<R>;\n\n/**\n * Type describing data used in transactions for data sets that are lists\n */\nexport type Transanctional<T> = T[] | T;\n","import { Todo, TodoOperation } from \"../todo\";\nimport { FilterType } from \"./types\";\nimport { isFilterTypeCompleted, isFilterTypeActive } from \"./assert\";\n\n/**\n * TODO\n */\nexport const makeFilterTodosByFilterType = <T extends FilterType>(\n  filterType: T\n) => (todos: [Todo, TodoOperation][]) =>\n  filterType === FilterType.All\n    ? todos\n    : todos.filter(\n        ([todo]) =>\n          (isFilterTypeCompleted(filterType) && todo.completed) ||\n          (isFilterTypeActive(filterType) && !todo.completed)\n      );\n\n/**\n * TODO\n */\nexport const filterCompletedTodos = makeFilterTodosByFilterType(\n  FilterType.Completed\n);\n\n/**\n * TODO\n */\nexport const filterActiveTodos = makeFilterTodosByFilterType(FilterType.Active);\n","import { Observable, BehaviorSubject } from \"rxjs\";\n\n/**\n * Similar to the what React's `useState` hook returns but for observables.\n */\nexport type StateObservable<T, U = T> = readonly [\n  Observable<U>,\n  (next: T) => void,\n  () => T\n];\n\n/**\n * Either [[StateObservable]] or [[Observable]]\n */\nexport type ObservableLike<T> = StateObservable<T> | Observable<T>;\n\n/**\n * Determines if the given observable like value is a [[StateObservable]]\n */\nexport const isStateObservable = <T>(\n  observable$: ObservableLike<T>\n): observable$ is StateObservable<T> => Array.isArray(observable$);\n\n/**\n * Create a stateful observable\n * \n * @param initialState Initial state of the observable (see [[BehaviourSubject]])\n */\nexport const stateOf = <T>(\n  initialState: T,\n): StateObservable<T> => {\n  // Create a new subject that will stream the state\n  const subject = new BehaviorSubject<T>(initialState);\n\n  // subject.subscribe(console.error)\n  const setState = (state: T) => {\n    subject.next(state);\n  };\n\n  const getCurrentState = () => subject.getValue();\n\n  return [\n    subject.asObservable(),\n    setState,\n    getCurrentState\n  ] as const;\n};\n","import { TransactionType } from './types'\n\n/**\n * makeTransactionMaker :: TransactionType -> a -> Add a\n * \n * Creates a function for creating transaction objects of a specific type.\n * It is a curried function combining transaction type and payload in to a transaction object.\n * \n * @param type The type of transaction\n */\nconst makeTransactionMaker = <T extends TransactionType>(type: T) => <P>(payload: P) => ({type, payload})\n\n\n/**\n * makeAddTransaction :: p -> Add p\n * \n * Creates an [[Add]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeAddTransaction = makeTransactionMaker(TransactionType.Add)\n\n/**\n * makeUpdateTransaction :: p -> Remove p\n * \n * Creates an [[Update]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeUpdateTransaction = makeTransactionMaker(TransactionType.Update)\n\n/**\n * makeRemoveTransaction :: p -> Remove p\n * \n * Creates an [[Remove]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeRemoveTransaction = makeTransactionMaker(TransactionType.Remove)","import { isArray } from \"../utils\";\n\nimport { TransactionLike, TransactionType } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\n/**\n * add :: (a -> a -> boolean) -> boolean - [a] -> Update a -> [a]\n *\n * Add data to state (a list of T) given the payload of an [[Add]] transaction\n * and return the next state.\n */\nexport const add = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Add, T | T[]>\n) => {\n  const data = dataIsTuple\n    ? [\n        ...state,\n        ...(isArray(dataIsTuple)(transaction.payload)\n          ? transaction.payload\n          : [transaction.payload])\n      ]\n    : state.concat(transaction.payload);\n  return data;\n};\n\n/**\n * update :: (a -> a -> boolean) -> boolean -> [a] -> Update a -> [a]\n *\n * Update data in state (a list of T) given the payload of an [[Update]] transaction\n * and return the next state.\n */\nexport const update = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Update, T | T[]>\n) => {\n  const next = [...state];\n  const data = isArray(dataIsTuple)(transaction.payload)\n    ? transaction.payload\n    : [transaction.payload];\n\n  data.forEach(record => {\n    const index = next.findIndex(r => isEqual(r, record));\n\n    if (index >= 0) {\n      next.splice(index, 1, record);\n    } else {\n      next.push(record);\n    }\n  });\n  return next;\n};\n\n/**\n * remove :: (a -> a -> boolean) -> boolean -> [a] -> Remove a -> [a]\n *\n * Remove data from state (a list of T) given the payload of an [[Remove]] transaction\n * and return the next state.\n */\nexport const remove = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Remove, T | T[]>\n) => {\n  const data = isArray(dataIsTuple)(transaction.payload)\n    ? [...transaction.payload]\n    : [transaction.payload];\n\n  return state.filter(record => {\n    const index = data.findIndex(data => isEqual(record, data));\n    if (index >= 0) {\n      data.splice(index, 1);\n      return false;\n    }\n\n    return true;\n  });\n};\n","import { stateOf } from \"../../modules/state\";\n\nimport { FilterType } from \"./types\";\n\nexport const filterTypeState$ = stateOf(FilterType.All);\n\n","import * as React from \"react\";\n\nimport { Chip, ChipSet } from \"@rmwc/chip\";\n\nimport {\n  FilterType,\n  isFilterTypeAll,\n  isFilterTypeActive,\n  isFilterTypeCompleted\n} from \"../../../modules/filter-todo\";\n\nexport interface PropsFilter {\n  filterType: FilterType;\n  onChangeFilterType: (filterType: FilterType) => void;\n}\n\n// Exports\nexport default (props: PropsFilter) => (\n  <ChipSet choice style={{ justifyContent: \"center\" }}>\n    <Chip\n      label=\"All\"\n      theme={isFilterTypeAll(props.filterType) ? \"secondaryBg\" : undefined}\n      onClick={() => props.onChangeFilterType(FilterType.All)}\n    />\n    <Chip\n      label=\"Active\"\n      icon=\"radio_button_unchecked\"\n      theme={isFilterTypeActive(props.filterType) ? \"secondaryBg\" : undefined}\n      onClick={() => props.onChangeFilterType(FilterType.Active)}\n    />\n    <Chip\n      label=\"Completed\"\n      icon=\"check_circle_outline\"\n      theme={\n        isFilterTypeCompleted(props.filterType) ? \"secondaryBg\" : undefined\n      }\n      onClick={() => props.onChangeFilterType(FilterType.Completed)}\n    />\n  </ChipSet>\n);\n","import * as React from \"react\";\nimport { Typography } from \"@rmwc/typography\";\nimport { Button } from \"@rmwc/button\";\n\nimport {\n  Todo,\n  TodoOperation,\n  NewTodoOperation,\n  MutableTodo\n} from \"../../modules/todo/types\";\n\nimport { FilterType } from \"../../modules/filter-todo\";\n\nimport List from \"./components/List\";\nimport Title from \"./components/Title\";\nimport Filter from \"./components/Filter\";\n\nexport interface PropsTodo {\n  todos: [Todo, TodoOperation][];\n  filterType: FilterType;\n  new: NewTodoOperation;\n  onChangeFilterType: (filterType: FilterType) => void;\n  onEdit: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state: Partial<MutableTodo>) => void;\n  onSave: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state?: Partial<MutableTodo>) => void;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n  onClearComplete: () => void;\n}\n\nexport default (props: PropsTodo) => {\n  const list = (\n    <List\n      todos={props.todos}\n      onEdit={props.onEdit}\n      onSave={props.onSave}\n      onChangeNew={props.onChangeNew}\n      new={props.new}\n      onSubmitNew={props.onSubmitNew}\n      onCompleteAll={props.onCompleteAll}\n    />\n  );\n\n  const clearBtn = (\n    <div>\n      <Button onClick={props.onClearComplete}>Clear completed</Button>\n    </div>\n  );\n\n  const filterChips = (\n    <Filter\n      filterType={props.filterType}\n      onChangeFilterType={props.onChangeFilterType}\n    />\n  );\n\n  const footer = (\n    <Typography use=\"caption\" style={{ color: \"#999  \" }}>\n      <strong>{props.todos.filter(([todo]) => !todo.completed).length}</strong>{\" \"}\n      item left\n    </Typography>\n  );\n\n  return (\n    <>\n      <Title />\n      <section className=\"todoapp\">\n        <section className=\"main\">{list}</section>\n        <footer className=\"footer\" style={{ textAlign: \"center\" }}>\n          {filterChips}\n          {clearBtn}\n          {footer}\n        </footer>\n      </section>\n    </>\n  );\n};\n","import * as React from \"react\";\n\nimport { IconButton } from \"@rmwc/icon-button\";\nimport { Slider } from \"@rmwc/slider\";\n\nexport interface PropsControls {\n  index: number;\n  max: number;\n  setIndex: (index: number) => void;\n  play: () => void;\n  pause: () => void;\n}\n\nexport default (props: PropsControls) => (\n  <div style={{ padding: 15 }}>\n    <Slider\n      value={props.index}\n      // onChange={evt => setIndex(evt.detail.value)}\n      onInput={evt => {\n        props.setIndex(evt.detail.value);\n      }}\n      discrete\n      start={0}\n      max={props.max}\n      step={1}\n    />\n    <div className=\"controls\">\n      <IconButton\n        theme={props.index === 0 ? undefined : \"secondary\"}\n        icon=\"fast_rewind\"\n        onClick={() => props.setIndex(0)}\n        disabled={props.index === 0}\n      />\n      <IconButton\n        theme={props.index === 0 ? undefined : \"secondary\"}\n        icon=\"skip_previous\"\n        onClick={() => props.setIndex(props.index - 1)}\n        disabled={props.index === 0}\n      />\n      <IconButton theme=\"secondary\" icon=\"stop\" onClick={props.pause} />\n      <IconButton\n        theme=\"secondary\"\n        icon=\"play_circle_filled\"\n        onClick={props.play}\n      />\n      <IconButton\n        theme={props.index === props.max ? undefined : \"secondary\"}\n        icon=\"skip_next\"\n        onClick={() => props.setIndex(props.index + 1)}\n        disabled={props.index === props.max}\n      />\n      <IconButton\n        theme={props.index === props.max ? undefined : \"secondary\"}\n        icon=\"fast_forward\"\n        onClick={() => props.setIndex(props.max)}\n        disabled={props.index === props.max}\n      />\n    </div>\n  </div>\n);\n","import * as React from \"react\";\n\nimport { CircularProgress } from \"@rmwc/circular-progress\";\n\nconst styles: React.CSSProperties = {\n  flex: \"1 1 auto\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\"\n};\n\nexport default () => (\n  <div style={styles}>\n    <div>\n      <CircularProgress theme=\"secondary\" size={\"large\"} />\n    </div>\n  </div>\n);\n","import { URL } from \"./constants\";\n\n// Todo\nimport { Todo, MutableTodo, TodoOperation, EventType } from \"./types\";\n\n// Operations\nimport { Ok, Bad, Status, Pending, Noop } from \"../operations\";\n\n// Utilities\nimport { take } from \"../utils\";\n\n/**\n * Mock database of Toods\n */\nlet todos: Todo[] = [];\n\n/**\n * Pattern of booleans used to to randomly fail API calls.\n */\nconst failPattern = [true, false, false, true, true, false, true];\n\n/**\n * Mutuable pointer referencing a boolean in [[failPattern]]\n */\nlet failIndex = 0;\n\n/**\n * Returns the next \"doFail\" flag and moves the failIndex\n * pointer to the next boolean in [[failPattern]]\n */\nconst getNextFailFlag = () => {\n  failIndex += 1;\n\n  if (failIndex > failPattern.length - 1) {\n    failIndex = 0;\n  }\n\n  return failPattern[failIndex];\n};\n\n/**\n * delay\n * Helper function for creating promise that resolves after `ms` milliseconds.\n *\n * @param ms Number of milliseconds to delay resolving the promise.\n */\nconst delay = (ms: number) =>\n  new Promise<void>(resolve => setTimeout(resolve, ms));\n\n/**\n * API for loading the list of Todos in the database.\n */\nexport const read = async () => {\n  const doFail = getNextFailFlag();\n\n  // Only make the network call once since we are mocking things here.\n  if (todos.length <= 0) {\n    const response = await fetch(URL);\n    const json: Todo[] = await response.json();\n    await delay(1500);\n\n    // Replace the database\n    todos = take(6)(json); //.map(todo => ({...todo, completed: false}));\n  }\n  // Return data from our mocked database [[todos]] after 1 second\n  else {\n    await delay(1000);\n  }\n  return todos;\n};\n\n/**\n * API for creating new Todos and storing them in the database.\n * @param operation\n */\nexport const create = async (\n  operation: Pending<string>\n): Promise<Ok<Todo> | Bad<string>> => {\n  const doFail = getNextFailFlag();\n\n  await delay(1500);\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state\n    };\n  }\n\n  if (!operation.state) {\n    return {\n      status: Status.Bad,\n      error: \"A title is required!\",\n      state: operation.state\n    };\n  }\n\n  const todo = {\n    id: Math.floor(Math.random() * 10000),\n    userId: Math.floor(Math.random() * 10000),\n    title: operation.state,\n    completed: false\n  };\n\n  todos = [...todos, todo];\n\n  return {\n    status: Status.Ok,\n    state: todo\n  };\n};\n\n/**\n * API for updating Todos in the database\n *\n * @param todo\n * @param operation\n */\nexport const update = async (\n  todo: Todo,\n  operation: Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Save> | Bad<MutableTodo, EventType.Save>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag();\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state,\n      action: EventType.Save\n    };\n  }\n\n  const title = operation.state.title.trim();\n\n  if (!title) {\n    return {\n      status: Status.Bad,\n      action: EventType.Save,\n      error: \"A title is required!\",\n      state: {\n        ...operation.state,\n        title\n      }\n    };\n  }\n\n  const nextTodo = {\n    ...todo,\n    ...operation.state,\n    title\n  };\n\n  todos = todos.map(current => {\n    if (current.id === nextTodo.id) {\n      return nextTodo;\n    }\n\n    return todo;\n  });\n\n  return {\n    status: Status.Ok,\n    state: { ...todo, ...operation.state, title },\n    action: EventType.Save\n  };\n};\n\n/**\n * API for deleting Todo's from the database\n *\n * @param todo\n * @param operation\n */\nexport const deleet = async (\n  todo: Todo,\n  operation: Pending<MutableTodo, EventType.Delete> //Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Delete> | Bad<MutableTodo, EventType.Delete>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag();\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Unable to delete!\",\n      state: operation.state,\n      action: EventType.Delete\n    };\n  }\n\n  todos = todos.filter(current => current.id !== todo.id);\n\n  return {\n    status: Status.Ok,\n    state: todo,\n    action: EventType.Delete\n  };\n};\n","export const URL = 'https://jsonplaceholder.typicode.com/todos/'\n","import {\n  EventType,\n  FetchEvent,\n  TodoEvent,\n  SaveEvent,\n  DeleteEvent,\n  TodoOperation,\n  EditEvent,\n  Todo,\n  OperationalEventTypes\n} from \"./types\";\n\nimport { Noop, Bad } from '../operations'\n\n/**\n * makeFetchEvent\n */\nexport const makeFetchEvent = (): FetchEvent => {\n  return { type: EventType.Fetch };\n};\n\n/**\n * makeEditEvent\n */\n\nexport const makeEditEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): EditEvent => {\n  return { type: EventType.Edit, todo, operation };\n};\n\n/**\n * makeSaveEvent\n */\nexport const makeSaveEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): SaveEvent => {\n  return { type: EventType.Save, todo, operation };\n};\n\n/**\n * makeDeleteEvent\n */\nexport const makeDeleteEvent = (todo: Todo): DeleteEvent => {\n  return { type: EventType.Delete, todo };\n};\n\n/**\n * makeIsEventType\n */\nexport const makeIsEventType = <T extends EventType>(of: T) => (\n  eventType: EventType\n): eventType is T => eventType === of;\n\n/**\n * isFetchEventType\n */\nexport const isFetchEventType = makeIsEventType(EventType.Fetch);\n\n/**\n * isEditEventType\n */\nexport const isEditEventType = makeIsEventType(EventType.Edit);\n\n/**\n * isSaveEventType\n */\nexport const isSaveEventType = makeIsEventType(EventType.Save);\n\n/**\n * isDeleteEventType\n */\nexport const isDeleteEventType = makeIsEventType(EventType.Delete);\n\n/**\n * makeIsEventOfType\n */\nexport const makeIsEventOfType = <A extends EventType>(\n  f: (eventType: EventType) => eventType is A\n) => (event: TodoEvent): event is Extract<TodoEvent, { type: A }> =>\n  f(event.type);\n\n/**\n * isFetchEvent\n */\nexport const isFetchEvent = makeIsEventOfType(isFetchEventType);\n\n/**\n * isEditEvent\n */\nexport const isEditEvent = makeIsEventOfType(isEditEventType);\n\n/**\n * isSaveEvent\n */\nexport const isSaveEvent = makeIsEventOfType(isSaveEventType);\n\n/**\n * isDeleteEvent\n */\nexport const isDeleteEvent = makeIsEventOfType(isDeleteEventType);\n","import { Todo, MutableTodo } from \"./types\";\nimport { get, set } from \"../utils/getset\";\n\n/**\n * @private\n * \n * Constant used for creating empty, new [[Todo]]s\n */\nconst mutuableTodo: MutableTodo = { completed: false, title: \"\" };\n\n/**\n * toMutable :: [[Todo]] -> [[MutableTodo]]\n * \n * Helper function for extracting `completed` and `title` from todos.\n * This is mostly used to create data for operations.\n * \n * @param todo - The todo object to convert.\n */\nexport const toMutable = (todo: Todo): MutableTodo =>\n  setTitle(setCompleted(mutuableTodo)(getCompleted(todo)))(getTitle(todo));\n\n// Experimental code\nexport const getId = get(\"id\");\nexport const getTitle = get(\"title\");\nexport const getCompleted = get(\"completed\");\n\nexport const setId = set(\"id\");\nexport const setTitle = set(\"title\");\nexport const setCompleted = set(\"completed\");\n\n\n","import {\n  EventType,\n  Todo,\n  MutableTodo,\n  SaveEvent,\n  DeleteEvent,\n  TodoWithOperation,\n  TodoOperation\n} from \"./types\";\n\n// Transactions\nimport {\n  Transaction,\n  TransactionType,\n  makeAddTransaction,\n  makeUpdateTransaction,\n  makeRemoveTransaction,\n  Transanctional\n} from \"../transactions\";\n\n// Operations\nimport { Ok, Bad, isOk, makeNoop } from \"../operations\";\n\n// Utilities\nimport { toMutable } from \"./utils\";\nimport { tuple } from \"../utils\";\n\n/** Operations that can be reset to Noop */\nexport type ResetableOperation =\n  | Ok<Todo, EventType.Save>\n  | Bad<MutableTodo, EventType.Save | EventType.Delete>;\n\n/* Events that can be done over if there outcome fails. */\nexport type RedoableEvent = SaveEvent | DeleteEvent;\n\n/* Effectful function for updating state */\nexport type Writer = (\n  todos: Transaction<Transanctional<TodoWithOperation>>\n) => void;\n\n/**\n * resetOkAndBadTodosEffect :: Write -> (RedoableEvent, ResetableOperation) -> ()\n *  \n * @param writer \n */\nexport const resetOkAndBadTodosEffect = (writer: Writer) => ([\n  event,\n  operation\n]: [RedoableEvent, ResetableOperation]) => {\n  const noop = makeNoop(\n    isOk(operation) ? toMutable(operation.state) : operation.state\n  );\n\n  const transaction = {\n    type: TransactionType.Update,\n    payload: isOk(operation)\n      ? tuple(operation.state, noop)\n      : tuple(event.todo, noop)\n  };\n\n  writer(transaction);\n};\n\n// What I want is:\n// export const add = (write: Writer) => compose(write, makeAddTransaction)\n// or go crazy\n// and make add:\n// curry(flip(compose)(makeAddTransaction))\n// But TypeScript can't handle me\n\nconst makeWriteEffect = (\n  transactionMaker: (\n    data: Transanctional<[Todo, TodoOperation]>\n  ) => Transaction<Transanctional<[Todo, TodoOperation]>>\n) => (writer: Writer) => (data: Transanctional<[Todo, TodoOperation]>) =>\n  writer(transactionMaker(data));\n\nexport const addEffect = makeWriteEffect(makeAddTransaction);\n\nexport const updateEffect = makeWriteEffect(makeUpdateTransaction);\n\nexport const remoteEffect = makeWriteEffect(makeRemoveTransaction);\n\ntype DeleteOutcome =\n  | Ok<Todo, EventType.Delete>\n  | Bad<MutableTodo, EventType.Delete>;\n\nexport const runDeleteOutcomeEffect = (writer: Writer) => (todo: Todo) => (\n  outcome: DeleteOutcome\n) =>\n  isOk(outcome)\n    ? remoteEffect(writer)(tuple(todo, outcome))\n    : updateEffect(writer)(tuple(todo, outcome));\n\ntype SaveOutcome = Ok<Todo, EventType.Save> | Bad<MutableTodo, EventType.Save>;\n\nexport const runSaveOutcomeEffect = (writer: Writer) => (todo: Todo) => (\n  outcome: SaveOutcome\n) => {\n  updateEffect(writer)(\n    tuple(isOk(outcome) ? { ...todo, ...outcome.state } : todo, outcome)\n  );\n};\n\nexport const runCreateOutcomeEffect = (writer: Writer) => (\n  outcome: Ok<Todo> | Bad<string>\n) => {\n  if (isOk(outcome)) {\n    const todoWithOperation = tuple(\n      outcome.state,\n      makeNoop({\n        title: outcome.state.title,\n        completed: false\n      })\n    );\n\n    addEffect(writer)(todoWithOperation);\n  }\n};\n","// RxJS\nimport { Subject, from, of, EMPTY, concat, Observable } from \"rxjs\";\nimport {\n  tap,\n  map,\n  mergeMap,\n  switchMap,\n  groupBy,\n  timeoutWith,\n  ignoreElements,\n  startWith,\n  delay,\n  filter\n} from \"rxjs/operators\";\n\n// Utilities\nimport {\n  tuple,\n  compose,\n  thruple,\n  identity,\n  IS_TUPLE,\n  arrayBimap\n} from \"../utils\";\n\n// State\nimport { stateOf, StateObservable, transactionalStateOf } from \"../state\";\n\n// API\nimport { read, create, update, deleet } from \"./api\";\n\n// Todo\nimport {\n  TodoEvent,\n  Todo,\n  NewTodoOperation,\n  EventType,\n  SaveEvent,\n  EditEvent,\n  DeleteEvent,\n  FetchEvent,\n  TodoWithOperation\n} from \"./types\";\n\nimport { isFetchEvent, isEditEvent, isSaveEvent, makeFetchEvent } from \"./events\";\n\nimport { toMutable } from \"./utils\";\n\n// Operational\nimport { makeNoop, isPending, isBad, toPending, isNoop } from \"../operations\";\n\n// Transaction\nimport { TransactionType } from \"../transactions\";\n\n// Effects\nimport {\n  resetOkAndBadTodosEffect,\n  RedoableEvent,\n  ResetableOperation,\n  addEffect,\n  updateEffect,\n  runDeleteOutcomeEffect,\n  runSaveOutcomeEffect,\n  runCreateOutcomeEffect\n} from \"./effects\";\n\n/**\n * @private\n *\n * [[Subject]] for dispatching and streaming events.\n */\nconst events$ = new Subject<TodoEvent>();\n\n/**\n * dispatch :: TodoEvent -> ()\n *\n * Function for dispatching to the [[events$]] [[Subject]]\n *\n * @param event An [[EditEvent]], [[SaveEent]], or [[DeleteEvent]].\n */\nexport const dispatch = (event: TodoEvent) => {\n  console.warn(`Dispatching ${event.type}`);\n  events$.next(event);\n};\n\n/**\n * dispatchFetch :: () -> void\n */\nexport const dispatchFetch = () => dispatch(makeFetchEvent());\n\n/**\n * Create a transactional [[StateObservable]] allowing us to use the\n * setState function (in this case named writeTodos) to either accept an\n * array of TodoWithOperation or just a single element.\n */\nexport const [todos$, writeTodos] = transactionalStateOf(\n  [] as TodoWithOperation[],\n  ([todo1], [todo2]) => todo1.id === todo2.id,\n  IS_TUPLE\n);\n\n/**\n * Operator for resetting a todo's operation to Noop\n * after it was set to Bad or Ok\n *\n * @param updateOrDeleteEventAndOperation$\n */\nconst resetOkAndBadTodos = (\n  updateOrDeleteEventAndOperation$: Observable<\n    [RedoableEvent, ResetableOperation]\n  >\n) =>\n  updateOrDeleteEventAndOperation$.pipe(\n    delay(1000),\n    tap(resetOkAndBadTodosEffect(writeTodos))\n  );\n\n/**\n * Main function for handling incoming events\n * Kind of like a reducer in Redux.\n *\n * It groups the events by type Fetch or the id of the todo.\n * and uses switchMap for each group.\n */\nexport const handleEvents$ = events$.pipe(\n  groupBy(\n    event => {\n      if (isFetchEvent(event)) {\n        return EventType.Fetch;\n      } else {\n        return event.todo.id;\n      }\n    },\n    event => event,\n    actionsByGroup$ =>\n      actionsByGroup$.pipe(\n        timeoutWith(15000, EMPTY),\n        ignoreElements()\n      )\n  ),\n  mergeMap(groupedEvent$ =>\n    groupedEvent$.pipe(\n      switchMap(event => {\n        if (isFetchEvent(event)) {\n          return handleReadEvent(event);\n        } else if (isEditEvent(event)) {\n          return handleEditEvent(event);\n        } else if (isSaveEvent(event)) {\n          return handleSaveEvent(event);\n        }\n\n        return handleDeleteEvent(event);\n      })\n    )\n  )\n);\n\n// Because TypeScript is unable to infer this bois abstractions.\ntype Id<T> = (id: T) => T;\n\n/**\n * Handles incoming [[FetchEvent]] events that have been\n * dispatched to the [[events$]] [[Subject]]\n *\n * It immediately calls the API for requesting Todos from\n * the server and updates state with the received todos\n * by running the addEffect\n *\n * @param event The [[FetchEvent]] event\n */\nexport const handleReadEvent = (event: FetchEvent) =>\n  from(read()).pipe(\n    // map(arrayMap(curry(tuple))),\n    map(\n      arrayBimap(identity as Id<Todo>)(\n        // f after g\n        compose(\n          makeNoop, // f\n          toMutable // g\n        )\n      )\n    ),\n    tap(addEffect(writeTodos))\n  );\n\n/**\n * Handle incoming events requesting [[Todo]](s) be deleted\n * from the database.\n *\n * State is updating first to indicate \"in progress\". Then the\n * API for deleting Todos is called. Once the call resolves\n * state is updated to indicate failure or success. After a second\n * state is updated once again to reset the operation so that the\n * UI removes the indicators of failure or success.\n *\n * @param event - The delete event [[DeleteEvent]]\n */\nconst handleDeleteEvent = (event: DeleteEvent) => {\n  const operation = toPending(\n    makeNoop(toMutable(event.todo)),\n    EventType.Delete as const\n  );\n\n  const promise = deleet(event.todo, operation);\n\n  return concat(\n    of(tuple(event.todo, operation)).pipe(tap(updateEffect(writeTodos))),\n    from(promise).pipe(\n      tap(runDeleteOutcomeEffect(writeTodos)(event.todo)),\n      filter(isBad),\n      map(outcome => tuple(event, outcome)),\n      resetOkAndBadTodos\n    )\n  );\n};\n\n/**\n * Responsds to the [[EditEvent]] dispatched on the [[events$]]\n * [[Subject]] after the user types to change the title of\n * a [[Todo]]\n *\n * The only effect here is updating state. No API calls\n *\n * @param event [[EditEvent]]\n */\nconst handleEditEvent = (event: EditEvent) => {\n  // Reset the Todo's operational status if the user\n  // started editing after a success or failure operation\n  const operation = isNoop(event.operation)\n    ? event.operation\n    : makeNoop(event.operation.state);\n\n  return of(tuple(event.todo, operation)).pipe(tap(updateEffect(writeTodos)));\n};\n\n/**\n * Handles incoming [[SaveEvent]] events that are dispatched to [[event$]]\n *\n * - It first updates state to indicate the Todo is currently being saved.\n * - Then calls the API for updating existing todos in the database.\n * - Passes the results to runSaveOutcomeEffect to update state accordingly\n * - And resets after a delay using [[resetOkAndBadTodos]]\n *\n * @param event\n */\nconst handleSaveEvent = (event: SaveEvent) => {\n  const operation = toPending(event.operation, EventType.Save as const);\n\n  const updateTransaction = {\n    type: TransactionType.Update as const,\n    payload: tuple(event.todo, operation)\n  };\n\n  const promise = update(event.todo, event.operation);\n\n  return concat(\n    of(void 0).pipe(tap(() => writeTodos(updateTransaction))),\n    from(promise).pipe(\n      tap(runSaveOutcomeEffect(writeTodos)(event.todo)),\n      map(outcome => tuple(event, outcome)),\n      resetOkAndBadTodos\n    )\n  );\n};\n\n/**\n * Event stream filtered by type FETCH\n */\nexport const eventsHandler$ = handleEvents$;\n\n/**\n * I'm destructuring the result of `stateOf` so that I can re-export\n * a piped version of `_newTodoOperation`\n */\nconst [_newTodoOperation$, setNewTodoOperation, getNewTodoOperation] = stateOf(\n  makeNoop(\"\") as NewTodoOperation\n);\n\n/**\n * [[StateObservable]] that handles new todos the user wants to create.\n * It starts with an empty \"Noop\" operation of a string (title)\n * and any time `setNewTodoOperation` is called the stream checks if the status\n * has changed to \"pending\" and if so will start calling the API\n * for storing the new todo in the datatabase.\n *\n * Using [[thruple]] to re-export everything as a [[StateObservable]]\n *\n *\n */\nexport const newTodoOperation$ = thruple(\n  _newTodoOperation$.pipe(\n    switchMap(state =>\n      isPending(state)\n        ? from(create(state)).pipe(\n            tap(runCreateOutcomeEffect(writeTodos)),\n            map(nextState => (isBad(nextState) ? nextState : makeNoop(\"\"))),\n            startWith(state)\n          )\n        : of(state)\n    )\n  ),\n  setNewTodoOperation,\n  getNewTodoOperation\n) as StateObservable<NewTodoOperation>;\n","import { scan } from \"rxjs/operators\";\n\nimport { tuple } from \"../utils\";\nimport { TransactionType, Transaction, update, add, remove } from \"../transactions\";\n\nimport { stateOf } from \"./stateOf\";\n\n/**\n * transactionalStateOf :: t | [t] -> (t -> t -> boolean) -> boolean -> (Observable [t], Transaction t | [t] -> void)\n * \n * Creates a stateful, transactional observable for lists.\n */\nexport const transactionalStateOf = <T>(\n  initialState: T | T[],\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  isTuple: boolean = false\n) => {\n  const initialTransaction: Transaction<T | T[]> = {\n    type: TransactionType.Add,\n    payload: initialState\n  } as any;\n\n\n\n  const [state$, setState] = stateOf(initialTransaction);\n\n  const transactional$ = state$.pipe(\n    scan(\n      (acc, transaction) => {\n        switch (transaction.type) {\n          case TransactionType.Add: {\n            return add(isEqual, isTuple)(acc)(transaction)\n          }\n          case TransactionType.Update: {\n            return update(isEqual, isTuple)(acc)(transaction)\n          }\n\n          case TransactionType.Remove: {\n            return remove(isEqual, isTuple)(acc)(transaction)\n          }\n\n          default:\n            return acc;\n        }\n      },\n      [] as T[]\n    )\n  );\n\n  return tuple(transactional$, setState);\n};\n\n","import {\n  Observable,\n  Subject,\n  combineLatest,\n  BehaviorSubject,\n  of,\n  EMPTY,\n  merge,\n  concat\n} from \"rxjs\";\n\nimport {\n  scan,\n  map,\n  withLatestFrom,\n  tap,\n  delay,\n  switchMap,\n  filter,\n  share\n} from \"rxjs/operators\";\n\nimport { tuple, isNotNull } from \"../utils\";\n\n/**\n * Turns an observable into a time travelable\n * version of itself.\n *\n * It does this by creating a Subject to sink/stream the selected\n * historic index.\n *\n * Then it it creates `stateWithHistory$` which is just using\n * the `scan` operator to keep track of all emitted values.\n *\n * A final `index$` observable is created that only emits\n * index values that are within the bounds of the history\n * array's length.\n *\n * A final `state$` observable is created by combining\n * `index$` and `stateWithHistory$` to either select state\n * from the history array or return the active, current state\n * if the index is `-1`\n *\n * The return value of this function is a thruple of:\n * 0: The final `state$` observable\n * 1: A dispatch function for setting the selected index\n * 2: The `index$` observable emitting both the index and the maximum\n */\nexport const makeTimeTravelable = <T>(observable$: Observable<T>) => {\n  const indexSubject = new BehaviorSubject(-1);\n\n  const stateWithHistory$ = combineLatest(indexSubject, observable$).pipe(\n    scan(\n      ([state, index, history], [nextIndex, nextState]) => {\n        return state !== nextState\n          ? ([\n              nextState,\n              index >= 0 && index + 1 < history.length ? index + 1 : -1,\n              state ? [...history, [state, Date.now()]] : []\n            ] as [T, number, [T, number][]])\n          : ([nextState, nextIndex, history] as [T, number, [T, number][]]);\n      },\n      [undefined, -1, []] as [T | undefined, number, [T, number][]]\n    ),\n    filter((stream): stream is [T, number, [T, number][]] =>\n      isNotNull(stream[0])\n    ),\n    map(([state, index, history]) => {\n      if (index < 0 || index >= history.length) {\n        return [state, history, history.length, history.length] as const;\n      }\n\n      return [history[index][0], history, index, history.length] as const;\n    }),\n    share()\n  );\n\n  const playSubject = new Subject<\"PLAY\" | \"PAUSE\">();\n\n  const replay$ = playSubject.pipe(\n    withLatestFrom(stateWithHistory$),\n    switchMap(([mode, s]) => {\n      if (mode === \"PLAY\") {\n        return concat(of(s), stateWithHistory$).pipe(\n          switchMap(([state, history, index]) => {\n            const timeline = state\n              ? [...history, tuple(state, history[history.length - 1][1] + 250)]\n              : history;\n            const ms =\n              index > 0 && timeline[index + 1]\n                ? timeline[index + 1][1] - timeline[index][1]\n                : 0;\n\n            return of(void 0).pipe(\n              delay(ms > 2500 ? 250 : ms),\n              tap(() => setIndex(timeline[index + 1] ? index + 1 : 0))\n            );\n          })\n        );\n      }\n\n      return EMPTY;\n    })\n  );\n\n  const setIndex = (index: number) => {\n    indexSubject.next(index);\n  };\n\n  const stream$ = merge(replay$, stateWithHistory$).pipe(\n    filter((stream): stream is readonly [T, [T, number][], number, number] =>\n      isNotNull(stream)\n    )\n  );\n\n  return [\n    stream$,\n    setIndex,\n    indexSubject.asObservable(),\n    () => playSubject.next(\"PLAY\"),\n    () => playSubject.next(\"PAUSE\")\n  ] as const;\n};\n","import { newTodoOperation$ } from \"../../modules/todo/observables\";\nimport { createState, makeTimeTravelable } from \"../../modules/state\";\nimport { filterTypeState$ } from \"../../modules/filter-todo\";\nimport { Observable } from \"rxjs\";\n\nimport { todosByFilterType$ } from \"./observables\";\n\n\nexport const state$ = createState({\n  todos: todosByFilterType$,\n  filterType: filterTypeState$,\n  new: newTodoOperation$\n});\n\nexport const [timeTravelableState$, setIndex, _, play, pause] = makeTimeTravelable(\n  state$\n);\n  \nexport type Observed<T> = T extends Observable<infer S> ? S : never;\n\nexport type State = Observed<typeof state$>","import { Observable, combineLatest } from \"rxjs\";\nimport { isStateObservable, ObservableLike } from \"./stateOf\";\nimport { map, tap, share } from \"rxjs/operators\";\n\n/**\n * Returns a type describing all keys of object T\n * that are of type V\n */\ntype KeyOfType<T, V> = {\n  [P in keyof T]: T[P] extends V ? P : never;\n}[keyof T];\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they belong to keys in type K\n */\ntype ReadonlyByKey<T extends {}, K extends keyof T> = Readonly<Pick<T, K>> &\n  Omit<T, K>;\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they are of type V\n */\ntype ReadonlyByType<T, V> = ReadonlyByKey<T, KeyOfType<T, V>>;\n\n/**\n * An object representing a map of [[Observable]] or [[StateObserveable]]\n */\ntype MapOfObservables = {\n  [prop: string]: ObservableLike<any>;\n};\n\n/**\n * A type representing a map of values based on a map of\n * [[Observable]] or [[StateObservable]] and the values those\n * observable stream.\n *\n * For example\n *\n * ```ts\n * type Foo = MapOfStateFromMapOfObservables<{ bar: Observable<number>>, zax: StateObservable<string> }\n *\n * // equates to\n *\n * type Foo = { readonly bar: number, zax: string }\n * ```\n *\n */\ntype MapOfStateFromMapOfObservables<T> = {\n  [P in keyof T]: T[P] extends ObservableLike<infer B> ? B : never;\n};\n\n/**\n * State$ describes an [[Observable]] that emits a state object where\n * key/value pairs created by a sub [[Observable]] are immutable and\n * key/values streamed by a [[StateObservable]] are semi-mutuable in\n * the sense that you can change their value in an mutauble style as\n * a _setter_ has been defined for that key/value pair that will send\n * the assigned value to the StateObservable's [[Subject]]\n *\n */\nexport type State$<T extends MapOfObservables> = Observable<\n  MapOfStateFromMapOfObservables<ReadonlyByType<T, Observable<any>>>\n>;\n\n/**\n * Creates a single state observable from a map of [[ObservableLike]]\n */\nexport const createState = <T extends MapOfObservables>(\n  mapOfObservables: T\n): State$<T> => {\n  // Compile a list of keys that are part of the state object.\n  const keys = Object.keys(mapOfObservables);\n\n  // Reduce the list of keys to a list of observables where each observable\n  // is a thruple of the key, getter, and setter.\n  const observables$: Observable<\n    [string, () => any, () => void]\n  >[] = keys.reduce(\n    (acc, key) => {\n      const observable$ = mapOfObservables[key];\n\n      // If the observable is our custom StateObservable\n      if (isStateObservable(observable$)) {\n        // Destructure the StateObservable into it's actual observabble and dispatcher\n        const [state$, setState] = observable$;\n\n        // Map the state$ observable to a thruple of\n        // its key, getter, and setter\n        const nextState$ = state$.pipe(\n          map(state => {\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter\n              (nextState: any) => {\n                setState(nextState);\n              }\n            ];\n          })\n        );\n\n        // Add the composed state observable to the accumulator.\n        acc.push(nextState$);\n      }\n\n      // If the observable was just a regular observable\n      else {\n        const nextState$ = observable$.pipe(\n          map(state => {\n            // Map the state$ observable to a thruple of\n            // its key, getter, and setter\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter that will log an error message in dev mode\n              (value: any) => {\n                if (process.env.NODE_ENV === \"development\") {\n                  console.error(\n                    `Attempting to mutate state \"${key}\" with value \"${value}\" of state with properties ${keys.join(\n                      \", \"\n                    )}`\n                  );\n                }\n              }\n            ];\n          }),\n          tap(_ => console.warn(`Streaming [${key}]`)),\n\n        );\n\n        acc.push(nextState$);\n      }\n      return acc;\n    },\n    [] as any[]\n  );\n\n  // Combine the list of observables of [key, getter, setter]\n  // into a single state observable\n\n  type Key = string;\n  type Getter = () => any;\n  type Setter = () => void;\n\n  const state$ = combineLatest(...observables$).pipe(\n    map((states: [Key, Getter, Setter][]) =>\n      states.reduce(\n        (acc, [k, g, s]) => {\n          // Using Object.defineProperty to preserve the merging\n          // of getters and setters\n          Object.defineProperty(acc, k, {\n            get: g,\n            set: s\n          });\n\n          return acc;\n        },\n        {} as any\n      )\n    ),\n    tap(state => console.log('State, state', state)),\n    share()\n  );\n\n  return state$;\n};\n","import { combineLatest } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\n\nimport { todos$ } from \"../../modules/todo/observables\";\nimport { selectTodoFilter, filterTypeState$ } from \"../../modules/filter-todo\";\n\n/**\n * Observable returning todos filtered by selected filter type.\n */\nexport const todosByFilterType$ = combineLatest(\n  todos$,\n  filterTypeState$[0]\n).pipe(\n  map(\n    ([todos, filterType]) => selectTodoFilter(filterType)(todos)\n    // What I want is point-free but TypeScript can't handle me.\n    // fromAandBToC(\n    //   compose(\n    //     selectTodoFilter,\n    //     second\n    //   )\n  )\n);\n","import { identity } from '../utils'\n\nimport { FilterType } from './types'\nimport { filterActiveTodos, filterCompletedTodos  } from './filter'\nimport { isFilterTypeActive, isFilterTypeCompleted } from './assert'\n\n/**\n * selectTodoFilter :: FilterType -> [TodoWithOperation] -> [TodoWithOperation]\n * \n * Given a type of filter returns a function that filters a list of tuples of (Todo, TodoOperation)\n * \n */\nexport const selectTodoFilter = (filterType: FilterType) =>\n  isFilterTypeActive(filterType)\n    ? filterActiveTodos\n    : isFilterTypeCompleted(filterType)\n    ? filterCompletedTodos\n    : identity;","import { Todo } from \"./types\";\n\n/**\n * isComplete :: Todo -> boolean\n */\nexport const isComplete = (todo: Todo) => todo.completed === true;\n","import { timeTravelableState$, State } from \"./state\";\nimport { map, filter } from \"rxjs/operators\";\n\nimport {\n  makeNoop,\n  toPending,\n  isPending,\n  isNoop,\n  isBad,\n  Noop\n} from \"../../modules/operations\";\n\nimport { FilterType } from \"../../modules/filter-todo\";\n\nimport {\n  dispatch,\n  makeEditEvent,\n  TodoOperation,\n  Todo,\n  makeSaveEvent,\n  MutableTodo,\n  makeDeleteEvent,\n  isComplete\n} from \"../../modules/todo\";\n\nimport { compose, second, tuple, first } from \"../../modules/utils\";\nimport { noop } from \"rxjs\";\n\nconst makeOnChangeFilterType = (state: State) => (filterType: FilterType) => {\n  state.filterType = filterType;\n};\n\nconst makeOnChangeNew = (state: State) => (title: string) => {\n  state.new = makeNoop(title);\n};\n\nconst makeOnSubmitNew = (state: State) => () => {\n  if (!isPending(state.new)) state.new = toPending(state.new);\n};\n\nconst makeOnEdit = (state: State) => (todo: Todo, operation: TodoOperation) => (\n  state: Partial<Pick<Todo, \"completed\" | \"title\">>\n) => {\n  if (isNoop(operation) || isBad(operation)) {\n    dispatch(\n      makeEditEvent(todo, {\n        ...operation,\n        state: {\n          ...operation.state,\n          ...state\n        }\n      })\n    );\n  }\n};\n\nconst makeOnSave = (todo: Todo, operation: TodoOperation) => (\n  state: Partial<Pick<Todo, \"completed\" | \"title\">> = {}\n) => {\n  if (isNoop(operation) || isBad(operation)) {\n    dispatch(\n      makeSaveEvent(todo, {\n        ...operation,\n        state: {\n          ...operation.state,\n          ...state\n        }\n      })\n    );\n  }\n};\n\nconst makeOnCompleteAll = (state: State) => () =>\n  state.todos\n    .filter(\n      compose(\n        a => !a,\n        compose(\n          isComplete,\n          first\n        )\n      )\n    )\n    .filter(\n      (todo): todo is [Todo, Noop<MutableTodo>] =>\n        isNoop(second(todo)) || isBad(second(todo))\n    )\n    .map(todo =>\n      tuple(first(todo), {\n        ...second(todo),\n        state: { ...second(todo).state, completed: true }\n      })\n    )\n    .forEach(todo => dispatch(makeSaveEvent(...todo)));\n\nconst makeOnClearComplete = (state: State) => () => {\n  state.todos\n    .filter(\n      compose(\n        isComplete,\n        first\n      )\n    )\n    .filter(\n      (todo): todo is [Todo, Noop<MutableTodo>] =>\n        isNoop(second(todo)) || isBad(second(todo))\n    )\n    .forEach(([todo]) => dispatch(makeDeleteEvent(todo)));\n};\n\n/**\n * Observable returning props\n */\nexport const props$ = timeTravelableState$.pipe(\n  // filter(<T>(stream: T | undefined): stream is T => !!stream),\n  map(([state, _, index, max]) => {\n    const isReplaying = index !== max\n\n    const onChangeFilterType = isReplaying ? noop : makeOnChangeFilterType(state);\n    const onChangeNew = isReplaying ? noop : makeOnChangeNew(state);\n    const onSubmitNew = isReplaying ? noop : makeOnSubmitNew(state);\n    const onEdit = isReplaying ? () => noop : makeOnEdit(state);\n    const onSave = isReplaying ? () => noop : makeOnSave;\n    const onCompleteAll = isReplaying ? noop : makeOnCompleteAll(state);\n    const onClearComplete = isReplaying ? noop : makeOnClearComplete(state);\n\n    return {\n      todos: state.todos,\n      new: state.new,\n      filterType: state.filterType,\n      onChangeFilterType,\n      onChangeNew,\n      onSubmitNew,\n      onEdit,\n      onSave,\n      onCompleteAll,\n      onClearComplete\n    }\n  })\n);\n","import React from \"react\";\nimport { noop } from \"rxjs\";\n\nimport TodoApp from \"./apps/todo/Todo\";\nimport Controls from \"./apps/state-replay/compontents/Controls\";\nimport Loading from \"./Loading\";\n\nimport { setIndex, play, pause } from \"./apps/todo/state\";\nimport { useTodoProps } from \"./apps/todo/hooks\";\n\nconst App = () => {\n  const [props, state] = useTodoProps();\n  if (props != null) {\n    const todoApp = (\n      <TodoApp\n        todos={props.todos}\n        new={props.new}\n        onChangeFilterType={\n          props.onChangeFilterType\n        }\n        onChangeNew={props.onChangeNew}\n        onSubmitNew={props.onSubmitNew}\n        filterType={props.filterType}\n        onEdit={props.onEdit}\n        onSave={props.onSave}\n        onCompleteAll={props.onCompleteAll}\n        onClearComplete={\n          props.onClearComplete\n        }\n      />\n    );\n\n    const controls = (\n      <Controls\n        index={state.index}\n        max={state.max}\n        setIndex={setIndex}\n        pause={pause}\n        play={play}\n      />\n    );\n\n    return (\n      <>\n        <div>\n          <div className=\"todomvc\">{todoApp}</div>\n        </div>\n        <div>{controls}</div>\n      </>\n    );\n  }\n\n  return <Loading />;\n};\n\nexport default App;\n","import * as React from \"react\";\nimport { tap } from \"rxjs/operators\";\n\nimport { dispatchFetch, eventsHandler$ } from \"../../modules/todo\";\n\nimport { timeTravelableState$, Observed } from \"./state\";\nimport { props$ } from \"./select\";\n\nexport const useTodoProps = () => {\n  const [state, setState] = React.useState<{ index: number; max: number }>({\n    index: -1,\n    max: 0\n  });\n\n  const [props, setProps] = React.useState<\n    Observed<typeof props$> | undefined\n  >();\n\n  React.useEffect(() => {\n    const propsSubscription = props$.pipe(tap(setProps)).subscribe();\n\n    const eventsHandlerSubscription = eventsHandler$.subscribe();\n\n    const stateSubscription = timeTravelableState$\n      .pipe(\n        tap(([, , index, max]) => setState({ index, max })),\n      )\n      .subscribe();\n\n    dispatchFetch()\n\n    return () => {\n      eventsHandlerSubscription.unsubscribe();\n      stateSubscription.unsubscribe();\n      propsSubscription.unsubscribe();\n    };\n  }, []);\n  debugger\n  return [props, state, setState] as const\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}