{"version":3,"sources":["modules/utils/getset.ts","modules/utils/index.ts","modules/utils/tuple.ts","modules/utils/array.ts","modules/utils/observable.ts","modules/utils/assert.ts","modules/utils/function.ts","modules/todo/types.ts","modules/operations/types.ts","modules/operations/utils.ts","apps/todo/components/Item.tsx","modules/filter-todo/types.ts","apps/todo/components/List.tsx","apps/todo/components/Title.tsx","modules/filter-todo/assert.ts","modules/transactions/types.ts","modules/filter-todo/filter.ts","modules/state/stateOf.ts","modules/transactions/utils.ts","modules/transactions/index.ts","modules/filter-todo/observable.ts","apps/todo/components/Filter.tsx","apps/todo/Todo.tsx","apps/state-replay/compontents/Controls.tsx","Loading.tsx","modules/todo/api.ts","modules/todo/constants.ts","modules/todo/events.ts","modules/todo/utils.ts","modules/todo/effects.ts","modules/todo/observables.ts","modules/state/transactionalStateOf.ts","modules/state/makeTimeTravelable.ts","apps/todo/state.ts","modules/state/createState.ts","apps/todo/observables.ts","modules/filter-todo/select.ts","modules/todo/assert.ts","apps/todo/select.ts","App.tsx","apps/todo/hooks.ts","serviceWorker.ts","index.tsx"],"names":["get","prop","object","set","value","Object","assign","first","second","tuple","a","b","thruple","c","arrayBimap","f","g","as","map","IS_TUPLE","isArray","dataIsTuple","data","Array","length","isNotNull","take","amount","xs","txs","len","i","push","once","output","identity","compose","EventType","Status","makeIsStatus","statusType","checkedStatus","statusTypeIsOk","Ok","statusTypeIsBad","Bad","statusTypeIsNoop","Noop","statusTypeIsPending","Pending","makeIsOperationOfStatus","operation","status","isOk","isBad","isNoop","isPending","makeNoop","state","toPending","action","FilterType","Item","props","title","todo","style","opacity","isDeleting","transition","icon","completed","theme","undefined","onClick","onSave","error","fontStyle","use","newTodo","new","onChangeNew","noop","evt","currentTarget","snack","open","background","message","className","twoLine","onCompleteAll","fullwidth","placeholder","height","onChange","onKeyUp","keyCode","onSubmitNew","autoFocus","trailingIcon","todos","key","id","onEdit","Delete","renderList","textAlign","marginTop","TransactionType","makeIsFilterType","of","filterType","isFilterTypeAll","All","isFilterTypeCompleted","Completed","isFilterTypeActive","Active","makeFilterTodosByFilterType","filter","filterCompletedTodos","filterActiveTodos","stateOf","initialState","subject","BehaviorSubject","asObservable","next","getValue","makeTransactionMaker","type","payload","makeAddTransaction","Add","makeUpdateTransaction","Update","makeRemoveTransaction","Remove","add","transaction","concat","update","isEqual","t1","t2","forEach","record","index","findIndex","r","splice","remove","filterTypeState$","choice","justifyContent","label","onChangeFilterType","list","List","clearBtn","onClearComplete","filterChips","Filter","footer","color","Title","padding","onInput","setIndex","detail","discrete","start","max","step","disabled","pause","play","styles","flex","display","alignItems","size","failPattern","failIndex","getNextFailFlag","delay","ms","Promise","resolve","setTimeout","randomDelay","Math","ceil","random","read","fetch","response","json","create","doFail","trim","find","floor","userId","Save","nextTodo","current","deleet","makeSaveEvent","makeIsEventType","eventType","isFetchEventType","Fetch","isEditEventType","Edit","isSaveEventType","isDeleteEventType","makeIsEventOfType","event","isFetchEvent","isEditEvent","isSaveEvent","mutuableTodo","toMutable","setTitle","setCompleted","getCompleted","getTitle","makeWriteEffect","transactionMaker","writer","addEffect","updateEffect","remoteEffect","runSaveOutcomeEffect","outcome","events$","Subject","dispatch","console","warn","dispatchFetch","isTuple","initialTransaction","state$","setState","transactional$","pipe","scan","acc","transactionalStateOf","todo1","todo2","todos$","writeTodos","resetOkAndBadTodos","updateOrDeleteEventAndOperation$","tap","handleEvents$","groupBy","actionsByGroup$","timeoutWith","EMPTY","ignoreElements","mergeMap","groupedEvent$","switchMap","handleReadEvent","handleEditEvent","handleSaveEvent","handleDeleteEvent","from","promise","updateTransaction","_newTodoOperation$","setNewTodoOperation","getNewTodoOperation","newTodoOperation$","todoWithOperation","nextState","startWith","observable$","indexSubject","stateWithHistory$","combineLatest","history","nextIndex","Date","now","stream","share","playSubject","replay$","withLatestFrom","mode","s","timeline","merge","makeTimeTravelable","mapOfObservables","observables$","keys","reduce","isStateObservable","nextState$","process","_","states","k","defineProperty","log","createState","selectTodoFilter","timeTravelableState$","isComplete","makeOnEdit","makeEditEvent","makeOnSave","makeOnClearComplete","makeDeleteEvent","props$","isReplaying","makeOnChangeFilterType","makeOnChangeNew","makeOnSubmitNew","makeOnCompleteAll","App","React","setProps","propsSubscription","subscribe","handleEventsSubscription","stateSubscription","unsubscribe","useTodoProps","todoApp","Todo","controls","Controls","Loading","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.55a35d5c.chunk.js","sourcesContent":["/**\n * @module utils\n */\n\n\n/**\n * TODO\n * @param prop \n */\n export function get<K extends string>(prop: K) {\n  // function getter<T extends { [P in K]?: T[K] }>(object: T): T[K]\n  function getter<T extends { [P in K]: T[K] }>(object: T): T[K] {\n    return object[prop]\n  }\n\n  return getter\n}\n\n/**\n * TODO\n * @param prop \n */\nexport function set<K extends string>(prop: K) {\n  // function setter<T extends { [P in K]?: T[K] }>(object: T): (value: T[K]) => T\n  function setter<T extends { [P in K]: T[K] }>(object: T): (value: T[K]) => T {\n    return function (value: T[K]): T {\n      return Object.assign(object, {\n        [prop]: value\n      })\n    }\n  }\n\n  return setter\n}\n\n/**\n * TODO\n * @param prop \n */\nexport interface GetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T): T[K]\n  <T extends { [P in K]: any }>(object: T): T[K]\n}\n\n/**\n * TODO\n * @param prop \n */\nexport interface SetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T, value: T[K]): T\n  <T extends { [P in K]: any }>(object: T, value: T[K]): T\n}\n    \n// Examples\n/*\ninterface User {\n    id: number,\n    username: string,\n}\n\ntype NewUser = Partial<User>\n    \nexport const getUserId = composeGetter('id')\n\ntype UsernameGetter = GetProperty<'username'>\nconst getUsername: UsernameGetter = composeGetter('username')\n\ndeclare const user: User\ndeclare const newUser: NewUser\n    \nconst userId = getUserId(user) // :number\nconst userUsername = getUsername(user) // :number | undefined\n\nconst newUserId = getUserId(newUser) // :number | undefined\nconst newUserUsername = getUsername(newUser) // :string | undefined\n\nconst nextUser = composeSetter('username')(newUser, 'foobar')\nconst nextUserUsername = nextUser.username // :string | undefined\n*/","/**\n * @module utils\n */\n/**\n * Don't ask. I was experimenting with point-free. Basically:\n * - We get (a, b)\n * - Then apply f((a, b)) wich gives use (a -> c)\n * - and so we apply a to that to return c\n *\n *  fromAandBToC :: ( (a, b) -> a -> c) -> (a, b) -> c\n */\nimport { first } from './tuple'\n\nexport const fromAandBToC = <A, B, C>(f: (ab: [A, B]) => (a: A) => C) => (\n  ab: [A, B]\n) => f(ab)(first(ab));\n\n\n\nexport * from './array'\nexport * from './observable'\nexport * from './tuple'\nexport * from './getset'\nexport * from './assert'\nexport * from './function'\nexport * from './types'","/**\n * @module utils\n */\n\nimport { F } from './types'\n\n/**\n * Tuple. Array with 2 elements.\n */\nexport type Tuple<A, B> = [A, B]\n\n/**\n * Thruple. Array with 3 elements\n */\nexport type Thruple<A, B, C> = [A, B, C]\n\n/**\n * ```hs\n * first :: (a, b) -> a\n * ```\n * \n * @typeparam A The type of the first element in the tuple.\n * @params [a] The tuple\n * @returns The first element in a tuple.\n */\nexport const first = <A>([a]: [A, any] | readonly [A, any]): A => a;\n\n\n/**\n * ```hs\n * thirst :: (a, b, c) -> a\n * ```\n * \n * Returns the first element in a thruple.\n */\nexport const thirst = <A>([a]: [A, any, any] | readonly [A, any, any]) => a;\n\n/**\n * Returns the second element in a tuple.\n *\n * ```hs\n * second :: ( (a, b) -> b)\n * ```\n */\nexport const second = <B>([, b]: [any, B] | readonly [any, B]) => b;\n\n/**\n * ```hs\n * threcond :: (a, b, c) -> b\n * ```\n * \n * Like [[second]]. But for thruples.\n */\nexport const threcond = <B>([, b]: [any, B, any] | readonly [any, B, any]) => b;\n\n/**\n * ```hs\n * tuple :: a -> b -> (a, b)\n * ```\n * \n * Create a tuple given two values.\n */\nexport const tuple = <A, B>(a: A, b: B): Tuple<A, B> => [a, b]\n\n/**\n * ```hs\n * thruple :: a -> b -> c -> (a, b, c)\n * ```\n * \n * Create a thruple given three values.\n */\nexport const thruple = <A, B, C>(a: A, b: B, c: C): [A, B, C] => [a, b, c]\n\n/**\n * ```hs\n * applyToSecond :: (a -> b) -> (t, a) -> (t, b)\n * ```\n * \n * There's gotta be an official name for this.\n * Applies function f to the second element in a tuple.\n * \n */\nexport const applyToSecond = <A, B>(f: F<A, B>) => <T>(t: Tuple<T, A>): Tuple<T, B> => tuple(first(t), f(second(t)))\n","/**\n * @module utils\n */\nimport { tuple } from \"./tuple\";\n\ntype F<A, B> = (a: A) => B;\n\nexport const arrayMap = <A, B>(f: F<A, B>) => (as: A[]) => as.map(a => f(a));\n\n/**\n * ```hs\n * arrayBimap :: (a -> t) -> (a -> u) -> [a] -> [(u, t)]\n * ```\n * @param f\n */\nexport const arrayBimap = <A, T>(f: F<A, T>) => <U>(g: F<A, U>) => (as: A[]) =>\n  as.map(a => tuple(f(a), g(a)));\n\n/**\n * Value alias used to better clearly indicate when\n * passing `true` to `transactionalStateOf`'s third `isTuple` parameter.\n */\nexport const IS_TUPLE = true;\n\n/**\n * ```hs\n * isArray :: boolean -> t | [t] -> boolean\n * ```\n *\n * Wrapper around Array.isArray when working with tuple like data structures.\n *\n * @param dataIsTuple - Whether to conside tuple like data or not.\n */\nexport const isArray = (dataIsTuple: boolean) => <A>(\n  data: A | A[]\n): data is A[] =>\n  Array.isArray(data)\n    ? // Continue if data is an array\n      dataIsTuple && data.length > 0\n      ? // TRUE if we're checking for tuples, data has 1 or more elements, and the first element is also an array\n        // FALSE if we're checking for tuples, data has 1 or more elements, and the first element is **NOT** an array (aka data is a tuple)\n        Array.isArray(data[0])\n      : // TRUE if data has more than zero elements\n        true\n    : // FALSE if data is not an array to begin with\n      false;\n","/**\n * @module utils\n */\nimport { of, concat } from 'rxjs'\nimport { delay } from 'rxjs/operators'\n\n/**\n * ```hs\n * mapToAfterMs :: b -> number -> a -> Observable a | b\n * ```\n * \n * @param to Value to emit first\n * @param ms Delay second value by number of milliseconds\n */\nexport const mapToAfterMs = <B>(to: B, ms: number = 1000) => <A>(from: A) =>\n  concat(of(from), of(to).pipe(delay(ms)));\n\n/**\n * ```hs\n * toNullAfterMs :: number -> b -> Observable null | b\n * ```\n * \n * @param ms Delay second value by number of milliseconds\n */\nexport const toNullAfterMs = (ms = 1000) => mapToAfterMs(null, ms);\n","/**\n * @module utils\n */\n/**\n * isNotNull :: a | null -> a asserted\n * \n * Filter nullable types from an array\n * \n * @param value The nullable value to be checked\n */\nexport const isNotNull = <T>(value: T | null): value is T => value != null;\n\n/**\n * take :: number -> [a] -> [a]\n * \n * Take a number of elements from a list.\n * \n * @param amount The number of elements to take.\n */\nexport const take = (amount: number) => <T>(xs: T[]) => {\n  const txs: T[] = [];\n  const len = xs.length;\n\n  for (let i = 0; i < len && i < amount; i += 1) {\n    txs.push(xs[i]);\n  }\n\n  return txs;\n};\n","/**\n * @module utils\n */\n/**\n * ```hs\n * once :: (a -> b) -> (a -> b)\n * ```\n * @typeparam A The funtions argument type.\n * @typearam B The functions return type.\n * @param f The function\n * @returns A version of function `f` that will only run once.\n */\nexport const once = <A, B>(f: (a: A) => B) => {\n  let output: B | undefined;\n\n  return (a: A) => {\n    if (!output) {\n      output = f(a);\n    }\n\n    return output;\n  };\n};\n\n/**\n * ```hs\n * identity :: a -> a\n * ```\n * \n * @typeparam T The type of value taken and returned.\n * @param value The value to return\n * @returns The same value that was passed as the argument.\n *\n * Identify function\n */\nexport const identity = <T>(value: T) => {\n  return value;\n};\n\n/**\n * ```hs\n * compose :: (b -> c) -> (a -> b) -> c\n * ```\n * Read as \"f\" after \"g\"\n * @typeparam A The first function argument taken.\n * @typeparam B The result type of function `g` and argument for function `f`\n * @typeparam C The result type of function `f`\n * @params f The function to pass the result of function `g` to\n * @params g Function that computes the first result `B`\n * @returns A function that takes `A` and returns `C` by applying output of `g` to `f`\n *\n * Function composition. f after g. g andThen f\n */\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) =>\n  f(g(a));\n\n/**\n * ```hs\n * flip :: (a -> b -> c) -> (b -> a -> c)\n * ```\n * @param f \n */\nexport const flip = <A, B, C>(f: (a: A, b: B) => C) => (b: B, a: A) => f(a, b)\n\n\n/**\n * TODO\n * @param f \n */\nexport const curry = <A, B, C>(f: (a: A, b: B) => C) => (a: A) => (b: B) => f(a, b)\n","/**\n * @module todo\n */\nimport { Operation, Noop, Bad } from \"../operations\";\n\n/**\n * Todo model\n */\nexport type Todo = {\n  readonly id: number;\n  readonly title: string;\n  // userId: number;\n  readonly completed: boolean;\n};\n\n/**\n * Type describing operational state for a new todo.\n */\nexport type NewTodoOperation = Operation<string, void>;\n\n/**\n * Type alias describing those parts of a todo that are user editable.\n */\nexport type MutableTodo = Pick<Todo, \"completed\" | \"title\">;\n\n/**\n * Union type of event types that are in use for operational state.\n */\nexport type OperationalEventTypes = EventType.Save | EventType.Delete;\n\n/**\n * Type describing operational data in relation to editing, saving, and or removing todos.\n */\nexport type TodoOperation = Operation<MutableTodo, Todo, OperationalEventTypes>;\n\n/**\n * Event types that are dispatched to thee events$ sink.\n */\nexport enum EventType {\n  Fetch = \"Fetch\",\n  Edit = \"Edit\",\n  Save = \"Save\",\n  Delete = \"Delete\"\n}\n\n/**\n * Event describing todo's should be requested from the server.\n */\nexport type FetchEvent = {\n  type: EventType.Fetch;\n};\n\n/**\n * Event indicating a change to a todo in state should be recorded.\n */\nexport type EditEvent = {\n  type: EventType.Edit;\n  operation: Noop<MutableTodo> | Bad<MutableTodo, OperationalEventTypes>;\n  todo: Todo;\n};\n\n/**\n * Event meant to trigger an API call for saving an event using the API\n */\nexport type SaveEvent = {\n  type: EventType.Save;\n  operation: Noop<MutableTodo> | Bad<MutableTodo, OperationalEventTypes>;\n  todo: Todo;\n};\n\n/**\n * Event indicating the user wants to delete an event from state and the database.\n */\nexport type DeleteEvent = {\n  type: EventType.Delete;\n  todo: Todo;\n};\n\n/**\n * Union type of all event tyeps.\n */\nexport type TodoEvent = FetchEvent | EditEvent | SaveEvent | DeleteEvent;\n\n/**\n * A tuple:\n * 1. [[Todo]]\n * 2. [[TodoOperation]]\n */\nexport type TodoWithOperation = [Todo, TodoOperation];\n","\nexport enum Status {\n  Noop = \"Noop\",\n  Pending = \"Pending\",\n  Ok = \"Ok\",\n  Bad = \"Bad\"\n}\n\nexport type Noop<T> = {\n  status: Status.Noop;\n  state: T;\n};\n\nexport type Pending<T, A = void> = {\n  status: Status.Pending;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Bad<T, A = void> = {\n  status: Status.Bad;\n  state: T;\n  error: string;\n} & (A extends void ? {} : { action: A });\n\nexport type Ok<T, A = void> = {\n  status: Status.Ok;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Operation<T, U = T, A = void> =\n  | Noop<T>\n  | Pending<T, A>\n  | Bad<T, A>\n  | (U extends void ? Noop<T> : Ok<U, A>);\n\n","import { Status, Noop, Pending, Bad } from './types'\n\n// Assertions\nconst makeIsStatus = <T extends Status>(statusType: T) => (\n  checkedStatus: Status\n): checkedStatus is T => statusType === checkedStatus;\n\nexport const statusTypeIsOk = makeIsStatus(Status.Ok);\nexport const statusTypeIsBad = makeIsStatus(Status.Bad);\nexport const statusTypeIsNoop = makeIsStatus(Status.Noop);\nexport const statusTypeIsPending = makeIsStatus(Status.Pending);\n\n// type Foo = <S, O extends Operation<S>, A extends O['status']>\n\nexport const makeIsOperationOfStatus = <S extends Status>(\n  f: (statusType: Status) => statusType is S\n) => <O extends { status: Status }>(\n  operation: O\n): operation is Extract<O, { status: S }> => f(operation.status);\n\nexport const isOk = makeIsOperationOfStatus(statusTypeIsOk);\nexport const isBad = makeIsOperationOfStatus(statusTypeIsBad);\nexport const isNoop = makeIsOperationOfStatus(statusTypeIsNoop);\nexport const isPending = makeIsOperationOfStatus(statusTypeIsPending);\n\nexport const makeNoop = <T>(state: T): Noop<T> => {\n  return {\n    status: Status.Noop,\n    state\n  };\n};\n\n// export const toPendingWithAction = <T, A, B extends A>(operation: Noop<T> | Bad<T, A>, action: B): Pending<T, B> => toPending(operation, action)\n\nexport function toPending<T>(operation: Noop<T> | Bad<T>): Pending<T>;\nexport function toPending<T, A>(\n  operation: Noop<T> | Bad<T, A>,\n  action: A\n): Pending<T, A>;\nexport function toPending<T, A>(\n  operation: Noop<T> | Bad<T, A>,\n  action?: A\n): Pending<T, any> {\n  if (action != null) {\n    return {\n      status: Status.Pending,\n      state: operation.state,\n      action\n    };\n  }\n\n  return {\n    status: Status.Pending,\n    state: operation.state\n  };\n}\n","import * as React from \"react\";\nimport { Todo, MutableTodo } from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\nimport {\n  Status,\n  statusTypeIsPending,\n  statusTypeIsBad,\n  statusTypeIsOk\n} from \"../../../modules/operations\";\nimport { Typography } from \"rmwc\";\n\nexport type PropsItem = {\n  todo: Todo;\n  status: Status;\n  error?: string;\n  onEdit: (state: Partial<MutableTodo>) => void;\n  onSave: (state?: Partial<MutableTodo>) => void;\n  isDeleting: boolean;\n};\n\nexport const Item = (props: PropsItem) => (\n  <>\n    <R.ListItem\n      title={props.todo.title}\n      style={{\n        opacity: props.isDeleting ? 0.5 : 1,\n        transition: \"opacity 0.2s ease-in-out\"\n      }}\n    >\n      <R.ListItemGraphic\n        icon={{\n          icon: props.todo.completed\n            ? \"check_circle_outline\"\n            : \"radio_button_unchecked\",\n          theme: props.todo.completed ? \"primary\" : undefined,\n          onClick: () => props.onSave({ completed: !props.todo.completed })\n        }}\n      />\n      <R.ListItemText>\n        <R.ListItemPrimaryText theme=\"secondary\">\n          {props.todo.title}\n        </R.ListItemPrimaryText>\n        <R.ListItemSecondaryText\n          theme={props.error ? \"error\" : undefined}\n          style={{ fontStyle: \"italic \" }}\n        >\n          {props.error ? (\n            props.error\n          ) : props.status && statusTypeIsPending(props.status) ? (\n            props.isDeleting ? (\n              \"...deleting\"\n            ) : (\n              \"...saving\"\n            )\n          ) : props.todo.completed ? (\n            <Typography theme=\"primary\" use=\"caption\">\n              You're a go-getter!\n            </Typography>\n          ) : (\n            <Typography use=\"caption\">Start working on it!</Typography>\n          )}\n        </R.ListItemSecondaryText>\n      </R.ListItemText>\n      <R.ListItemMeta\n        icon={\n          props.status == null ? (\n            \"\"\n          ) : statusTypeIsPending(props.status) ? (\n            <R.CircularProgress theme=\"secondary\" />\n          ) : statusTypeIsBad(props.status) ? (\n            { icon: \"error\", theme: \"error\" }\n          ) : statusTypeIsOk(props.status) ? (\n            { icon: \"check\", theme: \"primary\" }\n          ) : (\n            \"\"\n          )\n        }\n      />\n    </R.ListItem>\n    <R.ListDivider />\n  </>\n);\n","export enum FilterType {\n  All = \"All\",\n  Active = \"Active\",\n  Completed = \"Completed\"\n}\n","import * as React from \"react\";\n\nimport {\n  List,\n  ListItem,\n  ListItemGraphic,\n  ListItemPrimaryText,\n  ListItemSecondaryText,\n  ListItemMeta,\n  ListDivider,\n  ListItemText\n} from '@rmwc/list'\n\nimport { Snackbar, SnackbarAction } from '@rmwc/snackbar'\n\nimport {CircularProgress} from '@rmwc/circular-progress'\nimport {TextField} from '@rmwc/textfield'\n\nimport {\n  Todo,\n  TodoOperation,\n  NewTodoOperation,\n  MutableTodo,\n  EventType\n} from \"../../../modules/todo/types\";\n\nimport { Item } from \"./Item\";\nimport { isOk, isPending, isBad } from \"../../../modules/operations\";\nimport { noop } from \"rxjs\";\n\nexport const renderList = (props: PropsList) =>\n  props.todos.map(([todo, operation]) => {\n    return (\n      <Item\n        key={todo.id}\n        todo={todo}\n        onEdit={props.onEdit(todo, operation)}\n        onSave={props.onSave(todo, operation)}\n        status={operation && operation.status}\n        isDeleting={\n          isPending(operation) && operation.action === EventType.Delete\n        }\n        error={(operation && isBad(operation) && operation.error) || undefined}\n      />\n    );\n  });\n\nexport type PropsList = {\n  todos: [Todo, TodoOperation][];\n  onEdit: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state: Partial<MutableTodo>) => void;\n  onSave: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state?: Partial<MutableTodo>) => void;\n  new: NewTodoOperation;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n};\n\nexport default (props: PropsList) => {\n  const newTodo = props.new;\n\n  const onChangeNew = isOk(newTodo)\n    ? noop\n    : (evt: React.FormEvent<HTMLInputElement>) => {\n        props.onChangeNew(evt.currentTarget.value);\n      };\n\n  const snack = isBad(props.new) ? (\n    <Snackbar\n        icon={{icon: 'error', theme: 'secondary'}}\n        open\n        theme='primaryBg'\n        style={{background: 'var(--mdc-theme-primary)'}}\n        message={props.new.error}\n      />\n  ) : null\n\n  return (\n    <List className=\"todo-list\" twoLine>\n      <ListItem>\n        <ListItemGraphic\n          title={\"Mark all as complete.\"}\n          icon={{ icon: \"keyboard_arrow_down\", onClick: props.onCompleteAll }}\n          theme=\"secondary\"\n        />\n        {isPending(props.new) ? (\n          <>\n            <ListItemText>\n              <ListItemPrimaryText theme=\"secondary\">\n                {props.new.state}\n              </ListItemPrimaryText>\n              <ListItemSecondaryText style={{ fontStyle: \"italic \" }}>\n                ...busy\n              </ListItemSecondaryText>\n            </ListItemText>\n            <ListItemMeta\n              icon={\n                props.new.status == null ? (\n                  \"\"\n                ) : isPending(props.new) ? (\n                  <CircularProgress theme=\"secondary\" />\n                ) : isBad(props.new) ? (\n                  { icon: \"error\", theme: \"error\" }\n                ) : isOk(props.new) ? (\n                  { icon: \"check\", theme: \"primary\" }\n                ) : (\n                  \"\"\n                )\n              }\n            />\n          </>\n        ) : (\n          <TextField\n            fullwidth\n            theme=\"textPrimaryOnDark\"\n            placeholder=\"Where do you want to go today?\"\n            style={{ height: \"100%\" }}\n            onChange={onChangeNew}\n            value={props.new.state || \"\"}\n            onKeyUp={evt => evt.keyCode === 13 && props.onSubmitNew()}\n            autoFocus\n            trailingIcon={\n              isBad(props.new) ? { icon: \"error\", theme: \"error\" } : undefined\n            }\n          />\n        )}\n      </ListItem>\n      <ListDivider />\n      {renderList(props)}\n      {snack}\n    </List>\n  );\n};\n","import * as React from \"react\";\nimport { Typography } from \"@rmwc/typography\";\n\nconst style: React.CSSProperties = { textAlign: \"center\", marginTop: 15 };\n\nexport default () => (\n  <div style={style}>\n    <Typography use=\"headline1\" theme=\"secondary\">\n      todos\n    </Typography>\n  </div>\n);\n","/**\n * Helper functions to assert [[FilterType]]s\n */\n\nimport { FilterType } from \"./types\";\n\n/**\n * ```hs\n * makeIsFilterType :: (FilterType a) => a -> FilterType -> boolean\n * ```\n * Creates a function that compares filter types and asserts they are\n * of the same type.\n *\n * @typeparam T An instance of [[FilterType]]\n * @param of [[FilterType]] to compare against\n * @returns A function that will compare filter types.\n */\nexport const makeIsFilterType: <T extends FilterType>(\n  of: T\n) => (filterType: FilterType) => filterType is T = <T extends FilterType>(\n  of: T\n) => (filterType: FilterType): filterType is T => filterType === of;\n\n/**\n * ```hs\n * isFilterTypeAll :: FilterType -> boolean\n * ```\n * Asserts that a given filter type equals [[FilterType.All]]\n *\n * @param filterType [[FilterType]] to compare.\n * @returns `filterType is FilterType.ALL`, `true`\n * if the given filter type equals [[FilterType.All]]\n */\nexport const isFilterTypeAll: (\n  filterType: FilterType\n) => filterType is FilterType.All = makeIsFilterType(FilterType.All);\n\n/**\n * ```hs\n * isFilterTypeCompleted :: FilterType -> boolean\n * ```\n * Asserts that a given filter type equals [[FilterType.Completed]]\n *\n * @param filterType [[FilterType]] to compare.\n * @returns `filterType is FilterType.ALL`, `true`\n * if the given filter type equals [[FilterType.Completed]]\n */\nexport const isFilterTypeCompleted: (\n  filterType: FilterType\n) => filterType is FilterType.Completed = makeIsFilterType(\n  FilterType.Completed\n);\n\n/** \n * ```hs\n * isFilterTypeActive :: FilterType -> boolean\n * ```\n * Asserts that a given filter type equals [[FilterType.Active]]\n *\n * @param filterType [[FilterType]] to compare.\n * @returns `filterType is FilterType.ALL`, `true` if\n * the given filter type equals [[FilterType.Active]]\n */\nexport const isFilterTypeActive: (\n  filterType: FilterType\n) => filterType is FilterType.Active = makeIsFilterType(FilterType.Active);\n","/**\n * @module transactions\n */\n\n/**\n * Type of transaction you might apply to a dataset\n */\nexport enum TransactionType {\n  Update = \"Update\",\n  Remove = \"Remove\",\n  Add = \"Add\"\n}\n\n/**\n * A [[TransactionType]] combined with a payload.\n */\nexport type TransactionLike<T, P> = {\n  type: T;\n  payload: P;\n};\n\n/**\n * A transaction decribing the dataset should update an existing\n * piece of data with information in this transaction's payload.\n */\nexport type Update<T> = TransactionLike<TransactionType.Update, T>;\n\n/**\n * A transaction decribing the dataset should remove an existing\n * piece of data matching transaction's payload.\n */\nexport type Remove<T> = TransactionLike<TransactionType.Remove, T>;\n\n/**\n * A transaction decribing the dataset should add a new piece\n * of data that is this transaction's payload.\n */\nexport type Add<T> = TransactionLike<TransactionType.Add, T>;\n\n/**\n * An [[Add]], [[Update]], or [[Remomve]] transaction\n */\nexport type Transaction<A, U = A, R = A> = Add<A> | Update<U> | Remove<R>;\n\n/**\n * Type describing data used in transactions for data sets that are lists\n */\nexport type Transactional<T> = T[] | T;\n","import { Todo, TodoOperation, TodoWithOperation } from \"../todo\";\nimport { FilterType } from \"./types\";\nimport { isFilterTypeCompleted, isFilterTypeActive } from \"./assert\";\n\n/**\n * ```hs\n * makeFilterTodosByFilterType :: (FilterType a) => [Todo] -> [Todo]\n * ```\n * @param filterType Type of filter to create a filter function for.\n * @returns A function that filters given [[Todo]]s by the provided type.\n */\nexport const makeFilterTodosByFilterType = <T extends FilterType>(\n  filterType: T\n) => (todos: [Todo, TodoOperation][]) =>\n  filterType === FilterType.All\n    ? todos\n    : todos.filter(\n        ([todo]) =>\n          (isFilterTypeCompleted(filterType) && todo.completed) ||\n          (isFilterTypeActive(filterType) && !todo.completed)\n      );\n\n/**\n * ```hs\n * filterCompletedTodos :: [TodoWithOperation] -> [TodoWithOperation]\n * ```\n * @param todos List of [[Todo]]s to be filtered\n * @returns List of todos that are all complete.\n */\nexport const filterCompletedTodos = makeFilterTodosByFilterType(\n  FilterType.Completed\n);\n\n/**\n * ```hs\n * filterActiveTodos :: [TodoWithOperation] -> [TodoWithOperation]\n * ```\n * @param todos List of [[Todo]]s to be filtered\n * @returns List of todos that are all active.\n */\nexport const filterActiveTodos: (\n  todos: TodoWithOperation[]\n) => TodoWithOperation[] = makeFilterTodosByFilterType(FilterType.Active);\n","import { Observable, BehaviorSubject } from \"rxjs\";\n\n/**\n * Similar to the what React's `useState` hook returns but for observables.\n * It's a thruple containing:\n *  - 0: A stateful observable  (see RxJS' `BehaviourSubject`)\n *  - 1: A function to update/set the state (`$.next(..)`)\n *  - 2. A get state function. (`$.getValue()`)\n */\nexport type StateObservable<T, U = T> = readonly [\n  Observable<U>,\n  (next: T) => void,\n  () => T\n];\n\n/**\n * Either [[StateObservable]] or [[Observable]]\n */\nexport type ObservableLike<T> = StateObservable<T> | Observable<T>;\n\n/**\n * ```hs\n * isStateObservable :: ObservableLike a -> boolean\n * ```\n * Determines if the given observable like value is a [[StateObservable]]\n */\nexport const isStateObservable = <T>(\n  observable$: ObservableLike<T>\n): observable$ is StateObservable<T> => Array.isArray(observable$);\n\n/**\n * ```hs\n * stateOf :: a -> StateObservable a\n * ```\n * Create a stateful observable. Uses RxJS' `BehaviourSubject` under the hood.\n * \n * @typeparam T Type describing the type of the data stored.\n * @param initialState Initial state of the observable (see [[BehaviourSubject]])\n */\nexport const stateOf = <T>(\n  initialState: T,\n): StateObservable<T> => {\n  // Create a new subject that will stream the state\n  const subject = new BehaviorSubject<T>(initialState);\n\n  // subject.subscribe(console.error)\n  const setState = (state: T) => {\n    subject.next(state);\n  };\n\n  const getCurrentState = () => subject.getValue();\n\n  return [\n    subject.asObservable(),\n    setState,\n    getCurrentState\n  ] as const;\n};\n","/**\n * @module transactions\n */\nimport { TransactionType } from './types'\n\n/**\n * makeTransactionMaker :: TransactionType -> a -> Add a\n * \n * Creates a function for creating transaction objects of a specific type.\n * It is a curried function combining transaction type and payload in to a transaction object.\n * \n * @param type The type of transaction\n */\nconst makeTransactionMaker = <T extends TransactionType>(type: T) => <P>(payload: P) => ({type, payload})\n\n\n/**\n * makeAddTransaction :: p -> Add p\n * \n * Creates an [[Add]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeAddTransaction = makeTransactionMaker(TransactionType.Add)\n\n/**\n * makeUpdateTransaction :: p -> Remove p\n * \n * Creates an [[Update]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeUpdateTransaction = makeTransactionMaker(TransactionType.Update)\n\n/**\n * makeRemoveTransaction :: p -> Remove p\n * \n * Creates an [[Remove]] [[Transaction]] object for a given payload.\n * \n * @param payload The transaction payload. \n */\nexport const makeRemoveTransaction = makeTransactionMaker(TransactionType.Remove)","/**\n * @module transactions\n */\nimport { isArray } from \"../utils\";\n\nimport { TransactionLike, TransactionType } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\n/**\n * add :: (a -> a -> boolean) -> boolean - [a] -> Update a -> [a]\n *\n * Add data to state (a list of T) given the payload of an [[Add]] transaction\n * and return the next state.\n */\nexport const add = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Add, T | T[]>\n) => {\n  const data = dataIsTuple\n    ? [\n        ...state,\n        ...(isArray(dataIsTuple)(transaction.payload)\n          ? transaction.payload\n          : [transaction.payload])\n      ]\n    : state.concat(transaction.payload);\n  return data;\n};\n\n/**\n * update :: (a -> a -> boolean) -> boolean -> [a] -> Update a -> [a]\n *\n * Update data in state (a list of T) given the payload of an [[Update]] transaction\n * and return the next state.\n */\nexport const update = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Update, T | T[]>\n) => {\n  const next = [...state];\n  const data = isArray(dataIsTuple)(transaction.payload)\n    ? transaction.payload\n    : [transaction.payload];\n\n  data.forEach(record => {\n    const index = next.findIndex(r => isEqual(r, record));\n\n    if (index >= 0) {\n      next.splice(index, 1, record);\n    } else {\n      next.push(record);\n    }\n  });\n  return next;\n};\n\n/**\n * remove :: (a -> a -> boolean) -> boolean -> [a] -> Remove a -> [a]\n *\n * Remove data from state (a list of T) given the payload of an [[Remove]] transaction\n * and return the next state.\n */\nexport const remove = <T>(\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  dataIsTuple = false\n) => (state: T[]) => (\n  transaction: TransactionLike<TransactionType.Remove, T | T[]>\n) => {\n  const data = isArray(dataIsTuple)(transaction.payload)\n    ? [...transaction.payload]\n    : [transaction.payload];\n\n  return state.filter(record => {\n    const index = data.findIndex(data => isEqual(record, data));\n    if (index >= 0) {\n      data.splice(index, 1);\n      return false;\n    }\n\n    return true;\n  });\n};\n","import { stateOf } from \"../../modules/state\";\n\nimport { FilterType } from \"./types\";\n\n/**\n * ```hs\n * filterTypeState :: StateObservable FilterType\n * ```\n * Stateful observable for storing and emiting\n * the user's selected filter type by which\n * listed [[Todo]]s in the UI are filtered.\n */\nexport const filterTypeState$ = stateOf(FilterType.All);\n\n","import * as React from \"react\";\n\nimport { Chip, ChipSet } from \"@rmwc/chip\";\n\nimport {\n  FilterType,\n  isFilterTypeAll,\n  isFilterTypeActive,\n  isFilterTypeCompleted\n} from \"../../../modules/filter-todo\";\n\nexport interface PropsFilter {\n  filterType: FilterType;\n  onChangeFilterType: (filterType: FilterType) => void;\n}\n\n// Exports\nexport default (props: PropsFilter) => (\n  <ChipSet choice style={{ justifyContent: \"center\" }}>\n    <Chip\n      label=\"All\"\n      theme={isFilterTypeAll(props.filterType) ? \"secondaryBg\" : undefined}\n      onClick={() => props.onChangeFilterType(FilterType.All)}\n    />\n    <Chip\n      label=\"Active\"\n      icon=\"radio_button_unchecked\"\n      theme={isFilterTypeActive(props.filterType) ? \"secondaryBg\" : undefined}\n      onClick={() => props.onChangeFilterType(FilterType.Active)}\n    />\n    <Chip\n      label=\"Completed\"\n      icon=\"check_circle_outline\"\n      theme={\n        isFilterTypeCompleted(props.filterType) ? \"secondaryBg\" : undefined\n      }\n      onClick={() => props.onChangeFilterType(FilterType.Completed)}\n    />\n  </ChipSet>\n);\n","import * as React from \"react\";\nimport { Typography } from \"@rmwc/typography\";\nimport { Button } from \"@rmwc/button\";\n\nimport {\n  Todo,\n  TodoOperation,\n  NewTodoOperation,\n  MutableTodo\n} from \"../../modules/todo/types\";\n\nimport { FilterType } from \"../../modules/filter-todo\";\n\nimport List from \"./components/List\";\nimport Title from \"./components/Title\";\nimport Filter from \"./components/Filter\";\n\nexport interface PropsTodo {\n  todos: [Todo, TodoOperation][];\n  filterType: FilterType;\n  new: NewTodoOperation;\n  onChangeFilterType: (filterType: FilterType) => void;\n  onEdit: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state: Partial<MutableTodo>) => void;\n  onSave: (\n    todo: Todo,\n    operation: TodoOperation\n  ) => (state?: Partial<MutableTodo>) => void;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n  onClearComplete: () => void;\n}\n\nexport default (props: PropsTodo) => {\n  const list = (\n    <List\n      todos={props.todos}\n      onEdit={props.onEdit}\n      onSave={props.onSave}\n      onChangeNew={props.onChangeNew}\n      new={props.new}\n      onSubmitNew={props.onSubmitNew}\n      onCompleteAll={props.onCompleteAll}\n    />\n  );\n\n  const clearBtn = (\n    <div>\n      <Button onClick={props.onClearComplete}>Clear completed</Button>\n    </div>\n  );\n\n  const filterChips = (\n    <Filter\n      filterType={props.filterType}\n      onChangeFilterType={props.onChangeFilterType}\n    />\n  );\n\n  const footer = (\n    <Typography use=\"caption\" style={{ color: \"#999  \" }}>\n      <strong>{props.todos.filter(([todo]) => !todo.completed).length}</strong>{\" \"}\n      item left\n    </Typography>\n  );\n\n  return (\n    <>\n      <Title />\n      <section className=\"todoapp\">\n        <section className=\"main\">{list}</section>\n        <footer className=\"footer\" style={{ textAlign: \"center\" }}>\n          {filterChips}\n          {clearBtn}\n          {footer}\n        </footer>\n      </section>\n    </>\n  );\n};\n","import * as React from \"react\";\n\nimport { IconButton } from \"@rmwc/icon-button\";\nimport { Slider } from \"@rmwc/slider\";\n\nexport interface PropsControls {\n  index: number;\n  max: number;\n  setIndex: (index: number) => void;\n  play: () => void;\n  pause: () => void;\n}\n\nexport default (props: PropsControls) => (\n  <div style={{ padding: 15 }}>\n    <Slider\n      value={props.index}\n      // onChange={evt => setIndex(evt.detail.value)}\n      onInput={evt => {\n        props.setIndex(evt.detail.value);\n      }}\n      discrete\n      start={0}\n      max={props.max}\n      step={1}\n    />\n    <div className=\"controls\">\n      <IconButton\n        theme={props.index === 0 ? undefined : \"secondary\"}\n        icon=\"fast_rewind\"\n        onClick={() => props.setIndex(0)}\n        disabled={props.index === 0}\n      />\n      <IconButton\n        theme={props.index === 0 ? undefined : \"secondary\"}\n        icon=\"skip_previous\"\n        onClick={() => props.setIndex(props.index - 1)}\n        disabled={props.index === 0}\n      />\n      <IconButton theme=\"secondary\" icon=\"stop\" onClick={props.pause} />\n      <IconButton\n        theme=\"secondary\"\n        icon=\"play_circle_filled\"\n        onClick={props.play}\n      />\n      <IconButton\n        theme={props.index === props.max ? undefined : \"secondary\"}\n        icon=\"skip_next\"\n        onClick={() => props.setIndex(props.index + 1)}\n        disabled={props.index === props.max}\n      />\n      <IconButton\n        theme={props.index === props.max ? undefined : \"secondary\"}\n        icon=\"fast_forward\"\n        onClick={() => props.setIndex(props.max)}\n        disabled={props.index === props.max}\n      />\n    </div>\n  </div>\n);\n","import * as React from \"react\";\n\nimport { CircularProgress } from \"@rmwc/circular-progress\";\n\nconst styles: React.CSSProperties = {\n  flex: \"1 1 auto\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\"\n};\n\nexport default () => (\n  <div style={styles}>\n    <div>\n      <CircularProgress theme=\"secondary\" size={\"large\"} />\n    </div>\n  </div>\n);\n","/**\n * @module todo\n */\nimport { URL } from \"./constants\";\n\n// Todo\nimport { Todo, MutableTodo, TodoOperation, EventType } from \"./types\";\n\n// Operations\nimport { Ok, Bad, Status, Pending, Noop } from \"../operations\";\n\n// Utilities\nimport { take } from \"../utils\";\n\n/**\n * Mock database of Toods\n */\nlet todos: Todo[] = [];\n\n/**\n * Pattern of booleans used to to randomly fail API calls.\n */\nconst failPattern = [true, false, false, true, true, false, true];\n\n/**\n * Mutuable pointer referencing a boolean in [[failPattern]]\n */\nlet failIndex = 0;\n\n/**\n * Returns the next \"doFail\" flag and moves the failIndex\n * pointer to the next boolean in [[failPattern]]\n */\nconst getNextFailFlag = () => {\n  failIndex += 1;\n\n  if (failIndex > failPattern.length - 1) {\n    failIndex = 0;\n  }\n\n  return failPattern[failIndex];\n};\n\n/**\n * delay\n * Helper function for creating promise that resolves after `ms` milliseconds.\n *\n * @param ms Number of milliseconds to delay resolving the promise.\n */\nconst delay = (ms: number) =>\n  new Promise<void>(resolve => setTimeout(resolve, ms));\n\nconst randomDelay = () => delay(Math.ceil(Math.random() * 2500))\n\n/** \n * API for loading the list of Todos in the database.\n */\nexport const read = async () => {\n  getNextFailFlag();\n\n  // Only make the network call once since we are mocking things here.\n  if (todos.length <= 0) {\n    const response = await fetch(URL);\n    const json: Todo[] = await response.json();\n    await delay(1500);\n\n    // Replace the database\n    todos = take(6)(json); //.map(todo => ({...todo, completed: false}));\n  }\n  // Return data from our mocked database [[todos]] after 1 second\n  else {\n    await delay(1000);\n  }\n  return todos;\n};\n\n/**\n * API for creating new Todos and storing them in the database.\n * @param operation\n */\nexport const create = async (\n  operation: Pending<string>\n): Promise<Ok<Todo> | Bad<string>> => {\n  const doFail = getNextFailFlag();\n\n  const title = operation.state.trim()\n  \n  if (!title) {\n    return {\n      status: Status.Bad,\n      error: \"A title is required!\",\n      state: operation.state\n    };\n  }\n  \n  await randomDelay();\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state\n    };\n  }\n\n  const exists = todos.find(todo => todo.title === title)\n\n  if (exists) {\n    return {\n      status: Status.Bad,\n      error: \"A task with this title alreay exists!\",\n      state: operation.state\n    };\n  }\n\n  const todo = {\n    id: Math.floor(Math.random() * 10000),\n    userId: Math.floor(Math.random() * 10000),\n    title: operation.state,\n    completed: false\n  };\n\n  todos = [...todos, todo];\n\n  return {\n    status: Status.Ok,\n    state: todo\n  };\n};\n\n/**\n * API for updating Todos in the database\n *\n * @param todo\n * @param operation\n */\nexport const update = async (\n  todo: Todo,\n  operation: Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Save> | Bad<MutableTodo, EventType.Save>> => {\n  await randomDelay();\n  const doFail = getNextFailFlag();\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state,\n      action: EventType.Save\n    };\n  }\n\n  const title = operation.state.title.trim();\n\n  if (!title) {\n    return {\n      status: Status.Bad,\n      action: EventType.Save,\n      error: \"A title is required!\",\n      state: {\n        ...operation.state,\n        title\n      }\n    };\n  }\n\n  const nextTodo = {\n    ...todo,\n    ...operation.state,\n    title\n  };\n\n  todos = todos.map(current => {\n    if (current.id === nextTodo.id) {\n      return nextTodo;\n    }\n\n    return todo;\n  });\n\n  return {\n    status: Status.Ok,\n    state: { ...todo, ...operation.state, title },\n    action: EventType.Save\n  };\n};\n\n/**\n * API for deleting Todo's from the database\n *\n * @param todo\n * @param operation\n */\nexport const deleet = async (\n  todo: Todo,\n  operation: Pending<MutableTodo, EventType.Delete> //Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Delete> | Bad<MutableTodo, EventType.Delete>> => {\n  await randomDelay();\n  const doFail = getNextFailFlag();\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Unable to delete!\",\n      state: operation.state,\n      action: EventType.Delete\n    };\n  }\n\n  todos = todos.filter(current => current.id !== todo.id);\n\n  return {\n    status: Status.Ok,\n    state: todo,\n    action: EventType.Delete\n  };\n};\n","/**\n * @module todo\n */\nexport const URL = 'https://jsonplaceholder.typicode.com/todos/'\n","/**\n * @module todo\n */\nimport {\n  EventType,\n  FetchEvent,\n  TodoEvent,\n  SaveEvent,\n  DeleteEvent,\n  TodoOperation,\n  EditEvent,\n  Todo,\n  OperationalEventTypes\n} from \"./types\";\n\nimport { Noop, Bad } from '../operations'\n\n/**\n * makeFetchEvent\n */\nexport const makeFetchEvent = (): FetchEvent => {\n  return { type: EventType.Fetch };\n};\n\n/**\n * makeEditEvent\n */\n\nexport const makeEditEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): EditEvent => {\n  return { type: EventType.Edit, todo, operation };\n};\n\n/**\n * makeSaveEvent\n */\nexport const makeSaveEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): SaveEvent => {\n  return { type: EventType.Save, todo, operation };\n};\n\n/**\n * makeDeleteEvent\n */\nexport const makeDeleteEvent = (todo: Todo): DeleteEvent => {\n  return { type: EventType.Delete, todo };\n};\n\n/**\n * makeIsEventType\n */\nexport const makeIsEventType = <T extends EventType>(of: T) => (\n  eventType: EventType\n): eventType is T => eventType === of;\n\n/**\n * isFetchEventType\n */\nexport const isFetchEventType = makeIsEventType(EventType.Fetch);\n\n/**\n * isEditEventType\n */\nexport const isEditEventType = makeIsEventType(EventType.Edit);\n\n/**\n * isSaveEventType\n */\nexport const isSaveEventType = makeIsEventType(EventType.Save);\n\n/**\n * isDeleteEventType\n */\nexport const isDeleteEventType = makeIsEventType(EventType.Delete);\n\n/**\n * makeIsEventOfType\n */\nexport const makeIsEventOfType = <A extends EventType>(\n  f: (eventType: EventType) => eventType is A\n) => (event: TodoEvent): event is Extract<TodoEvent, { type: A }> =>\n  f(event.type);\n\n/**\n * isFetchEvent\n */\nexport const isFetchEvent = makeIsEventOfType(isFetchEventType);\n\n/**\n * isEditEvent\n */\nexport const isEditEvent = makeIsEventOfType(isEditEventType);\n\n/**\n * isSaveEvent\n */\nexport const isSaveEvent = makeIsEventOfType(isSaveEventType);\n\n/**\n * isDeleteEvent\n */\nexport const isDeleteEvent = makeIsEventOfType(isDeleteEventType);\n","/**\n * @module todo\n */\nimport { Todo, MutableTodo } from \"./types\";\nimport { get, set } from \"../utils/getset\";\n\n/**\n * @private\n * \n * Constant used for creating empty, new [[Todo]]s\n */\nconst mutuableTodo: MutableTodo = { completed: false, title: \"\" };\n\n/**\n * toMutable :: [[Todo]] -> [[MutableTodo]]\n * \n * Helper function for extracting `completed` and `title` from todos.\n * This is mostly used to create data for operations.\n * \n * @param todo - The todo object to convert.\n */\nexport const toMutable = (todo: Todo): MutableTodo =>\n  setTitle(setCompleted(mutuableTodo)(getCompleted(todo)))(getTitle(todo));\n\n// Experimental code\nexport const getId = get(\"id\");\nexport const getTitle = get(\"title\");\nexport const getCompleted = get(\"completed\");\n\nexport const setId = set(\"id\");\nexport const setTitle = set(\"title\");\nexport const setCompleted = set(\"completed\");\n\n\n","/**\n * @module todo\n */\nimport {\n  EventType,\n  Todo,\n  MutableTodo,\n  SaveEvent,\n  DeleteEvent,\n  TodoWithOperation,\n  TodoOperation\n} from \"./types\";\n\n// Transactions\nimport {\n  Transaction,\n  TransactionType,\n  makeAddTransaction,\n  makeUpdateTransaction,\n  makeRemoveTransaction,\n  Transactional\n} from \"../transactions\";\n\n// Operations\nimport { Ok, Bad, isOk, makeNoop } from \"../operations\";\n\n// Utilities\nimport { toMutable } from \"./utils\";\nimport { tuple } from \"../utils\";\n\n/** Operations that can be reset to Noop */\nexport type ResetableOperation =\n  | Ok<Todo, EventType.Save>\n  | Bad<MutableTodo, EventType.Save | EventType.Delete>;\n\n/* Events that can be done over if there outcome fails. */\nexport type RedoableEvent = SaveEvent | DeleteEvent;\n\n/* Effectful function for updating state */\nexport type Writer = (\n  todos: Transaction<Transactional<TodoWithOperation>>\n) => void;\n\n/**\n * resetOkAndBadTodosEffect :: Write -> (RedoableEvent, ResetableOperation) -> ()\n *  \n * @param writer \n */\nexport const resetOkAndBadTodosEffect = (writer: Writer) => ([\n  event,\n  operation\n]: [RedoableEvent, ResetableOperation]) => {\n  const noop = makeNoop(\n    isOk(operation) ? toMutable(operation.state) : operation.state\n  );\n\n  const transaction = {\n    type: TransactionType.Update,\n    payload: isOk(operation)\n      ? tuple(operation.state, noop)\n      : tuple(event.todo, noop)\n  };\n\n  writer(transaction);\n};\n\n// What I want is:\n// export const add = (write: Writer) => compose(write, makeAddTransaction)\n// or go crazy\n// and make add:\n// curry(flip(compose)(makeAddTransaction))\n// But TypeScript can't handle me\n\nconst makeWriteEffect = (\n  transactionMaker: (\n    data: Transactional<[Todo, TodoOperation]>\n  ) => Transaction<Transactional<[Todo, TodoOperation]>>\n) => (writer: Writer) => (data: Transactional<[Todo, TodoOperation]>) =>\n  writer(transactionMaker(data));\n\nexport const addEffect = makeWriteEffect(makeAddTransaction);\n\nexport const updateEffect = makeWriteEffect(makeUpdateTransaction);\n\nexport const remoteEffect = makeWriteEffect(makeRemoveTransaction);\n\ntype DeleteOutcome =\n  | Ok<Todo, EventType.Delete>\n  | Bad<MutableTodo, EventType.Delete>;\n\nexport const runDeleteOutcomeEffect = (writer: Writer) => (todo: Todo) => (\n  outcome: DeleteOutcome\n) =>\n  isOk(outcome)\n    ? remoteEffect(writer)(tuple(todo, outcome))\n    : updateEffect(writer)(tuple(todo, outcome));\n\ntype SaveOutcome = Ok<Todo, EventType.Save> | Bad<MutableTodo, EventType.Save>;\n\nexport const runSaveOutcomeEffect = (writer: Writer) => (todo: Todo) => (\n  outcome: SaveOutcome\n) => {\n  updateEffect(writer)(\n    tuple(isOk(outcome) ? { ...todo, ...outcome.state } : todo, outcome)\n  );\n};\n\nexport const runCreateOutcomeEffect = (writer: Writer) => (\n  outcome: Ok<Todo> | Bad<string>\n) => {\n  if (isOk(outcome)) {\n    const todoWithOperation = tuple(\n      outcome.state,\n      makeNoop({\n        title: outcome.state.title,\n        completed: false\n      })\n    );\n\n    addEffect(writer)(todoWithOperation);\n  }\n};\n","/**\n * @module todo\n */\n\n// RxJS\nimport { Subject, from, of, EMPTY, concat, Observable } from \"rxjs\";\nimport {\n  tap,\n  map,\n  mergeMap,\n  switchMap,\n  groupBy,\n  timeoutWith,\n  ignoreElements,\n  startWith,\n  delay,\n  filter\n} from \"rxjs/operators\";\n\n// Utilities\nimport {\n  tuple,\n  compose,\n  thruple,\n  identity,\n  IS_TUPLE,\n  arrayBimap\n} from \"../utils\";\n\n// State\nimport { stateOf, StateObservable, transactionalStateOf } from \"../state\";\n\n// API\nimport { read, create, update, deleet } from \"./api\";\n\n// Todo\nimport {\n  TodoEvent,\n  Todo,\n  NewTodoOperation,\n  EventType,\n  SaveEvent,\n  EditEvent,\n  DeleteEvent,\n  FetchEvent,\n  TodoWithOperation\n} from \"./types\";\n\nimport {\n  isFetchEvent,\n  isEditEvent,\n  isSaveEvent,\n  makeFetchEvent\n} from \"./events\";\n\nimport { toMutable } from \"./utils\";\n\n// Operational\nimport { makeNoop, isPending, isBad, toPending, isNoop } from \"../operations\";\n\n// Transaction\nimport { TransactionType, Transactional } from \"../transactions\";\n\n// Effects\nimport {\n  resetOkAndBadTodosEffect,\n  RedoableEvent,\n  ResetableOperation,\n  addEffect,\n  updateEffect,\n  runDeleteOutcomeEffect,\n  runSaveOutcomeEffect,\n  runCreateOutcomeEffect\n} from \"./effects\";\n\n/**\n * @private\n * `Subject` for dispatching and streaming events.\n */\nconst events$ = new Subject<TodoEvent>();\n\n/**\n * ```hs\n * dispatch :: TodoEvent -> ()\n * ```\n *\n * Function for dispatching to the [[events$]] `Subject`\n *\n * @param event An [[EditEvent]], [[SaveEvent]], or [[DeleteEvent]].\n */\nexport const dispatch = (event: TodoEvent) => {\n  console.warn(`Dispatching ${event.type}`);\n  events$.next(event);\n};\n\n/**\n * ```hs\n * dispatchFetch :: () -> void\n * ```\n *\n * Dispatches the [[FetchEvent]] to the [[events$]] `Subject`.\n */\nexport const dispatchFetch = () => dispatch(makeFetchEvent());\n\n/**\n * ```hs\n * [todos$, writeTodos] :: (Observable [[TodoWithOperation[]]], TodoWithOperation -> void)\n * ```\n * \n * Create a transactional [[StateObservable]] allowing us to use the\n * setState function _(in this case named writeTodos)_ to either accept\n * state transactions who's payload is an array of [[TodoWithOperation]]\n * or just a single element.\n */\nexport const [todos$, writeTodos] = transactionalStateOf(\n  [] as TodoWithOperation[],\n  ([todo1], [todo2]) => todo1.id === todo2.id,\n  IS_TUPLE\n);\n\n/**\n * ```hs\n * resetOkAndBadTodos :: Observable (RedoableEvent, ResetableOperation) -> Observable (RedoableEvent, ResetableOperation)\n * ```\n * Operator for resetting a [[Todo]]'s [[TodoOperation]] to [[Noop]]\n * after it was set to [[Bad]] or [[Ok]]\n *\n * @param updateOrDeleteEventAndOperation$\n */\nconst resetOkAndBadTodos = (\n  updateOrDeleteEventAndOperation$: Observable<\n    [RedoableEvent, ResetableOperation]\n  >\n): Observable<[RedoableEvent, ResetableOperation]> =>\n  updateOrDeleteEventAndOperation$.pipe(\n    delay(1000),\n    tap(resetOkAndBadTodosEffect(writeTodos))\n  );\n\n/**\n * ```hs\n * handleEvents$ :: Observable ()\n * ```\n *\n * Main observable for handling incoming events that have been dispatched\n * to the [[events$]] `Subject`. Kind of like a reducer in redux.\n *\n * It groups the events by type [[EventType.Fetch]] or the `id` of the [[Todo]].\n * and uses `switchMap` for each group.\n */\nexport const handleEvents$: Observable<never> = events$.pipe(\n  groupBy(\n    event => {\n      if (isFetchEvent(event)) {\n        return EventType.Fetch;\n      } else {\n        return event.todo.id;\n      }\n    },\n    event => event,\n    actionsByGroup$ =>\n      actionsByGroup$.pipe(\n        timeoutWith(15000, EMPTY),\n        ignoreElements()\n      )\n  ),\n  mergeMap(groupedEvent$ =>\n    groupedEvent$.pipe(\n      switchMap(event => {\n        if (isFetchEvent(event)) {\n          return handleReadEvent(event);\n        } else if (isEditEvent(event)) {\n          return handleEditEvent(event);\n        } else if (isSaveEvent(event)) {\n          return handleSaveEvent(event);\n        }\n\n        return handleDeleteEvent(event);\n      })\n    )\n  ),\n  ignoreElements()\n);\n\n// Because TypeScript is unable to infer this bois abstractions.\ntype Id<T> = (id: T) => T;\n\n/**\n * ```hs\n * handleReadEvent :: FetchEvent -> Observable (Transactional TodoWithOperation)\n * ```\n *\n * Handles incoming [[FetchEvent]] events that have been\n * dispatched to the [[events$]] `Subject`\n *\n * It immediately calls the API for requesting [[Todo]]s from\n * the server and updates state with the received todos\n * by running the [[addEffect]]\n *\n * @param event The [[FetchEvent]] event\n */\nexport const handleReadEvent = (\n  event: FetchEvent\n): Observable<Transactional<TodoWithOperation>> =>\n  from(read()).pipe(\n    // map(arrayMap(curry(tuple))),\n    map(\n      arrayBimap(identity as Id<Todo>)(\n        // f after g\n        compose(\n          makeNoop, // f\n          toMutable // g\n        )\n      )\n    ),\n    tap(addEffect(writeTodos))\n  );\n\n/**\n * Handle incoming events requesting [[Todo]](s) be deleted\n * from the database.\n *\n * State is updating first to indicate \"in progress\". Then the\n * API for deleting Todos is called. Once the call re solves\n * state is updated to indicate failure or success. After a second\n * state is updated once again to reset the operation so that the\n * UI removes the indicators of failure or success.\n *\n * @param event - The delete event [[DeleteEvent]]\n */\nconst handleDeleteEvent = (\n  event: DeleteEvent\n): Observable<\n  Transactional<TodoWithOperation | [RedoableEvent, ResetableOperation]>\n> => {\n  const operation = toPending(\n    makeNoop(toMutable(event.todo)),\n    // @ts-ignore\n    EventType.Delete as const\n  );\n\n  const promise = deleet(event.todo, operation);\n\n  return concat(\n    of(tuple(event.todo, operation)).pipe(tap(updateEffect(writeTodos))),\n    from(promise).pipe(\n      tap(runDeleteOutcomeEffect(writeTodos)(event.todo)),\n      filter(isBad),\n      map(outcome => tuple(event, outcome)),\n      resetOkAndBadTodos\n    )\n  );\n};\n\n/**\n * ```hs\n * handleEditEvent :: EditEvent -> Observable\n * ```\n * \n * Responsds to the [[EditEvent]] dispatched on the [[events$]]\n * `Subject` after the user types to change the title of\n * a [[Todo]]\n *\n * The only effect here is updating state. No API calls\n *\n * @param event [[EditEvent]]\n */\nconst handleEditEvent = (event: EditEvent): Observable<unknown> => {\n  // Reset the Todo's operational status if the user\n  // started editing after a success or failure operation\n  const operation = isNoop(event.operation)\n    ? event.operation\n    : makeNoop(event.operation.state);\n\n  return of(tuple(event.todo, operation)).pipe(tap(updateEffect(writeTodos)));\n};\n\n/**\n * ```hs\n * handleSaveEvent :: SaveEvent -> Observable ?\n * ```\n * \n * Handles incoming [[SaveEvent]] events that have been dispatched to [[event$]]\n *\n * - It first updates state to indicate the [[Todo]] is currently being saved.\n * - Then calls the [[update]] API for mutating existing todos in the database.\n * - Passes the results to [[runSaveOutcomeEffect]] to update state with the updated [[Todo]] and [[TodoOperation]]\n * - The todo's operation is resets after a delay using the [[resetOkAndBadTodos]] operator\n *\n * @param event\n */\nconst handleSaveEvent = (event: SaveEvent): Observable<unknown> => {\n  // @ts-ignore (mitigates a typedoc issue)\n  const operation = toPending(event.operation, EventType.Save as const);\n\n  const updateTransaction = {\n    // @ts-ignore (mitigates a typedoc issue)\n    type: TransactionType.Update as const,\n    payload: tuple(event.todo, operation)\n  };\n\n  const promise = update(event.todo, event.operation);\n\n  return concat(\n    of(void 0).pipe(tap(() => writeTodos(updateTransaction))),\n    from(promise).pipe(\n      tap(runSaveOutcomeEffect(writeTodos)(event.todo)),\n      map(outcome => tuple(event, outcome)),\n      resetOkAndBadTodos\n    )\n  );\n};\n\n/**\n * ```hs\n * (_newTodoOperation$, setNewTodoOperation, getNewTodoOperation) :: StateObservable (Operation string void void)\n * -- aka\n * (_newTodoOperation$, setNewTodoOperation, getNewTodoOperation) :: (Observable (Operation string void void), (Operation string void void) -> void, () -> (Operation string void void))\n * ```\n * I'm destructuring the result of `stateOf` so that I can re-export\n * a piped version of `_newTodoOperation`\n */\nconst [_newTodoOperation$, setNewTodoOperation, getNewTodoOperation] = stateOf(\n  makeNoop(\"\") as NewTodoOperation\n);\n\n/**\n * @private\n * \n * ```hs\n * newTodoOperation$ :: StateObservable (Operation string void void)\n * ```\n * \n * [[StateObservable]] that handles creating a new [[Todo]] for the user.\n * It starts with a [[Noop]] operation of a `string`, the title of the new [[Todo]].\n * \n * Any time the [[StateObservable]]'s `setState` function `setNewTodoOperation` is\n * called the observable's operator checks if the status has changed to [[Pending]]\n * and if so will direct the [[NewTodoOperation]] to the [[create]] API for storing\n * the new todo in the datatabase.\n *\n * Using [[thruple]] to re-export everything as a [[StateObservable]]\n *\n *\n */\nexport const newTodoOperation$: StateObservable<NewTodoOperation> = thruple(\n  _newTodoOperation$.pipe(\n    switchMap(state =>\n      isPending(state)\n        ? from(create(state)).pipe(\n            tap(runCreateOutcomeEffect(writeTodos)),\n            map(nextState => (isBad(nextState) ? nextState : makeNoop(\"\"))),\n            startWith(state)\n          )\n        : of(state)\n    )\n  ),\n  setNewTodoOperation,\n  getNewTodoOperation\n)\n","import { scan } from \"rxjs/operators\";\n\nimport { tuple } from \"../utils\";\nimport { TransactionType, Transaction, update, add, remove } from \"../transactions\";\n\nimport { stateOf } from \"./stateOf\";\n\n/**\n * transactionalStateOf :: t | [t] -> (t -> t -> boolean) -> boolean -> (Observable [t], Transaction t | [t] -> void)\n * \n * Creates a stateful, transactional observable for lists.\n */\nexport const transactionalStateOf = <T>(\n  initialState: T | T[],\n  isEqual: (t1: T, t2: T) => boolean = (t1, t2) => t1 === t2,\n  isTuple: boolean = false\n) => {\n  const initialTransaction: Transaction<T | T[]> = {\n    type: TransactionType.Add,\n    payload: initialState\n  } as any;\n\n\n\n  const [state$, setState] = stateOf(initialTransaction);\n\n  const transactional$ = state$.pipe(\n    scan(\n      (acc, transaction) => {\n        switch (transaction.type) {\n          case TransactionType.Add: {\n            return add(isEqual, isTuple)(acc)(transaction)\n          }\n          case TransactionType.Update: {\n            return update(isEqual, isTuple)(acc)(transaction)\n          }\n\n          case TransactionType.Remove: {\n            return remove(isEqual, isTuple)(acc)(transaction)\n          }\n\n          default:\n            return acc;\n        }\n      },\n      [] as T[]\n    )\n  );\n\n  return tuple(transactional$, setState);\n};\n\n","import {\n  Observable,\n  Subject,\n  combineLatest,\n  BehaviorSubject,\n  of,\n  EMPTY,\n  merge,\n  concat\n} from \"rxjs\";\n\nimport {\n  scan,\n  map,\n  withLatestFrom,\n  tap,\n  delay,\n  switchMap,\n  filter,\n  share\n} from \"rxjs/operators\";\n\nimport { tuple, isNotNull } from \"../utils\";\n\n/**\n * Turns an observable into a time travelable\n * version of itself.\n *\n * It does this by creating a Subject to sink/stream the selected\n * historic index.\n *\n * Then it it creates `stateWithHistory$` which is just using\n * the `scan` operator to keep track of all emitted values.\n *\n * A final `index$` observable is created that only emits\n * index values that are within the bounds of the history\n * array's length.\n *\n * A final `state$` observable is created by combining\n * `index$` and `stateWithHistory$` to either select state\n * from the history array or return the active, current state\n * if the index is `-1`\n *\n * The return value of this function is a thruple of:\n * 0: The final `state$` observable\n * 1: A dispatch function for setting the selected index\n * 2: The `index$` observable emitting both the index and the maximum\n */\nexport const makeTimeTravelable = <T>(observable$: Observable<T>) => {\n  const indexSubject = new BehaviorSubject(-1);\n\n  const stateWithHistory$ = combineLatest(indexSubject, observable$).pipe(\n    scan(\n      ([state, index, history], [nextIndex, nextState]) => {\n        return state !== nextState\n          ? ([\n              nextState,\n              index >= 0 && index + 1 < history.length ? index + 1 : -1,\n              state ? [...history, [state, Date.now()]] : []\n            ] as [T, number, [T, number][]])\n          : ([nextState, nextIndex, history] as [T, number, [T, number][]]);\n      },\n      [undefined, -1, []] as [T | undefined, number, [T, number][]]\n    ),\n    filter((stream): stream is [T, number, [T, number][]] =>\n      isNotNull(stream[0])\n    ),\n    map(([state, index, history]) => {\n      if (index < 0 || index >= history.length) {\n        return [state, history, history.length, history.length] as const;\n      }\n\n      return [history[index][0], history, index, history.length] as const;\n    }),\n    share()\n  );\n\n  const playSubject = new Subject<\"PLAY\" | \"PAUSE\">();\n\n  const replay$ = playSubject.pipe(\n    withLatestFrom(stateWithHistory$),\n    switchMap(([mode, s]) => {\n      if (mode === \"PLAY\") {\n        return concat(of(s), stateWithHistory$).pipe(\n          switchMap(([state, history, index]) => {\n            const timeline = state\n              ? [...history, tuple(state, history[history.length - 1][1] + 250)]\n              : history;\n            const ms =\n              index > 0 && timeline[index + 1]\n                ? timeline[index + 1][1] - timeline[index][1]\n                : 0;\n\n            return of(void 0).pipe(\n              delay(ms > 2500 ? 250 : ms),\n              tap(() => setIndex(timeline[index + 1] ? index + 1 : 0))\n            );\n          })\n        );\n      }\n\n      return EMPTY;\n    })\n  );\n\n  const setIndex = (index: number) => {\n    indexSubject.next(index);\n  };\n\n  const stream$ = merge(replay$, stateWithHistory$).pipe(\n    filter((stream): stream is readonly [T, [T, number][], number, number] =>\n      isNotNull(stream)\n    )\n  );\n\n  return [\n    stream$,\n    setIndex,\n    indexSubject.asObservable(),\n    () => playSubject.next(\"PLAY\"),\n    () => playSubject.next(\"PAUSE\")\n  ] as const;\n};\n","import { newTodoOperation$ } from \"../../modules/todo/observables\";\nimport { createState, makeTimeTravelable } from \"../../modules/state\";\nimport { filterTypeState$ } from \"../../modules/filter-todo\";\nimport { Observable } from \"rxjs\";\n\nimport { todosByFilterType$ } from \"./observables\";\n\n\nexport const state$ = createState({\n  todos: todosByFilterType$,\n  filterType: filterTypeState$,\n  new: newTodoOperation$\n});\n\nexport const [timeTravelableState$, setIndex, _, play, pause] = makeTimeTravelable(\n  state$\n);\n  \nexport type Observed<T> = T extends Observable<infer S> ? S : never;\n\nexport type State = Observed<typeof state$>","import { Observable, combineLatest } from \"rxjs\";\nimport { isStateObservable, ObservableLike } from \"./stateOf\";\nimport { map, tap, share } from \"rxjs/operators\";\n\n/**\n * Returns a type describing all keys of object T\n * that are of type V\n * \n * For example:\n * ```ts\n * type User = { id: number, name: string, age: number }\n * type NumericUserProperties = KeyOfType<User, number> // 'id' | 'age'\n * ```\n */\ntype KeyOfType<T, V> = {\n  [P in keyof T]: T[P] extends V ? P : never;\n}[keyof T];\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they belong to keys in type K\n * \n * For example:\n * ```ts\n * type User = { id: number, name: string, age: number }\n * type UserWithProtectedId = Readonly<User, 'id'>\n * \n * const user: Readonly<User, 'id'> = { id: 24, name: 'Bob', age: 54 }\n * user.age = 55 // no problem here\n * user.id = 77 // should not compile\n * ```\n */\ntype ReadonlyByKey<T extends {}, K extends keyof T> = Readonly<Pick<T, K>> &\n  Omit<T, K>;\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they are of type V\n * \n * For example:\n * ```ts\n * type User = { id: number, name: string, age: number }\n * \n * const user: Readonly<User, number> = { id: 24, name: 'Bob', age: 54 }\n * user.age = 55 // should not compile\n * user.id = 77 // should not compile\n * user.name = \"Alice\" // no problem here\n * ```\n */\ntype ReadonlyByType<T, V> = ReadonlyByKey<T, KeyOfType<T, V>>;\n\n/**\n * An object representing a map of [[Observable]] or [[StateObserveable]]\n */\ntype MapOfObservables = {\n  [prop: string]: ObservableLike<any>;\n};\n\n/**\n * A type representing an objectc, a map of values, based on a map of\n * [[Observable]] or [[StateObservable]] and the values those\n * observable stream.\n *\n * For example\n *\n * ```ts\n * type State = MapOfStateFromMapOfObservables<{\n *  users: Observable<User[]>>,\n *  active: StateObservable<boolean>\n * }\n *\n * // equates to\n *\n * type State = { readonly users: number, active: boolean }\n * ```\n * \n * In this example you are building a state object where\n * `state.users` is immutauble and not controlled by the application\n * while `state.active` is a [[StateObservable]] to which you can\n * not only subscribe to get the \"next\" value of `.active` but also\n * emit to, aka set it's state\n * ```\n *\n */\ntype MapOfStateFromMapOfObservables<T> = {\n  [P in keyof T]: T[P] extends ObservableLike<infer B> ? B : never;\n};\n\n/**\n * [[State$]] describes an `Observable` that is the composition of\n * of a map of observables.\n * \n * See [[MapOfStateFromMapOfObservables]] for more information on\n * the data streamed by this observable.\n *\n */\nexport type State$<T extends MapOfObservables> = Observable<\n  MapOfStateFromMapOfObservables<ReadonlyByType<T, Observable<any>>>\n>;\n\n/**\n * ```hs\n * createState :: MapOfObservables t => MapOfObservables t -> State$ t\n * ```\n * \n * Creates a single state observable from a map of [[ObservableLike]]\n * \n * The keys of `mapOfObservables` are reduced into an array of thruples\n * where each thruple contains:\n * 0 - The key / property being iterated\n * 1 - A _getter_ function for that property\n * 2 _ A _setter_ function for that property\n * \n * Since values on the `mapOfObservables` object are either `Obervable` or\n * [[StateObservable]], the thruple created for both differs slightly in\n * that the _setter_ function for `Observables` logs a warning to the\n * console in development mode since data/state for `Obserable`s is considered\n * immutable.\n * \n * Finally the list of (key, getter, setter) data is reduced into a single object.\n * `Object.defineProperty` is used to decalre `get` and `set` on the accumulated\n * object.\n * \n * See [[MapOfStateFromMapOfObservables]] for more information on\n * the data streamed by this observable.\n * \n * TODO I think this can be simplified with less iterations\n * \n * @param mapOfObservables Map (object) of observables.\n * @returns An observable whos data stream matches the shape of `mapOfObservables`\n * \n */\nexport const createState = <T extends MapOfObservables>(\n  mapOfObservables: T\n): State$<T> => {\n  // Compile a list of keys that are part of the state object.\n  const keys = Object.keys(mapOfObservables);\n\n  // Reduce the list of keys to a list of observables where each observable\n  // is a thruple of the key, getter, and setter.\n  const observables$: Observable<\n    [string, () => any, () => void]\n  >[] = keys.reduce(\n    (acc, key) => {\n      const observable$ = mapOfObservables[key];\n\n      // If the observable is our custom StateObservable\n      if (isStateObservable(observable$)) {\n        // Destructure the StateObservable into it's actual observabble and dispatcher\n        const [state$, setState] = observable$;\n\n        // Map the state$ observable to a thruple of\n        // its key, getter, and setter\n        const nextState$ = state$.pipe(\n          map(state => {\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter\n              (nextState: any) => {\n                setState(nextState);\n              }\n            ];\n          })\n        );\n\n        // Add the composed state observable to the accumulator.\n        acc.push(nextState$);\n      }\n\n      // If the observable was just a regular observable\n      else {\n        const nextState$ = observable$.pipe(\n          map(state => {\n            // Map the state$ observable to a thruple of\n            // its key, getter, and setter\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter that will log an error message in dev mode\n              (value: any) => {\n                if (process.env.NODE_ENV === \"development\") {\n                  console.error(\n                    `Attempting to mutate state \"${key}\" with value \"${value}\" of state with properties ${keys.join(\n                      \", \"\n                    )}`\n                  );\n                }\n              }\n            ];\n          }),\n          tap(_ => console.warn(`Streaming [${key}]`)),\n\n        );\n\n        acc.push(nextState$);\n      }\n      return acc;\n    },\n    [] as any[]\n  );\n\n  // Combine the list of observables of [key, getter, setter]\n  // into a single state observable\n\n  type Key = string;\n  type Getter = () => any;\n  type Setter = () => void;\n\n  const state$ = combineLatest(...observables$).pipe(\n    map((states: [Key, Getter, Setter][]) =>\n      states.reduce(\n        (acc, [k, g, s]) => {\n          // Using Object.defineProperty to preserve the merging\n          // of getters and setters\n          Object.defineProperty(acc, k, {\n            get: g,\n            set: s\n          });\n\n          return acc;\n        },\n        {} as any\n      )\n    ),\n    tap(state => console.log('State, state', state)),\n    share()\n  );\n\n  return state$;\n};\n","import { combineLatest } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\n\nimport { todos$ } from \"../../modules/todo/observables\";\nimport { selectTodoFilter, filterTypeState$ } from \"../../modules/filter-todo\";\n\n/**\n * Observable returning todos filtered by selected filter type.\n */\nexport const todosByFilterType$ = combineLatest(\n  todos$,\n  filterTypeState$[0]\n).pipe(\n  map(\n    ([todos, filterType]) => selectTodoFilter(filterType)(todos)\n    // What I want is point-free but TypeScript can't handle me.\n    // fromAandBToC(\n    //   compose(\n    //     selectTodoFilter,\n    //     second\n    //   )\n  )\n);\n","import { identity } from '../utils'\n\nimport { FilterType } from './types'\nimport { filterActiveTodos, filterCompletedTodos  } from './filter'\nimport { isFilterTypeActive, isFilterTypeCompleted } from './assert'\n\n/**\n * selectTodoFilter :: FilterType -> [TodoWithOperation] -> [TodoWithOperation]\n * \n * Given a type of filter returns a function that filters a list of tuples of (Todo, TodoOperation)\n * \n */\nexport const selectTodoFilter = (filterType: FilterType) =>\n  isFilterTypeActive(filterType)\n    ? filterActiveTodos\n    : isFilterTypeCompleted(filterType)\n    ? filterCompletedTodos\n    : identity;","/**\n * @module todo\n */\nimport { Todo } from \"./types\";\n\n/**\n * isComplete :: Todo -> boolean\n */\nexport const isComplete = (todo: Todo) => todo.completed === true;\n","import { timeTravelableState$, State } from \"./state\";\nimport { map, filter } from \"rxjs/operators\";\n\nimport {\n  makeNoop,\n  toPending,\n  isPending,\n  isNoop,\n  isBad,\n  Noop\n} from \"../../modules/operations\";\n\nimport { FilterType } from \"../../modules/filter-todo\";\n\nimport {\n  dispatch,\n  makeEditEvent,\n  TodoOperation,\n  Todo,\n  makeSaveEvent,\n  MutableTodo,\n  makeDeleteEvent,\n  isComplete\n} from \"../../modules/todo\";\n\nimport { compose, second, tuple, first } from \"../../modules/utils\";\nimport { noop } from \"rxjs\";\n\nconst makeOnChangeFilterType = (state: State) => (filterType: FilterType) => {\n  state.filterType = filterType;\n};\n\nconst makeOnChangeNew = (state: State) => (title: string) => {\n  state.new = makeNoop(title);\n};\n\nconst makeOnSubmitNew = (state: State) => () => {\n  if (!isPending(state.new)) state.new = toPending(state.new);\n};\n\nconst makeOnEdit = (state: State) => (todo: Todo, operation: TodoOperation) => (\n  state: Partial<Pick<Todo, \"completed\" | \"title\">>\n) => {\n  if (isNoop(operation) || isBad(operation)) {\n    dispatch(\n      makeEditEvent(todo, {\n        ...operation,\n        state: {\n          ...operation.state,\n          ...state\n        }\n      })\n    );\n  }\n};\n\nconst makeOnSave = (todo: Todo, operation: TodoOperation) => (\n  state: Partial<Pick<Todo, \"completed\" | \"title\">> = {}\n) => {\n  if (isNoop(operation) || isBad(operation)) {\n    dispatch(\n      makeSaveEvent(todo, {\n        ...operation,\n        state: {\n          ...operation.state,\n          ...state\n        }\n      })\n    );\n  }\n};\n\nconst makeOnCompleteAll = (state: State) => () =>\n  state.todos\n    .filter(\n      compose(\n        a => !a,\n        compose(\n          isComplete,\n          first\n        )\n      )\n    )\n    .filter(\n      (todo): todo is [Todo, Noop<MutableTodo>] =>\n        isNoop(second(todo)) || isBad(second(todo))\n    )\n    .map(todo =>\n      tuple(first(todo), {\n        ...second(todo),\n        state: { ...second(todo).state, completed: true }\n      })\n    )\n    .forEach(todo => dispatch(makeSaveEvent(...todo)));\n\nconst makeOnClearComplete = (state: State) => () => {\n  state.todos\n    .filter(\n      compose(\n        isComplete,\n        first\n      )\n    )\n    .filter(\n      (todo): todo is [Todo, Noop<MutableTodo>] =>\n        isNoop(second(todo)) || isBad(second(todo))\n    )\n    .forEach(([todo]) => dispatch(makeDeleteEvent(todo)));\n};\n\n/**\n * Observable returning props\n */\nexport const props$ = timeTravelableState$.pipe(\n  // filter(<T>(stream: T | undefined): stream is T => !!stream),\n  map(([state, _, index, max]) => {\n    const isReplaying = index !== max\n\n    const onChangeFilterType = isReplaying ? noop : makeOnChangeFilterType(state);\n    const onChangeNew = isReplaying ? noop : makeOnChangeNew(state);\n    const onSubmitNew = isReplaying ? noop : makeOnSubmitNew(state);\n    const onEdit = isReplaying ? () => noop : makeOnEdit(state);\n    const onSave = isReplaying ? () => noop : makeOnSave;\n    const onCompleteAll = isReplaying ? noop : makeOnCompleteAll(state);\n    const onClearComplete = isReplaying ? noop : makeOnClearComplete(state);\n\n    return {\n      todos: state.todos,\n      new: state.new,\n      filterType: state.filterType,\n      onChangeFilterType,\n      onChangeNew,\n      onSubmitNew,\n      onEdit,\n      onSave,\n      onCompleteAll,\n      onClearComplete\n    }\n  })\n);\n","import React from \"react\";\nimport { noop } from \"rxjs\";\n\nimport TodoApp from \"./apps/todo/Todo\";\nimport Controls from \"./apps/state-replay/compontents/Controls\";\nimport Loading from \"./Loading\";\n\nimport { setIndex, play, pause } from \"./apps/todo/state\";\nimport { useTodoProps } from \"./apps/todo/hooks\";\n\nconst App = () => {\n  const [props, state] = useTodoProps();\n  if (props != null) {\n    const todoApp = (\n      <TodoApp\n        todos={props.todos}\n        new={props.new}\n        onChangeFilterType={\n          props.onChangeFilterType\n        }\n        onChangeNew={props.onChangeNew}\n        onSubmitNew={props.onSubmitNew}\n        filterType={props.filterType}\n        onEdit={props.onEdit}\n        onSave={props.onSave}\n        onCompleteAll={props.onCompleteAll}\n        onClearComplete={\n          props.onClearComplete\n        }\n      />\n    );\n\n    const controls = (\n      <Controls\n        index={state.index}\n        max={state.max}\n        setIndex={setIndex}\n        pause={pause}\n        play={play}\n      />\n    );\n\n    return (\n      <>\n        <div>\n          <div className=\"todomvc\">{todoApp}</div>\n        </div>\n        <div>{controls}</div>\n      </>\n    );\n  }\n\n  return <Loading />;\n};\n\nexport default App;\n","import * as React from \"react\";\nimport { tap } from \"rxjs/operators\";\n\nimport { dispatchFetch, handleEvents$ } from \"../../modules/todo\";\n\nimport { timeTravelableState$, Observed } from \"./state\";\nimport { props$ } from \"./select\";\n\nexport const useTodoProps = () => {\n  const [state, setState] = React.useState<{ index: number; max: number }>({\n    index: -1,\n    max: 0\n  });\n\n  const [props, setProps] = React.useState<\n    Observed<typeof props$> | undefined\n  >();\n\n  React.useEffect(() => {\n    const propsSubscription = props$.pipe(tap(setProps)).subscribe();\n\n    const handleEventsSubscription = handleEvents$.subscribe();\n\n    const stateSubscription = timeTravelableState$\n      .pipe(\n        tap(([, , index, max]) => setState({ index, max })),\n      )\n      .subscribe();\n\n    dispatchFetch()\n\n    return () => {\n      handleEventsSubscription.unsubscribe();\n      stateSubscription.unsubscribe();\n      propsSubscription.unsubscribe();\n    };\n  }, []);\n  debugger\n  return [props, state, setState] as const\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}