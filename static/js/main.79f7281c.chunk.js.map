{"version":3,"sources":["modules/todo/types.ts","modules/todo/utils.ts","apps/todo/components/Item.tsx","apps/todo/types.ts","apps/todo/components/List.tsx","modules/utils/index.ts","apps/todo/Todo.tsx","modules/rxjs-state/stateOf.ts","modules/todo/api.ts","modules/todo/constants.ts","modules/todo/events.ts","modules/todo/observables.ts","modules/utils/getset.ts","apps/todo/observables.ts","App.tsx","modules/rxjs-state/makeTimeTravelable.ts","modules/rxjs-state/createState.ts","serviceWorker.ts","index.tsx"],"names":["Status","EventType","makeIsStatus","statusType","checkedStatus","statusTypeIsOk","Ok","statusTypeIsBad","Bad","statusTypeIsNoop","Noop","statusTypeIsPending","Pending","makeIsOperationOfStatus","f","operation","status","isOk","isBad","isNoop","isPending","makeNoop","state","toPending","action","FilterType","Item","props","title","todo","style","opacity","isDeleting","transition","icon","completed","theme","undefined","onClick","onSave","error","fontStyle","List","newTodo","new","onChangeNew","noop","evt","currentTarget","value","className","twoLine","onCompleteAll","fullwidth","placeholder","height","onChange","onKeyUp","keyCode","onSubmitNew","autoFocus","trailingIcon","todos","map","key","id","onEdit","Delete","renderList","take","amount","xs","txs","len","length","i","push","first","thirst","second","threcond","tuple","a","b","thruple","c","makeIsFilterType","of","filterType","isFilterTypeAll","All","isFilterTypeCompleted","Completed","isFilterTypeActive","Active","makeFilterTodosByFilterType","filter","filterCompletedTodos","filterActiveTodos","identity","compose","g","list","textAlign","marginTop","use","choice","justifyContent","label","onChangeFilterType","onClearComplete","color","stateOf","initialState","piper","subject","BehaviorSubject","setState","console","info","JSON","stringify","next","getCurrentState","getValue","piped$","concat","asObservable","Object","assign","window","failPattern","failIndex","getNextFailFlag","delay","ms","Promise","resolve","setTimeout","read","fetch","response","json","create","doFail","Math","floor","random","userId","update","Save","trim","nextTodo","current","deleet","makeSaveEvent","type","makeIsEventType","eventType","isFetchEventType","Fetch","isEditEventType","Edit","isSaveEventType","isDeleteEventType","makeIsEventOfType","event","isFetchEvent","isEditEvent","isSaveEvent","isDeleteEvent","events$","Subject","dispatch","warn","$","pipe","tap","log","todos$","storeTodos","subs","subscribe","nbr","args","subscription","call","unsubscribe","storeTodo","get","mergeMap","stream","withLatestFrom","todoOrId","todoOperation","index","findIndex","nextTodos","splice","eventsHandler$","groupBy","actionsByGroup$","timeoutWith","EMPTY","ignoreElements","groupedEvent$","switchMap","from","noopOperation","makeEditEvent$","data","curry","clear","makeSaveEvent$","prop","getId","object","find","item","maybeTodo","pendingOperation","newTodoOperation$","state$","nextState","startWith","filterTypeState$","observable$","indexSubject","stateWithHistory$","Date","now","combineLatest","scan","history","nextIndex","share","playSubject","replay$","mode","s","timeline","setIndex","merge","result","makeTimeTravelable","mapOfObservables","observables$","keys","reduce","acc","Array","isArray","isStateObservable","nextState$","process","states","k","defineProperty","set","createState","selectTodoFilter","timeTravelableState$","play","pause","App","React","useState","max","useEffect","eventsHandlerSubscription","stateSubscription","isComplete","Todo","makeEditEvent","forEach","padding","onInput","detail","discrete","start","step","disabled","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.79f7281c.chunk.js","sourcesContent":["export type Todo = {\n  readonly id: number;\n  readonly title: string;\n  // userId: number;\n  readonly completed: boolean;\n};\n\nexport enum Status {\n  Noop = \"Noop\",\n  Pending = \"Pending\",\n  Ok = \"Ok\",\n  Bad = \"Bad\"\n}\n\nexport type Noop<T> = {\n  status: Status.Noop;\n  state: T;\n};\n\nexport type Pending<T, A = void> = {\n  status: Status.Pending;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Bad<T, A = void> = {\n  status: Status.Bad;\n  state: T;\n  error: string;\n} & (A extends void ? {} : { action: A });\n\nexport type Ok<T, A = void> = {\n  status: Status.Ok;\n  state: T;\n} & (A extends void ? {} : { action: A });\n\nexport type Operation<T, U = T, A = void> =\n  | Noop<T>\n  | Pending<T, A>\n  | Bad<T, A>\n  | (U extends void ? Noop<T> : Ok<U, A>);\n\n\n\nexport type NewTodoOperation = Operation<string, void>;\n\n// type Foo = Operation<string, boolean>\n\nexport type Mutable = Pick<Todo, \"completed\" | \"title\">;\n\nexport type OperationalEventTypes = EventType.Save | EventType.Delete;\n\nexport type TodoOperation = Operation<Mutable, Todo, OperationalEventTypes>;\n\n// Events\n\nexport enum EventType {\n  Fetch = \"Fetch\",\n  Edit = \"Edit\",\n  Save = \"Save\",\n  Delete = \"Delete\"\n}\n\nexport type FetchEvent = {\n  type: EventType.Fetch;\n};\n\nexport type EditEvent = {\n  type: EventType.Edit;\n  operation: Noop<Mutable> | Bad<Mutable, OperationalEventTypes>;\n  todo: Todo;\n};\n\nexport type SaveEvent = {\n  type: EventType.Save;\n  operation: Noop<Mutable> | Bad<Mutable, OperationalEventTypes>;\n  todo: Todo;\n};\n\nexport type DeleteEvent = {\n  type: EventType.Delete;\n  id: number;\n};\n\nexport type TodoEvent = FetchEvent | EditEvent | SaveEvent | DeleteEvent;\n","import {\n  Status,\n  Operation,\n  Todo,\n  Noop,\n  Bad,\n  Pending,\n} from \"./types\";\nimport { number } from \"prop-types\";\n\n// Assertions\nconst makeIsStatus = <T extends Status>(statusType: T) => (\n  checkedStatus: Status\n): checkedStatus is T => statusType === checkedStatus;\n\nexport const statusTypeIsOk = makeIsStatus(Status.Ok);\nexport const statusTypeIsBad = makeIsStatus(Status.Bad);\nexport const statusTypeIsNoop = makeIsStatus(Status.Noop);\nexport const statusTypeIsPending = makeIsStatus(Status.Pending);\n\n// type Foo = <S, O extends Operation<S>, A extends O['status']>\n\nexport const makeIsOperationOfStatus = <S extends Status>(\n  f: (statusType: Status) => statusType is S\n) => <O extends { status: Status }>(operation: O): operation is Extract<O, { status: S }> => f(operation.status)\n\nexport const isOk = makeIsOperationOfStatus(statusTypeIsOk);\nexport const isBad = makeIsOperationOfStatus(statusTypeIsBad);\nexport const isNoop = makeIsOperationOfStatus(statusTypeIsNoop);\nexport const isPending = makeIsOperationOfStatus(statusTypeIsPending);\n\nexport const makeNoop = <T>(state: T): Noop<T> => {\n  return {\n    status: Status.Noop,\n    state,\n  }\n}\n\n// export const toPendingWithAction = <T, A, B extends A>(operation: Noop<T> | Bad<T, A>, action: B): Pending<T, B> => toPending(operation, action)\n\n\nexport function toPending<T>(operation: Noop<T> | Bad<T>): Pending<T>\nexport function toPending<T, A>(operation: Noop<T> | Bad<T, A>, action: A): Pending<T, A>\nexport function toPending<T, A>(operation: Noop<T> | Bad<T, A>, action?: A): Pending<T, any> {\n  if (action != null) {\n    return {\n      status: Status.Pending,\n      state: operation.state,\n      action,\n    }\n  }\n\n  return {\n    status: Status.Pending,\n    state: operation.state,\n  }\n}","import * as React from \"react\";\nimport { Todo, Status, Mutable } from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\nimport { isBad, isPending, isOk, statusTypeIsPending, statusTypeIsBad, statusTypeIsOk } from \"../../../modules/todo/utils\";\n\nexport type PropsItem = {\n  todo: Todo;\n  status: Status,\n  error?: string,\n  onEdit: (state: Partial<Mutable>) => void;\n  onSave: (state?: Partial<Mutable>) => void;\n  isDeleting: boolean\n};\n\nexport const Item = (props: PropsItem) => (\n  <>\n    <R.ListItem title={props.todo.title} style={{opacity: props.isDeleting ? 0.5 : 1, transition: 'opacity 0.2s ease-in-out'}}>\n      <R.ListItemGraphic\n        icon={{\n          icon: props.todo.completed\n            ? \"check_circle_outline\"\n            : \"radio_button_unchecked\",\n          theme: props.todo.completed ? \"primary\" : undefined,\n          onClick: () =>\n            props.onSave({ completed: !props.todo.completed })\n        }}\n      />\n      <R.ListItemText>\n        <R.ListItemPrimaryText theme=\"secondary\">\n          {props.todo.title}\n        </R.ListItemPrimaryText>\n        <R.ListItemSecondaryText\n          theme={props.error ? \"error\" : undefined}\n          style={{ fontStyle: \"italic \" }}\n        >\n          {props.error\n            ? props.error\n            : props.status && statusTypeIsPending(props.status)\n            ? \"...busy\"\n            : \"Get to it!\"}\n        </R.ListItemSecondaryText>\n      </R.ListItemText>\n      <R.ListItemMeta\n        icon={\n          props.status == null ? (\n            \"\"\n          ) : statusTypeIsPending(props.status) ? (\n            <R.CircularProgress theme='secondary' />\n          ) : statusTypeIsBad(props.status) ? (\n            { icon: \"error\", theme: \"error\" }\n          ) : statusTypeIsOk(props.status) ? (\n            { icon: \"check\", theme: \"primary\" }\n          ) : (\n            \"\"\n          )\n        }\n      />\n    </R.ListItem>\n    <R.ListDivider />\n  </>\n);\n","export enum FilterType {\n  All = \"All\",\n  Active = \"Active\",\n  Completed = \"Completed\"\n}\n","import * as React from \"react\";\nimport { Todo, TodoOperation, NewTodoOperation, Status, Mutable, EventType } from \"../../../modules/todo/types\";\nimport * as R from \"rmwc\";\n\nimport { Item } from \"./Item\";\nimport {\n  isOk,\n  isPending,\n  isBad\n} from \"../../../modules/todo/utils\";\nimport { noop } from \"rxjs\";\n\nexport const renderList = (props: PropsList) =>\n  props.todos.map(([todo, operation]) => {\n\n    return (\n      <Item\n        key={todo.id}\n        todo={todo}\n        onEdit={props.onEdit(todo, operation)}\n        onSave={props.onSave(todo, operation)}\n        status={operation && operation.status}\n        isDeleting={isPending(operation) && operation.action === EventType.Delete}\n        error={\n          (operation && isBad(operation) && operation.error) || undefined\n        }\n      />\n    );\n  });\n\nexport type PropsList = {\n  todos: [Todo, TodoOperation][],\n  onEdit: (todo: Todo, operation: TodoOperation) => (state: Partial<Mutable>) => void;\n  onSave: (todo: Todo, operation: TodoOperation) => (state?: Partial<Mutable>) => void;\n  new: NewTodoOperation;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n};\n\nexport const List = (props: PropsList) => {\n  const newTodo = props.new;\n\n  const onChangeNew = isOk(newTodo)\n    ? noop\n    : (evt: React.FormEvent<HTMLInputElement>) => {\n        props.onChangeNew(evt.currentTarget.value);\n      };\n\n  return (\n    <R.List className=\"todo-list\" twoLine>\n      <R.ListItem>\n        <R.ListItemGraphic\n          title={\"Mark all as complete.\"}\n          icon={{ icon: \"keyboard_arrow_down\", onClick: props.onCompleteAll }}\n          theme=\"secondary\"\n        />\n        {isPending(props.new) ? (\n          <>\n            <R.ListItemText>\n              <R.ListItemPrimaryText theme=\"secondary\">\n                {props.new.state}\n              </R.ListItemPrimaryText>\n              <R.ListItemSecondaryText style={{ fontStyle: \"italic \" }}>\n                ...busy\n              </R.ListItemSecondaryText>\n            </R.ListItemText>\n            <R.ListItemMeta\n              icon={\n                props.new.status == null ? (\n                  \"\"\n                ) : isPending(props.new) ? (\n                  <R.CircularProgress theme=\"secondary\" />\n                ) : isBad(props.new) ? (\n                  { icon: \"error\", theme: \"error\" }\n                ) : isOk(props.new) ? (\n                  { icon: \"check\", theme: \"primary\" }\n                ) : (\n                  \"\"\n                )\n              }\n            />\n          </>\n        ) : (\n          <R.TextField\n            fullwidth\n            theme=\"textPrimaryOnDark\"\n            placeholder=\"Where do you want to go today?\"\n            style={{ height: \"100%\" }}\n            onChange={onChangeNew}\n            value={props.new.state || ''}\n            onKeyUp={evt => evt.keyCode === 13 && props.onSubmitNew()}\n            autoFocus\n            trailingIcon={isBad(props.new) ? {icon: 'error', theme: 'error'} : undefined}\n          />\n        )}\n      </R.ListItem>\n      <R.ListDivider />\n      {renderList(props)}\n    </R.List>\n  );\n};\n","import { Subject, Observable, merge, of } from \"rxjs\";\nimport { startWith, tap, withLatestFrom, map, delay, publish } from \"rxjs/operators\";\nimport { FilterType } from \"../../apps/todo/types\";\nimport { Todo, TodoOperation } from \"../todo/types\";\nimport * as React from \"react\";\n\n// Types\ntype F<A, B> = (a: A) => B\n\ntype Tuple<A, B> = [A, B]\n\n// Array functions\nexport const take = (amount: number) => <T>(xs: T[]) => {\n  const txs: T[] = [];\n  const len = xs.length;\n\n  for (let i = 0; i < len && i < amount; i += 1) {\n    txs.push(xs[i]);\n  }\n\n  return txs;\n};\n\n// Tuple functions\n\n/**\n * Returns the first element in a tuple.\n *\n * first :: ( (a, b) -> a)\n */\nexport const first = <A>([a]: [A, any] | readonly [A, any]) => a;\n\nexport const thirst = <A>([a]: [A, any, any] | readonly [A, any, any]) => a;\n/**\n * Returns the second element in a tuple.\n *\n * second :: ( (a, b) -> b)\n */\nexport const second = <B>([, b]: [any, B] | readonly [any, B]) => b;\n\nexport const threcond = <B>([, b]: [any, B, any] | readonly [any, B, any]) => b;\n\n/**\n * \n * @param a \n * @param b \n */\nexport const tuple = <A, B>(a: A, b: B): Tuple<A, B> => [a, b]\n\nexport const thruple = <A, B, C>(a: A, b: B, c: C): [A, B, C] => [a, b, c]\n\n/**\n * \n * @param f \n */\nexport const applyToSecond = <A, B>(f: F<A, B>) => <T>(t: Tuple<T, A>): Tuple<T, B> => tuple(first(t), f(second(t)))\n\n// Compositors for observables\nexport const mapToAfterMs = <B>(to: B, ms: number = 1000) => <A>(from: A) =>\n  merge(of(from), of(to).pipe(delay(ms)));\n\nexport const toNullAfterMs = (ms = 1000) => mapToAfterMs(null, ms);\n\n\n\n// Assertion functions\nexport const isNotNull = <T>(value: T | null): value is T => value != null;\n\nexport const makeIsFilterType = <T extends FilterType>(of: T) => (\n  filterType: FilterType\n): filterType is T => filterType === of;\n\nexport const isFilterTypeAll = makeIsFilterType(FilterType.All);\nexport const isFilterTypeCompleted = makeIsFilterType(FilterType.Completed);\nexport const isFilterTypeActive = makeIsFilterType(FilterType.Active);\n\n// Filter functions\nexport const makeFilterTodosByFilterType = <T extends FilterType>(\n  filterType: FilterType\n) => (todos: [Todo, TodoOperation][]) =>\n  filterType === FilterType.All\n    ? todos\n    : todos.filter(\n        ([todo]) =>\n          (isFilterTypeCompleted(filterType) && todo.completed) ||\n          (isFilterTypeActive(filterType) && !todo.completed)\n      );\n\nexport const filterCompletedTodos = makeFilterTodosByFilterType(\n  FilterType.Completed\n);\nexport const filterActiveTodos = makeFilterTodosByFilterType(\n  FilterType.Active\n);\n\n// Function functions\n\nexport const once = <A, B>(f: (a: A) => B) => {\n  let output: B | undefined;\n\n  return (a: A) => {\n    if (!output) {\n      output = f(a);\n    }\n\n    return output;\n  };\n};\n/**\n * Identify function\n *\n * identity :: a -> a\n */\nexport const identity = <T>(value: T) => {\n  return value;\n};\n\n/**\n * Function composition. f after g. g andThen f\n *\n * compose :: (b -> c) -> (a -> b) -> c\n */\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) =>\n  f(g(a));\n\n/**\n * \n * @param f \n */\nexport const flip = <A, B, C>(f: (a: A, b: B) => C) => (b: B, a: A) => f(a, b)\n\n/**\n * \n * @param f \n */\nexport const curry = <A, B, C>(f: (a: A, b: B) => C) => (a: A) => (b: B) => f(a, b)\n\n/**\n * Don't ask. I was experimenting with point-free. Basically:\n * - We get (a, b)\n * - Then apply f((a, b)) wich gives use (a -> c)\n * - and so we apply a to that to return c\n *\n *  fromAandBToC :: ( (a, b) -> a -> c) -> (a, b) -> c\n */\nexport const fromAandBToC = <A, B, C>(f: (ab: [A, B]) => (a: A) => C) => (\n  ab: [A, B]\n) => f(ab)(first(ab));\n\n// Selectors\nexport const selectTodoFilter = (filterType: FilterType) =>\n  isFilterTypeActive(filterType)\n    ? filterActiveTodos\n    : isFilterTypeCompleted(filterType)\n    ? filterCompletedTodos\n    : identity;\n","import * as React from \"react\";\nimport { Todo, Status, TodoOperation, NewTodoOperation, Mutable } from \"../../modules/todo/types\";\nimport { List } from \"./components/List\";\nimport { FilterType } from \"./types\";\nimport {\n  isFilterTypeAll,\n  isFilterTypeActive,\n  isFilterTypeCompleted\n} from \"../../modules/utils\";\n\nimport * as R from \"rmwc\";\n\nexport interface PropsTodo {\n  todos: [Todo, TodoOperation][];\n  filterType: FilterType;\n  new: Exclude<NewTodoOperation, { status: Status.Ok }>;\n  onChangeFilterType: (filterType: FilterType) => void;\n  onEdit: (todo: Todo, operation: TodoOperation) => (state: Partial<Mutable>) => void;\n  onSave: (todo: Todo, operation: TodoOperation) => (state?: Partial<Mutable>) => void;\n  onChangeNew: (title: string) => void;\n  onSubmitNew: () => void;\n  onCompleteAll: () => void;\n  onClearComplete: () => void;\n}\n\nexport default (props: PropsTodo) => {\n  // console.log(JSON.stringify(props, null, 2))\n  const list = (\n    <List\n      todos={props.todos}\n      onEdit={props.onEdit}\n      onSave={props.onSave}\n      onChangeNew={props.onChangeNew}\n      new={props.new}\n      onSubmitNew={props.onSubmitNew}\n      onCompleteAll={props.onCompleteAll}\n    />\n  );\n\n  return (\n    <>\n      <div style={{ textAlign: \"center\", marginTop: 15}}>\n        <R.Typography use=\"headline1\" theme=\"secondary\">\n          todos\n        </R.Typography>\n      </div>\n      <section className=\"todoapp\">\n        <section className=\"main\">{list}</section>\n        <footer className=\"footer\" style={{ textAlign: \"center\" }}>\n          <R.ChipSet choice style={{ justifyContent: \"center\" }}>\n            <R.Chip\n              label=\"All\"\n              theme={\n                isFilterTypeAll(props.filterType) ? \"secondaryBg\" : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.All)}\n            />\n            <R.Chip\n              label=\"Active\"\n              icon=\"radio_button_unchecked\"\n              theme={\n                isFilterTypeActive(props.filterType) ? \"secondaryBg\" : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.Active)}\n            />\n            <R.Chip\n              label=\"Completed\"\n              icon=\"check_circle_outline\"\n              theme={\n                isFilterTypeCompleted(props.filterType)\n                  ? \"secondaryBg\"\n                  : undefined\n              }\n              onClick={() => props.onChangeFilterType(FilterType.Completed)}\n            />\n          </R.ChipSet>\n\n          <div>\n            <R.Button onClick={props.onClearComplete}>Clear completed</R.Button>\n          </div>\n          <R.Typography use=\"caption\" style={{color: '#999  '}}>\n            <strong>\n              {props.todos.filter(([todo]) => !todo.completed).length}\n            </strong>{\" \"}\n            item left\n          </R.Typography>\n        </footer>\n      </section>\n    </>\n  );\n};\n","import { Observable, concat, BehaviorSubject } from \"rxjs\";\nimport { identity } from \"../utils\";\n\n/**\n * Similar to the what React's `useState` hook returns but for observables.\n */\nexport type StateObservable<T> = readonly [\n  Observable<T>,\n  (next: T) => void,\n  () => T\n];\n\n/**\n * Either [[StateObservable]] or [[Observable]]\n */\nexport type ObservableLike<T> = StateObservable<T> | Observable<T>;\n\n/**\n * Determines if the given observable like value is a [[StateObservable]]\n */\nexport const isStateObservable = <T>(\n  observable$: ObservableLike<T>\n): observable$ is StateObservable<T> => Array.isArray(observable$);\n\n/**\n *\n * @param initialState Initial state of the [[Subject]]\n * @param piper Callback for adding \"pipes\" aka operators to the subject's output.\n */\nexport const stateOf = <T>(\n  initialState: T,\n  piper: (o$: Observable<T>) => Observable<T> = identity\n): StateObservable<T> => {\n  // Create a new subject that will stream the state\n  const subject = new BehaviorSubject<T>(initialState);\n  // subject.subscribe(console.error)\n  const setState = (state: T) => {\n    console.info(`Updating state for ${JSON.stringify(initialState)}`)\n    // debugger\n    // nextState = state\n    subject.next(state);\n  };\n\n  const getCurrentState = () => subject.getValue();\n\n  // const nextState$ = of(void 0).pipe(\n  //   map(() => nextState)\n  // )\n\n  const piped$ = concat(piper(subject.asObservable()));\n\n  // const initialState$ = piped$\n\n  return [\n    piped$, // concat(nextState$, piped$),\n    setState,\n    getCurrentState\n  ] as const;\n};\n\nObject.assign(window, { stateOf });\n","import { URL } from \"./constants\";\n\nimport {\n  Ok,\n  Bad,\n  Status,\n  Pending,\n  Todo,\n  Noop,\n  Mutable,\n  TodoOperation,\n  EventType\n} from \"./types\";\n\nimport { take } from \"../utils\";\n\n/**\n * Mock database\n */\nlet todos: Todo[] = [];\n\nconst failPattern = [true, false, false, true, true, false, true]\nlet failIndex = 0\n\nconst getNextFailFlag = () => {\n  failIndex += 1\n\n  if (failIndex > failPattern.length - 1) {\n    failIndex = 0\n  }\n\n  return failPattern[failIndex]\n}\n\nconst delay = (ms: number) =>\n  new Promise<void>(resolve => setTimeout(resolve, ms));\n\n/**\n * \n */\nexport const read = async () => {\n  const doFail = getNextFailFlag()\n\n  if (todos.length <= 0) {\n    const response = await fetch(URL);\n    const json: Todo[] = await response.json();\n    await delay(1500);\n    todos = take(25)(json).map(todo => ({...todo, completed: false}));\n  } else {\n    await delay(1000);\n  }\n  return todos\n};\n\n/**\n * \n * @param operation \n */\nexport const create = async (\n  operation: Pending<string>\n): Promise<Ok<Todo> | Bad<string>> => {\n  const doFail = getNextFailFlag()\n\n  await delay(1500);\n\n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state\n    };\n  }\n\n  if (!operation.state) {\n    return {\n      status: Status.Bad,\n      error: \"A title is required!\",\n      state: operation.state\n    };\n  }\n\n  const todo = {\n    id: Math.floor(Math.random() * 10000),\n    userId: Math.floor(Math.random() * 10000),\n    title: operation.state,\n    completed: false\n  };\n\n  todos = [...todos, todo];\n\n  return {\n    status: Status.Ok,\n    state: todo\n  };\n};\n\nexport const update = async (\n  todo: Todo,\n  operation: Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Save> | Bad<Mutable, EventType.Save>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag()\n  \n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Something went terribly wrong!\",\n      state: operation.state,\n      action: EventType.Save\n    };\n  }\n\n  const title = operation.state.title.trim();\n\n  if (!title) {\n    return {\n      status: Status.Bad,\n      action: EventType.Save,\n      error: \"A title is required!\",\n      state: {\n        ...operation.state,\n        title\n      }\n    };\n  }\n\n  const nextTodo = {\n    ...todo,\n    ...operation.state,\n    title\n  };\n\n  todos = todos.map(current => {\n    if (current.id === nextTodo.id) {\n      return nextTodo;\n    }\n\n    return todo;\n  });\n\n  return {\n    status: Status.Ok,\n    state: { ...todo, ...operation.state, title },\n    action: EventType.Save\n  };\n};\n\nexport const deleet = async (\n  todo: Todo,\n  operation: Pending<Mutable, EventType.Delete>, //Exclude<TodoOperation, { status: Status.Ok | Status.Pending }>\n): Promise<Ok<Todo, EventType.Delete> | Bad<Mutable, EventType.Delete>> => {\n  await delay(1500);\n  const doFail = getNextFailFlag()\n  \n  if (doFail) {\n    return {\n      status: Status.Bad,\n      error: \"Unable to delete!\",\n      state: operation.state,\n      action: EventType.Delete\n    };\n  }\n\n  todos = todos.filter(current => current.id !== todo.id)\n\n  return {\n    status: Status.Ok,\n    state: todo,\n    action: EventType.Delete\n  };\n};\n","export const URL = 'https://jsonplaceholder.typicode.com/todos/'\n\n","import {\n  EventType,\n  FetchEvent,\n  TodoEvent,\n  SaveEvent,\n  DeleteEvent,\n  TodoOperation,\n  EditEvent,\n  Todo,\n  Noop,\n  Bad,\n  OperationalEventTypes\n} from \"./types\";\n\n/**\n * makeFetchEvent\n */\nexport const makeFetchEvent = (): FetchEvent => {\n  return { type: EventType.Fetch };\n};\n\n/**\n * makeEditEvent\n */\n\nexport const makeEditEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): EditEvent => {\n  return { type: EventType.Edit, todo, operation };\n};\n\n/**\n * makeSaveEvent\n */\nexport const makeSaveEvent = (\n  todo: Todo,\n  operation:\n    | Noop<Pick<Todo, \"completed\" | \"title\">>\n    | Bad<Pick<Todo, \"completed\" | \"title\">, OperationalEventTypes>\n): SaveEvent => {\n  return { type: EventType.Save, todo, operation };\n};\n\n/**\n * makeDeleteEvent\n */\nexport const makeDeleteEvent = (id: number): DeleteEvent => {\n  return { type: EventType.Delete, id };\n};\n\n/**\n * makeIsEventType\n */\nexport const makeIsEventType = <T extends EventType>(of: T) => (\n  eventType: EventType\n): eventType is T => eventType === of;\n\n/**\n * isFetchEventType\n */\nexport const isFetchEventType = makeIsEventType(EventType.Fetch);\n\n/**\n * isEditEventType\n */\nexport const isEditEventType = makeIsEventType(EventType.Edit);\n\n/**\n * isSaveEventType\n */\nexport const isSaveEventType = makeIsEventType(EventType.Save);\n\n/**\n * isDeleteEventType\n */\nexport const isDeleteEventType = makeIsEventType(EventType.Delete);\n\n/**\n * makeIsEventOfType\n */\nexport const makeIsEventOfType = <A extends EventType>(\n  f: (eventType: EventType) => eventType is A\n) => (event: TodoEvent): event is Extract<TodoEvent, { type: A }> =>\n  f(event.type);\n\n/**\n * isFetchEvent\n */\nexport const isFetchEvent = makeIsEventOfType(isFetchEventType);\n\n/**\n * isEditEvent\n */\nexport const isEditEvent = makeIsEventOfType(isEditEventType);\n\n/**\n * isSaveEvent\n */\nexport const isSaveEvent = makeIsEventOfType(isSaveEventType);\n\n/**\n * isDeleteEvent\n */\nexport const isDeleteEvent = makeIsEventOfType(isDeleteEventType);\n","import { Subject, from, of, EMPTY, concat } from \"rxjs\";\n\nimport {\n  tap,\n  map,\n  mergeMap,\n  share,\n  withLatestFrom,\n  switchMap,\n  groupBy,\n  timeoutWith,\n  ignoreElements,\n  startWith,\n  delay,\n  filter\n} from \"rxjs/operators\";\n\nimport { get, set } from \"../utils/getset\";\n\nimport { stateOf } from \"../rxjs-state\";\nimport { read, create, update, deleet } from \"./api\";\nimport {\n  TodoEvent,\n  Todo,\n  NewTodoOperation,\n  Status,\n  TodoOperation,\n  EventType,\n  SaveEvent,\n  EditEvent,\n  Operation,\n  Noop,\n  OperationalEventTypes,\n  Bad,\n  Mutable,\n  Pending\n} from \"./types\";\nimport {\n  isFetchEvent,\n  isEditEvent,\n  isSaveEvent,\n  isDeleteEvent\n} from \"./events\";\n\nimport {\n  tuple,\n  first,\n  second,\n  compose,\n  curry,\n  thruple,\n  threcond,\n  thirst\n} from \"../utils\";\nimport { makeNoop, isPending, isBad, isOk, toPending, isNoop } from \"./utils\";\n\n/**\n * Event stream\n */\nexport const events$ = new Subject<TodoEvent>();\n\n/**\n * Helper function for dispatching to the event stream.\n */\nexport const dispatch = (event: TodoEvent) => {\n  console.warn(`Dispatching ${event.type}`);\n  events$.next(event);\n};\n\ntype TodoWithOperation = [Todo, TodoOperation];\n/**\n * Fetches and streams ToDos\n */\nexport const [todos$, storeTodos] = stateOf<TodoWithOperation[]>([], $ =>\n  $.pipe(tap(() => console.log(\"Streaming Todos\")))\n);\n\n\nlet subs = 0;\n\nconst subscribe = todos$.subscribe\nObject.assign(todos$, {\n  subscribe: (...args: any[]) => {\n    const nbr = ++subs;\n\n    console.warn(`Subscribe ${nbr}`)\n    const subscription = subscribe.call(todos$, ...args)\n\n    if (subscription.unsubscribe) {\n      const unsubscribe = subscription.unsubscribe\n\n      Object.assign(subscription, {\n        unsubscribe: (...args: any[]) => {\n          console.info(args)\n          console.error(`Unsubscrube ${nbr}`)\n          subs--;\n          unsubscribe.call(subscription)\n        }\n      })\n    }\n\n    return subscription\n  }\n})\n\n/**\n *\n */\nconst readTodos$ = () =>\n  from(read()).pipe(\n    withLatestFrom(todos$),\n    map(([next, current]) => {\n      // TODO Filter out incoming todos that have matching ids with todos in state\n      const additional: TodoWithOperation[] = [\n        ...current,\n        ...next.map(todo => {\n          const noopOperation = makeNoop({\n            title: todo.title,\n            completed: todo.completed\n          });\n\n          return tuple(todo, noopOperation);\n        })\n      ];\n\n      return additional;\n    }),\n    tap(storeTodos)\n  );\n\n/** \n *\n * @param event\n */\nconst makeEditEvent$ = (event: EditEvent) =>\n  of(void 0).pipe(\n    withLatestFrom(todos$),\n    map(second),\n    map(todos => {\n      const index = todos.findIndex(([todo]) => todo.id === event.todo.id);\n      const nextTodos = [...todos];\n      nextTodos.splice(index, 1, [event.todo, event.operation]);\n      return nextTodos;\n    }),\n    tap(storeTodos),\n    map(nextTodos => tuple(event, nextTodos))\n  );\n\ntype TodoId = number;\n\n/**\n * Operator compositor for dispatching a single updated todo to state\n * @param get - Callback function that given stream S returns a tuple of a [[Todo]] or [[TodoId]] and [[TodoOperation]]\n */\nconst storeTodo = <S, O extends TodoOperation, T extends TodoId | Todo>(\n  get: (stream: S) => [Todo | TodoId, O]\n) =>\n  mergeMap((stream: S) =>\n    of(stream).pipe(\n      // Combine the stream with the most recent state of the list of todos\n      tap(() => console.error('withLatestFrom')),\n      withLatestFrom(todos$),\n      map(([stream, todos]) => {\n        const [todoOrId, todoOperation] = get(stream);\n\n        // Find the index of the operated todo in state\n        const index = todos.findIndex(\n          ([current]) =>\n            current.id ===\n            (typeof todoOrId === \"number\" ? todoOrId : todoOrId.id)\n        );\n\n        if (index >= 0) {\n          // Update state with data from the operated todo\n          const nextTodos = [...todos];\n          nextTodos.splice(index, 1, [\n            typeof todoOrId === \"number\" ? todos[index][0] : todoOrId,\n            todoOperation\n          ]);\n\n          return thruple(todoOperation, nextTodos, todoOrId);\n        }\n\n        return thruple(todoOperation, todos, todoOrId);\n      }),\n      tap(\n        compose(\n          storeTodos,\n          threcond\n        )\n      )\n    )\n  );\n\n/**\n *\n * @param event\n */\nconst makeSaveEvent$ = (event: SaveEvent) =>\n  concat(\n    // Update state for this todo to status \"Pending\"\n    of(toPending(event.operation, EventType.Save)).pipe(\n      tap(() => console.warn(`Storing pending todo`)),\n\n      storeTodo(stream => tuple(event.todo, stream)),\n      map(data => threcond(data)),\n      map(data => curry(tuple)(event)(data))\n    ),\n    // Continue with updating the the todo on the server\n    from(update(event.todo, event.operation)).pipe(\n      tap(console.clear),\n      storeTodo(stream => {\n        // const foo = isOk(stream)\n        //   ? tuple(stream.state, stream)\n        //   : tuple(event.todo, stream);\n        return tuple(isOk(stream) ? stream.state : event.todo, stream);\n        // return [event.todo, stream];\n      }),\n      map(thirst),\n      // or 5000 if the operation was Bad\n      // Delay the stream by 750ms if the operation was Ok\n      mergeMap(stream => of(stream).pipe(delay(isOk(stream) ? 750 : 5000))),\n\n      // Reset the todo in state to status \"Noop\"\n      storeTodo(stream => tuple(event.todo.id, makeNoop(stream.state))),\n      map(nextTodos => tuple(event, nextTodos))\n    )\n  );\n\n/**\n *\n */\nexport const handleEvents$ = events$.pipe(\n  tap(event => console.warn(`Handle event ${event.type}`)),\n  groupBy(\n    event => {\n      if (isFetchEvent(event)) {\n        return EventType.Fetch;\n      } else if (isEditEvent(event) || isSaveEvent(event)) {\n        return event.todo.id;\n      } else if (isDeleteEvent(event)) {\n        return event.id;\n      }\n    },\n    event => event,\n    actionsByGroup$ =>\n      actionsByGroup$.pipe(\n        timeoutWith(15000, EMPTY),\n        ignoreElements()\n      )\n  ),\n  mergeMap(groupedEvent$ =>\n    groupedEvent$.pipe(\n      switchMap(event => {\n        if (isFetchEvent(event)) {\n          return readTodos$().pipe(map(todos => tuple(event, todos)));\n        } else if (isEditEvent(event)) {\n          return makeEditEvent$(event);\n        } else if (isSaveEvent(event)) {\n          return makeSaveEvent$(event);\n        }\n\n        const getId = get(\"id\");\n\n        return of(void 0).pipe(\n          withLatestFrom(todos$),\n          map(second),\n          map(todos => todos.find(item => getId(first(item)) === getId(event))),\n          mergeMap(maybeTodo =>\n            maybeTodo\n              ? of(maybeTodo).pipe(\n                  filter(\n                    (\n                      data\n                    ): data is [\n                      Todo,\n                      Extract<\n                        TodoOperation,\n                        { status: Status.Noop | Status.Bad }\n                      >\n                    ] => isNoop(second(data)) || isBad(second(data))\n                  ),\n                  // I wish TypeScript had better type inference\n                  // storeTodo(applyToSecond(curry(flip(toPendingWithAction))(EventType.Delete))),\n                  storeTodo(([todo, operation]) =>\n                    tuple(todo, toPending(operation, EventType.Delete))\n                  ),\n                  mergeMap(([pendingOperation, _, todo]) =>\n                    from(\n                      deleet(\n                        todo as Todo,\n                        pendingOperation as Pending<Mutable, EventType.Delete>\n                      )\n                    ).pipe(\n                      mergeMap(stream => {\n                        if (isOk(stream)) {\n                          return of(void 0).pipe(\n                            withLatestFrom(todos$),\n                            map(second),\n                            tap(todos =>\n                              storeTodos(\n                                todos.filter(\n                                  ([todo]) => todo.id !== stream.state.id\n                                )\n                              )\n                            )\n                          );\n                        }\n\n                        return of(void 0).pipe(\n                          storeTodo(() => [first(maybeTodo), stream])\n                        );\n                      })\n                    )\n                  )\n                )\n              : of(tuple(event, undefined))\n          )\n        );\n      })\n    )\n  )\n);\n\n/**\n * Event stream filtered by type FETCH\n */\nexport const eventsHandler$ = handleEvents$;\n\n/**\n *\n */\nexport const newTodoOperation$ = stateOf<NewTodoOperation>(\n  {\n    status: Status.Noop,\n    state: \"\"\n  },\n  state$ =>\n    state$.pipe(\n      switchMap(state =>\n        isPending(state)\n          ? from(create(state)).pipe(\n              withLatestFrom(todos$),\n              tap(([nextState, todos]) => {\n                if (isOk(nextState))\n                  storeTodos([\n                    ...todos,\n                    tuple(nextState.state, makeNoop(nextState.state))\n                  ]);\n              }),\n              map(first),\n              map(nextState => (isBad(nextState) ? nextState : makeNoop(\"\"))),\n              startWith(state)\n            )\n          : of(state)\n      )\n      // share()\n    )\n);\n","export function get<K extends string>(prop: K) {\n  function getter<T extends { [P in K]?: any }>(object: T): T[typeof prop]\n  function getter<T extends { [P in K]: any }>(object: T) {\n    return object[prop]\n  }\n\n  return getter\n}\n\nexport function set<K extends string>(prop: K) {\n  function setter<T extends { [P in K]?: any }>(object: T, value: T[typeof prop]): T\n  function setter<T extends { [P in K]: any }>(object: T, value: T[typeof prop]): T {\n    return Object.assign(object, {\n      [prop]: value\n    })\n  }\n\n  return setter\n}\n\nexport interface GetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T): T[K]\n  <T extends { [P in K]: any }>(object: T): T[K]\n}\n\nexport interface SetProperty<K extends string> {\n  <T extends { [P in K]?: any }>(object: T, value: T[K]): T\n  <T extends { [P in K]: any }>(object: T, value: T[K]): T\n}\n    \n// Examples\n/*\ninterface User {\n    id: number,\n    username: string,\n}\n\ntype NewUser = Partial<User>\n    \nexport const getUserId = composeGetter('id')\n\ntype UsernameGetter = GetProperty<'username'>\nconst getUsername: UsernameGetter = composeGetter('username')\n\ndeclare const user: User\ndeclare const newUser: NewUser\n    \nconst userId = getUserId(user) // :number\nconst userUsername = getUsername(user) // :number | undefined\n\nconst newUserId = getUserId(newUser) // :number | undefined\nconst newUserUsername = getUsername(newUser) // :string | undefined\n\nconst nextUser = composeSetter('username')(newUser, 'foobar')\nconst nextUserUsername = nextUser.username // :string | undefined\n*/","import {\n  second,\n  selectTodoFilter,\n  compose,\n  fromAandBToC\n} from \"../../modules/utils\";\n\nimport { stateOf } from \"../../modules/rxjs-state\";\n\nimport { todos$ } from \"../../modules/todo/observables\";\n\nimport { FilterType } from \"./types\";\nimport { map, filter } from \"rxjs/operators\";\nimport { combineLatest } from \"rxjs\";\n\nexport const filterTypeState$ = stateOf(FilterType.All);\n\nexport const todosByFilterType$ = combineLatest(\n  todos$,\n  filterTypeState$[0]\n).pipe(\n  map(\n    ([todos, filterType]) => selectTodoFilter(filterType)(todos)\n    // fromAandBToC(\n    //   compose(\n    //     selectTodoFilter,\n    //     second\n    //   )\n    )\n);\n","import React from \"react\";\n\nimport TodoApp from \"./apps/todo/Todo\";\nimport { Slider, IconButton } from \"rmwc\";\n\nimport {\n  dispatch,\n  newTodoOperation$,\n  eventsHandler$\n} from \"./modules/todo/observables\";\n\nimport { tap, filter } from \"rxjs/operators\";\n\nimport { filterTypeState$, todosByFilterType$ } from \"./apps/todo/observables\";\nimport { createState, makeTimeTravelable } from \"./modules/rxjs-state\";\n\nimport { Observable, noop } from \"rxjs\";\nimport {\n  makeFetchEvent,\n  makeSaveEvent,\n  makeEditEvent,\n  makeDeleteEvent\n} from \"./modules/todo/events\";\nimport {\n  makeNoop,\n  toPending,\n  isPending,\n  isOk,\n  isBad,\n  isNoop\n} from \"./modules/todo/utils\";\nimport { TodoOperation, Todo, Mutable, Noop } from \"./modules/todo/types\";\nimport { FilterType } from \"./apps/todo/types\";\nimport { compose, first, second, tuple } from \"./modules/utils\";\n\nconst state$ = createState({\n  todos: todosByFilterType$,\n  filterType: filterTypeState$,\n  new: newTodoOperation$\n});\n\nconst [timeTravelableState$, setIndex, _, play, pause] = makeTimeTravelable(state$);\n\ntype Observed<T> = T extends Observable<infer S> ? S : never;\n\ntype State = {\n  data: Observed<typeof state$> | undefined;\n  index: number;\n  max: number;\n};\n\nconst App = () => {\n  console.log(\"Render App\");\n  const [state, setState] = React.useState<State>({\n    data: undefined,\n    index: -1,\n    max: 0\n  });\n\n  React.useEffect(() => {\n    // const todosSubscription = todosByFilterType$.pipe(tap(setTodos)).subscribe()\n\n    const eventsHandlerSubscription = eventsHandler$.subscribe();\n\n    const stateSubscription = timeTravelableState$\n      .pipe(\n        tap(([state, _, index, max]) => setState({ data: state, index, max })),\n        tap(state => Object.assign(window, { state }))\n      )\n      .subscribe();\n\n    dispatch(makeFetchEvent());\n\n    return () => {\n      eventsHandlerSubscription.unsubscribe();\n      stateSubscription.unsubscribe();\n    };\n  }, []);\n\n  const data = state.data;\n  if (data != null) {\n    const onChangeFilterType = (filterType: FilterType) => {\n      data.filterType = filterType;\n    };\n\n    const onChangeNew = (title: string) => {\n      data.new = makeNoop(title);\n    };\n\n    const onSubmitNew = () => {\n      if (!isPending(data.new)) data.new = toPending(data.new);\n    };\n\n    const onEdit = (todo: Todo, operation: TodoOperation) => (\n      state: Partial<Pick<Todo, \"completed\" | \"title\">>\n    ) => {\n      if (isNoop(operation) || isBad(operation)) {\n        dispatch(\n          makeEditEvent(todo, {\n            ...operation,\n            state: {\n              ...operation.state,\n              ...state\n            }\n          })\n        );\n      }\n    };\n\n    const onSave = (todo: Todo, operation: TodoOperation) => (\n      state: Partial<Pick<Todo, \"completed\" | \"title\">> = {}\n    ) => {\n      if (isNoop(operation) || isBad(operation)) {\n        dispatch(\n          makeSaveEvent(todo, {\n            ...operation,\n            state: {\n              ...operation.state,\n              ...state\n            }\n          })\n        );\n      }\n    };\n\n    const isComplete = (todo: Todo) => todo.completed === true;\n\n    const onCompleteAll = () =>\n      data.todos\n        .filter(\n          compose(\n            a => !a,\n            compose(\n              isComplete,\n              first\n            )\n          )\n        )\n        .filter(\n          (todo): todo is [Todo, Noop<Mutable>] =>\n            isNoop(second(todo)) || isBad(second(todo))\n        )\n        .map(todo =>\n          tuple(first(todo), {\n            ...second(todo),\n            state: { ...second(todo).state, completed: true }\n          })\n        )\n        .forEach(todo => dispatch(makeSaveEvent(...todo)));\n\n    const onClearComplete = () => {\n      data.todos\n        .filter(\n          compose(\n            isComplete,\n            first\n          )\n        )\n        .filter(\n          (todo): todo is [Todo, Noop<Mutable>] =>\n            isNoop(second(todo)) || isBad(second(todo))\n        )\n        .forEach(([todo]) => dispatch(makeDeleteEvent(todo.id)));\n    };\n\n    return (\n      <>\n        <div>\n          <div className=\"todomvc\">\n            <TodoApp\n              todos={data.todos}\n              new={data.new}\n              onChangeFilterType={\n                state.index !== state.max ? noop : onChangeFilterType\n              }\n              onChangeNew={state.index !== state.max ? noop : onChangeNew}\n              onSubmitNew={state.index !== state.max ? noop : onSubmitNew}\n              filterType={data.filterType}\n              onEdit={state.index !== state.max ? () => noop : onEdit}\n              onSave={state.index !== state.max ? () => noop : onSave}\n              onCompleteAll={state.index !== state.max ? noop : onCompleteAll}\n              onClearComplete={\n                state.index !== state.max ? noop : onClearComplete\n              }\n            />\n          </div>\n        </div>\n        <div>\n          <div style={{ padding: 15 }}>\n            <Slider\n              value={state.index}\n              // onChange={evt => setIndex(evt.detail.value)}\n              onInput={evt => {\n                setIndex(evt.detail.value);\n              }}\n              discrete\n              start={0}\n              max={state.max}\n              step={1}\n            />\n            <div className='controls'>\n              <IconButton\n                theme={state.index === 0 ? undefined : 'secondary'}\n                icon=\"fast_rewind\"\n                onClick={() => setIndex(0)}\n                disabled={state.index === 0}\n              />\n              <IconButton\n                theme={state.index === 0 ? undefined : 'secondary'}\n                icon=\"skip_previous\"\n                onClick={() => setIndex(state.index - 1)}\n                disabled={state.index === 0}\n              />\n              <IconButton theme=\"secondary\" icon=\"stop\" onClick={pause} />\n              <IconButton theme=\"secondary\" icon=\"play_circle_filled\" onClick={play} />\n              <IconButton\n                theme={state.index === state.max ? undefined : 'secondary'}\n                icon=\"skip_next\"\n                onClick={() => setIndex(state.index + 1)}\n                disabled={state.index === state.max}\n              />\n              <IconButton\n                theme={state.index === state.max ? undefined : 'secondary'}\n                icon=\"fast_forward\"\n                onClick={() => setIndex(state.max)}\n                disabled={state.index === state.max}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  return <div>Loading..</div>;\n};\n\nexport default App;\n","import {\n  Observable,\n  Subject,\n  combineLatest,\n  BehaviorSubject,\n  of,\n  interval,\n  EMPTY,\n  merge,\n  concat\n} from \"rxjs\";\nimport {\n  debounceTime,\n  scan,\n  startWith,\n  map,\n  withLatestFrom,\n  mergeAll,\n  tap,\n  delay,\n  mergeMap,\n  repeat,\n  switchMap,\n  filter,\n  share\n} from \"rxjs/operators\";\nimport { first, second, tuple } from \"../utils\";\n\n/**\n * Turns an observable into a time travelable\n * version of itself.\n *\n * It does this by creating a Subject to sink/stream the selected\n * historic index.\n *\n * Then it it creates `stateWithHistory$` which is just using\n * the `scan` operator to keep track of all emitted values.\n *\n * A final `index$` observable is created that only emits\n * index values that are within the bounds of the history\n * array's length.\n *\n * A final `state$` observable is created by combining\n * `index$` and `stateWithHistory$` to either select state\n * from the history array or return the active, current state\n * if the index is `-1`\n *\n * The return value of this function is a thruple of:\n * 0: The final `state$` observable\n * 1: A dispatch function for setting the selected index\n * 2: The `index$` observable emitting both the index and the maximum\n */\nexport const makeTimeTravelable = <T>(observable$: Observable<T>) => {\n  const indexSubject = new BehaviorSubject(-1);\n  const startDate = Date.now();\n\n  const stateWithHistory$ = combineLatest(indexSubject, observable$).pipe(\n    scan(\n      ([state, index, history], [nextIndex, nextState]) => {\n        return state !== nextState\n          ? ([\n              nextState,\n              index >= 0 && index + 1 < history.length ? index + 1 : -1,\n              state ? [...history, [state, Date.now()]] : []\n            ] as [T, number, [T, number][]])\n          : ([nextState, nextIndex, history] as [T, number, [T, number][]]);\n      },\n      [undefined, -1, []] as [T | undefined, number, [T, number][]]\n    ),\n    map(([state, index, history]) => {\n      if (index < 0 || index >= history.length) {\n        return [state, history, history.length, history.length] as const;\n      }\n\n      return [history[index][0], history, index, history.length] as const;\n    }),\n    share()\n  );\n\n  const playSubject = new Subject<\"PLAY\" | \"PAUSE\">();\n\n  const replay$ = playSubject.pipe(\n    withLatestFrom(stateWithHistory$),\n    switchMap(([mode, s]) => {\n      // debugger;\n      // console.log(\"switch\", mode, index);\n      if (mode === \"PLAY\") {\n        return concat(of(s), stateWithHistory$).pipe(\n          switchMap(([state, history, index]) => {\n            const timeline = state ? [...history, tuple(state, history[history.length - 1][1] + 250)] : history\n            const ms = index > 0 && timeline[index + 1]\n              ? timeline[index + 1][1] - timeline[index][1]\n              : 0;\n\n            return of(void 0).pipe(\n              delay(ms > 2500 ? 250 : ms),\n              tap(() => setIndex(timeline[index + 1] ? index + 1 : 0))\n            );\n          })\n        );\n      }\n\n      return EMPTY;\n    })\n  );\n\n  const setIndex = (index: number) => {\n    console.log(index);\n    indexSubject.next(index);\n  };\n\n  return [\n    merge(replay$, stateWithHistory$).pipe(\n      filter(result => !!result)\n    ) as typeof stateWithHistory$,\n    setIndex,\n    indexSubject.asObservable(),\n    () => playSubject.next('PLAY'),\n    () => playSubject.next('PAUSE')\n  ] as const;\n};\n","import { Observable, combineLatest } from \"rxjs\";\nimport { isStateObservable, StateObservable, ObservableLike } from \"./stateOf\";\nimport { map, tap, share } from \"rxjs/operators\";\n\n/**\n * Returns a type describing all keys of object T\n * that are of type V\n */\ntype KeyOfType<T, V> = {\n  [P in keyof T]: T[P] extends V ? P : never;\n}[keyof T];\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they belong to keys in type K\n */\ntype ReadonlyByKey<T extends {}, K extends keyof T> = Readonly<Pick<T, K>> &\n  Omit<T, K>;\n\n/**\n * Returns a type that makes all values of object T readonly\n * if they are of type V\n */\ntype ReadonlyByType<T, V> = ReadonlyByKey<T, KeyOfType<T, V>>;\n\n/**\n * An object representing a map of [[Observable]] or [[StateObserveable]]\n */\ntype MapOfObservables = {\n  [prop: string]: ObservableLike<any>;\n};\n\n/**\n * A type representing a map of values based on a map of\n * [[Observable]] or [[StateObservable]] and the values those\n * observable stream.\n *\n * For example\n *\n * ```ts\n * type Foo = MapOfStateFromMapOfObservables<{ bar: Observable<number>>, zax: StateObservable<string> }\n *\n * // equates to\n *\n * type Foo = { readonly bar: number, zax: string }\n * ```\n *\n */\ntype MapOfStateFromMapOfObservables<T> = {\n  [P in keyof T]: T[P] extends ObservableLike<infer B> ? B : never;\n};\n\n/**\n * State$ describes an [[Observable]] that emits a state object where\n * key/value pairs created by a sub [[Observable]] are immutable and\n * key/values streamed by a [[StateObservable]] are semi-mutuable in\n * the sense that you can change their value in an mutauble style as\n * a _setter_ has been defined for that key/value pair that will send\n * the assigned value to the StateObservable's [[Subject]]\n *\n */\nexport type State$<T extends MapOfObservables> = Observable<\n  MapOfStateFromMapOfObservables<ReadonlyByType<T, Observable<any>>>\n>;\n\n/**\n * Creates a single state observable from a map of [[ObservableLike]]\n */\nexport const createState = <T extends MapOfObservables>(\n  mapOfObservables: T\n): State$<T> => {\n  // Compile a list of keys that are part of the state object.\n  const keys = Object.keys(mapOfObservables);\n\n  // Reduce the list of keys to a list of observables where each observable\n  // is a thruple of the key, getter, and setter.\n  const observables$: Observable<\n    [string, () => any, () => void]\n  >[] = keys.reduce(\n    (acc, key) => {\n      const observable$ = mapOfObservables[key];\n\n      // If the observable is our custom StateObservable\n      if (isStateObservable(observable$)) {\n        // Destructure the StateObservable into it's actual observabble and dispatcher\n        const [state$, setState] = observable$;\n\n        // Map the state$ observable to a thruple of\n        // its key, getter, and setter\n        const nextState$ = state$.pipe(\n          map(state => {\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter\n              (nextState: any) => {\n                setState(nextState);\n              }\n            ];\n          })\n        );\n\n        // Add the composed state observable to the accumulator.\n        acc.push(nextState$);\n      }\n\n      // If the observable was just a regular observable\n      else {\n        const nextState$ = observable$.pipe(\n          map(state => {\n            // Map the state$ observable to a thruple of\n            // its key, getter, and setter\n            return [\n              // key\n              key,\n              // getter\n              () => state,\n              // setter that will log an error message in dev mode\n              (value: any) => {\n                if (process.env.NODE_ENV === \"development\") {\n                  console.error(\n                    `Attempting to mutate state \"${key}\" with value \"${value}\" of state with properties ${keys.join(\n                      \", \"\n                    )}`\n                  );\n                }\n              }\n            ];\n          }),\n          tap(state => console.warn(`Streaming [${key}]`)),\n\n        );\n\n        acc.push(nextState$);\n      }\n      return acc;\n    },\n    [] as any[]\n  );\n\n  // Combine the list of observables of [key, getter, setter]\n  // into a single state observable\n\n  type Key = string;\n  type Getter = () => any;\n  type Setter = () => void;\n\n  const state$ = combineLatest(...observables$).pipe(\n    map((states: [Key, Getter, Setter][]) =>\n      states.reduce(\n        (acc, [k, g, s]) => {\n          // Using Object.defineProperty to preserve the merging\n          // of getters and setters\n          Object.defineProperty(acc, k, {\n            get: g,\n            set: s\n          });\n\n          return acc;\n        },\n        {} as any\n      )\n    ),\n    tap(state => console.log('State, state', state)),\n    share()\n  );\n\n  return state$;\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}